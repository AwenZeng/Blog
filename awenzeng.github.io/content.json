[{"title":"Activity布局加载流程源码分析(III)","date":"2019-06-28T02:09:39.000Z","path":"2019/06/28/tech_android_framework_activity_loadLayout_III/","text":"在Activity布局加载流程源码分析(I)、Activity布局加载流程源码分析(II)、DecorView绘制流程源码分析与View绘制三大流程源码分析等四篇文章中，已经很详细分析了Acitivity的布局加载过程及布局的绘制过程。但在Activity布局加载流程源码分析(I) 中，对于setContentView(“资源文件”)怎么转化View的，没有细说，本篇博文主要想梳理一下这块内容（ps:面试的时候，被面试官问到，既然答不上来，所以决定对这部分知识也好好梳理一下）。 在开始分析之前，我们需要了解一些概念，如： PhoneWindow： 是Window类具体实现类，Activity中布局加载逻辑主要就是在此类中完成的。 LayoutInflater： 是布局填充类，主要就是将我们的layout转化为View。 XmlPullParser： 是XML解析器，主要是解析xml文件也即layout.xml文件。 一、源码分析从Activity布局加载流程源码分析(I)文中，我们知道，在Activity的onCreate()中setContentView()后，最后也是调用PhoneWindow中的setContentView()方法。源码如下：12345 //Activity中public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID);//核心代码 initActionBar(); &#125; 123456789101112131415161718192021222324//PhoneWindow中public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent);//核心代码 &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 这里我们主要来看核心代码，也即 mLayoutInflater.inflate(layoutResID, mContentParent)；其中mLayoutInflater的初始化主要是在PhoneWindow中构造方法中初始化的：1234public PhoneWindow(Context context) &#123; super(context); mLayoutInflater = LayoutInflater.from(context); &#125; 所以，重点我们还是来看一下LayoutInflater类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public abstract class LayoutInflater &#123; ....... /** * Obtains the LayoutInflater from the given context. */ public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(\"LayoutInflater not found.\"); &#125; return LayoutInflater; &#125; ....... //填充方法1 public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; /** * 填充方法2 * Inflate a new view hierarchy from the specified xml node. Throws * &#123;@link InflateException&#125; if there is an error. * */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123; return inflate(parser, root, root != null); &#125; /** * 填充方法3 * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); ....... final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; /** * 填充方法4 * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"inflate\"); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; ......... final String name = parser.getName(); .......... if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(\"&lt;merge /&gt; can be used only with a valid \" + \"ViewGroup root and attachToRoot=true\"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(\"Creating params from root: \" + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(\"-----&gt; start inflating children\"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(\"-----&gt; done inflating children\"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ........ return result; &#125; &#125; ..........&#125; 从上面代码我们知道，mLayoutInflater 的初始化，主要是从context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)中获取的。在LayoutInflater的源码中，还有多个inflate方法中，这里我们先来看看填充方法2：12345678910public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); ....... final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; 由代码易知，这里主要是从资源Resources中获取布局xml，通过res.getLayout(resource)得到一个Xml资源解析器XmlResourceParser，然后再调用填充方法4，这里的XmlResourceParser，我们也可以来看一下源码：1234567public interface XmlResourceParser extends XmlPullParser, AttributeSet, AutoCloseable &#123; /** * Close this interface to the resource. Calls on the interface are no * longer value after this call. */ public void close();&#125; 由上易知，XmlResourceParser也是一个接口，这里主要继承了三个类XmlPullParser（XML文件解析器）、AttributeSet（自定义属性值）、AutoCloseable ，主要是了后面解析服务。所以这里我们重点来看看Resource中的getLayout()方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Resources &#123; ........ public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException &#123; return loadXmlResourceParser(id, \"layout\"); &#125; ........ /*package*/ XmlResourceParser loadXmlResourceParser(int id, String type) throws NotFoundException &#123; synchronized (mAccessLock) &#123; TypedValue value = mTmpValue; if (value == null) &#123; mTmpValue = value = new TypedValue(); &#125; getValue(id, value, true); if (value.type == TypedValue.TYPE_STRING) &#123; return loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type); &#125; throw new NotFoundException( \"Resource ID #0x\" + Integer.toHexString(id) + \" type #0x\" + Integer.toHexString(value.type) + \" is not valid\"); &#125; &#125; /*package*/ XmlResourceParser loadXmlResourceParser(String file, int id, int assetCookie, String type) throws NotFoundException &#123; if (id != 0) &#123; try &#123; // These may be compiled... synchronized (mCachedXmlBlockIds) &#123; // First see if this block is in our cache. final int num = mCachedXmlBlockIds.length; for (int i=0; i&lt;num; i++) &#123; if (mCachedXmlBlockIds[i] == id) &#123; //System.out.println(\"**** REUSING XML BLOCK! id=\" // + id + \", index=\" + i); return mCachedXmlBlocks[i].newParser(); &#125; &#125; // Not in the cache, create a new block and put it at // the next slot in the cache. XmlBlock block = mAssets.openXmlBlockAsset( assetCookie, file); if (block != null) &#123; int pos = mLastCachedXmlBlockIndex+1; if (pos &gt;= num) pos = 0; mLastCachedXmlBlockIndex = pos; XmlBlock oldBlock = mCachedXmlBlocks[pos]; if (oldBlock != null) &#123; oldBlock.close(); &#125; mCachedXmlBlockIds[pos] = id; mCachedXmlBlocks[pos] = block; //System.out.println(\"**** CACHING NEW XML BLOCK! id=\" // + id + \", index=\" + pos); return block.newParser(); &#125; &#125; &#125; catch (Exception e) &#123; NotFoundException rnf = new NotFoundException( \"File \" + file + \" from xml type \" + type + \" resource ID #0x\" + Integer.toHexString(id)); rnf.initCause(e); throw rnf; &#125; &#125; throw new NotFoundException( \"File \" + file + \" from xml type \" + type + \" resource ID #0x\" + Integer.toHexString(id)); &#125; ........&#125; 通过上面代码我们知道，最后通过XmlBlock.newParser()生成一个xml解析器，也即是XmlResourceParser，从以上我们知道Android中布局文件用的xml解析方法就是PULL解析方式。 下面我们具体来看填充方法4：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 /** * 填充方法4 * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"inflate\"); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + \": No start tag found!\"); &#125; final String name = parser.getName(); .......... if (TAG_MERGE.equals(name)) &#123;//核心代码1 if (root == null || !attachToRoot) &#123; throw new InflateException(\"&lt;merge /&gt; can be used only with a valid \" + \"ViewGroup root and attachToRoot=true\"); &#125; rInflate(parser, root, inflaterContext, attrs, false);//核心代码2 &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs);//核心代码3 ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(\"Creating params from root: \" + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(\"-----&gt; start inflating children\"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true);//核心代码4 if (DEBUG) &#123; System.out.println(\"-----&gt; done inflating children\"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ........ return result; &#125; &#125; ..........&#125; 我们在写布局文件的时候，经常也会考虑到一些布局优化的问题，所以难免会用到include、merge、ViewStub标签，所以在XML解析的时候，需要针对此类标签作特别处理。 从上面代码中，我们来看核心代码1, TAG_MERGE.equals(name)，其中 TAG_MERGE就为merge，这里主要就是针对merge标签处理。我们先来看核心代码3和4，核心代码3： createViewFromTag(root, name, inflaterContext, attrs),具体我们也来看看源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123; return createViewFromTag(parent, name, context, attrs, false); &#125; /** * Creates a view from a tag name using the supplied attribute set. */ View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(\"view\")) &#123; name = attrs.getAttributeValue(null, \"class\"); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; if (name.equals(TAG_1995)) &#123; // Let's party like it's 1995! return new BlinkLayout(context, attrs); &#125; try &#123; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch (InflateException e) &#123; throw e; &#125; catch (ClassNotFoundException e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + \": Error inflating class \" + name); ie.initCause(e); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + \": Error inflating class \" + name); ie.initCause(e); throw ie; &#125; &#125; 我们也来看看核心代码4：rInflateChildren(parser, temp, attrs, true)，我们具体来看看相关代码：1234final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125; 通过上面发现，最后也还是调用了核心代码2，rInflate(parser, root, inflaterContext, attrs, false)，下面我们具体来看看核心代码2：1234567891011121314151617181920212223242526272829303132333435363738void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123;//代码1 if (parser.getDepth() == 0) &#123; throw new InflateException(\"&lt;include /&gt; cannot be the root element\"); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123;//代码2 throw new InflateException(\"&lt;merge /&gt; must be the root element\"); &#125; else &#123; final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125; &#125; 这里我们看到，主要就是通过PULL解析布局文件的方式解析出相关的View结构，具体PULL解析方式这里就不介绍了，小伙伴可以自行百度。在这里PULL解析的过程中，还对标签include,merge做了特别处理，是不是发现貌似代码中没有对标签ViewStub进行处理，其实是有的，主要是在createView()方法中，这里就不介绍了，小伙伴可以自行查一下源码。 好了，到这里，就差不多分析完了。 注：源码采用android-6.0.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 二、参考文档Activity布局加载流程源码分析(I) Activity布局加载流程源码分析(II) Android解析XML的三种方式","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"Android显示原理源码分析","date":"2018-03-05T12:42:59.000Z","path":"2018/03/05/tech_android_framework_surface_draw/","text":"在博文DecorView绘制流程源码分析中，我们对Android的显示原理简单的说了一下，但没有深入。在博文中我们只知道Choreographer(舞蹈指挥者)只是post了一个操作，但后面到底怎么执行的？按啥逻辑执行的？我们都不清楚，作为一个喜欢刨根问底的程序员，是必须要分析分析的。 在开始分析之前，我们需要了解一些概念，如： ViewRootImpl:是View的绘制的辅助类，所有View的绘制都离不开ViewRootImpl。 Choreographer：是”舞蹈指挥”者，控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。 DisplayEventReceiver：是一个抽象类，主要是接收显示绘制帧的垂直脉冲vsync,从而开始绘制帧。 FrameDisplayEventReceiver： Choreographer的内部类，也是DisplayEventReceiver具体实现类。 一、Android的显示原理Android的显示过程： i.应用层通过执行View三大绘制流程，把数据缓存在Surface上； ii.应用层通过跨进程通信机制，将数据传给系统层的SurfaceFlinger服务，SurfaceFlinger服务再通过硬件渲染到屏幕上； iii.通过Android刷新机制(每隔16ms会发出VSYNC信号),刷新界面。 1.应用层（Android应用程序）我们都知道一个Android的UI界面layout是整体一棵由很多不同层次的View组成的树形结构，它们存在着父子关系，子View在父View中，这些View都经过一个相同的流程最终显示到屏幕上。 关于View的绘制流程，在前面两篇博文DecorView绘制流程源码分析和View绘制三大流程源码分析中已经说过，这里就不再细说了，想了解的同学，可以回看一下前面的文章。 通过绘制流程，最后绘制数据都缓存到Surface上。 2.系统层（SurfaceFlinger服务）Android是通过系统级进程中的SurfaceFlinger服务来把真正需要显示的数据渲染到屏幕上。SurfaceFlinger的主要工作是： 响应客户端事件，创建Layer与客户端的Surface建立连接。 接收客户端数据及属性，修改Layer属性，如尺寸、颜色、透明度等。 将创建的Layer内容刷新到屏幕上。 维持Layer的序列，并对Layer最终输出做出裁剪计算。 因应用层和系统层分别是两个不同进程，需要一个跨进程的通信机制来实现数据传输，在Android的显示系统中，使用了Android的匿名共享内存：SharedClient。每一个应用和SurfaceFlinger之间都会创建一个SharedClient，每个SharedClient中，最多可以创建31个SharedBufferStack，每个Surface都对应一个SharedBufferStack，也就是一个window。这意味着一个Android应用程序最多可以包含31个窗口，同时每个SharedBufferStack中又包含两个(=4.1)缓冲区。 总结：应用层绘制到缓冲区，SurfaceFlinger把缓存区数据渲染到屏幕，两个进程之间使用Android的匿名共享内存SharedClient缓存需要显示的数据。 3.Android显示刷新机制Android系统一直在不断的优化、更新，但直到4.0版本发布，有关UI显示不流畅的问题仍未得到根本解决。 从Android4.1版本开始，Android对显示系统进行了重构，引入了三个核心元素：VSYNC, Tripple Buffer和Choreographer。VSYNC是Vertical Synchronized的缩写，是一种定时中断；Tripple Buffer是显示数据的缓冲区；Choreographer起调度作用，将绘制工作统一到VSYNC的某个时间点上，使应用的绘制工作有序进行。 Android在绘制UI时，会采用一种称为“双缓冲”的技术，双缓冲即使用两个缓冲区（在SharedBufferStack中），其中一个称为Front Buffer，另外一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。理想情况下，一个刷新会在16ms内完成（60FPS），下图就是描述的这样一个刷新过程（Display处理前Front Buffer，CPU、GPU处理Back Buffer。 i.没有VSYNC信号同步时 但实际运行时情况并不一定如此 第一个16ms开始：Display显示第0帧，CPU处理完第一帧后，GPU紧接其后处理继续第一帧。三者都在正常工作。 进入第二个16ms：因为早在上一个16ms时间内，第1帧已经由CPU，GPU处理完毕。故Display可以直接显示第1帧。显示没有问题。但在本16ms期间，CPU和GPU却并未及时去绘制第2帧数据（前面的空白区表示CPU和GPU忙其它的事），直到在本周期快结束时，CPU/GPU才去处理第2帧数据。 进入第三个16ms，此时Display应该显示第2帧数据，但由于CPU和GPU还没有处理完第2帧数据，故Display只能继续显示第一帧的数据，结果使得第1帧多画了一次（对应时间段上标注了一个Jank），导致错过了显示第二帧。 通过上述分析可知，此处发生Jank的关键问题在于，为何第1个16ms段内，CPU/GPU没有及时处理第2帧数据？原因很简单，CPU可能是在忙别的事情，不知道该到处理UI绘制的时间了。可CPU一旦想起来要去处理第2帧数据，时间又错过了。 为解决这个问题，Android 4.1中引入了VSYNC，核心目的是解决刷新不同步的问题。 ii.引入VSYNC信号同步后 在加入VSYNC信号同步后，每收到VSYNC中断，CPU就开始处理各帧数据。已经解决了刷新不同步的问题。但是上图中仍然存在一个问题：CPU和GPU处理数据的速度似乎都能在16ms内完成，而且还有时间空余，也就是说，CPU/GPU的FPS（帧率）要高于Display的FPS。由于CPU/GPU只在收到VSYNC时才开始数据处理，故它们的FPS被拉低到与Display的FPS相同。但这种处理并没有什么问题，因为Android设备的Display FPS一般是60，其对应的显示效果非常平滑。 但如果CPU/GPU的FPS小于Display的FPS，情况又不同了，将会发生如下图的情况： 在第二个16ms时间段，Display本应显示B帧，但却因为GPU还在处理B帧，导致A帧被重复显示。 同理，在第二个16ms时间段内，CPU无所事事，因为A Buffer被Display在使用。B Buffer被GPU在使用。注意，一旦过了VSYNC时间点，CPU就不能被触发以处理绘制工作了。 为什么CPU不能在第二个16ms处开始绘制工作呢？原因就是只有两个Buffer（Android 4.1之前）。如果有第三个Buffer的存在，CPU就能直接使用它，而不至于空闲。于是在Android4.1以后，引出了第三个缓冲区：Tripple Buffer。Tripple Buffer利用CPU/GPU的空闲等待时间提前准备好数据，并不一定会使用。 iii.引入Tripple Buffer后 引入Tripple Buffer后的刷新时序如下图： 上图中，第二个16ms时间段，CPU使用C Buffer绘图。虽然还是会多显示A帧一次，但后续显示就比较顺畅了。 是不是Buffer越多越好呢？回答是否定的。由上图可知，在第二个时间段内，CPU绘制的第C帧数据要到第四个16ms才能显示，这比双Buffer情况多了16ms延迟。所以缓冲区并不是越多越好。 注：2和3来源于Android绘制优化—-系统显示原理 三、Android显示原理源码分析我们接着DecorView绘制流程源码分析中Choreographer(舞蹈指挥者)post一个操作继续分析，我们来看相关源码，ViewRootImp中的scheduleTraversals()方法12345678void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; ...... mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);//核心代码 ...... &#125;&#125; 这里主要mChoreographer(舞蹈指挥者)作了一个postCallback操作，主要Action为mTraversalRunnable,我们再来看此变量：1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 从DecorView绘制流程知，doTraversal()方法主要功能就是执行绘制流程，也就是我们上面说应用层，主要就是把绘制数据缓存到surface上。前面两篇博文已经介绍过了，这里就不介绍了。 我们具体来看看 mChoreographer.postCallback()方法，mChoreographer为ViewRootImp的属性变量，其初始化主要也就是在ViewRootImp的构造方法中，具体我们来看一下：123456public ViewRootImpl(Context context) &#123; super(); ....... mChoreographer = Choreographer.getInstance(); ....... &#125; 这里主要用了单例模式来初始化mChoreographer，我们继续来看看Choreographer中的getInstance()方法1234567891011121314151617181920 public final class Choreographer &#123; ....... // Thread local storage for the choreographer. private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper();//1. if (looper == null) &#123; throw new IllegalStateException(\"The current thread must have a looper!\"); &#125; return new Choreographer(looper);//2. &#125; &#125;; public static Choreographer getInstance() &#123; return sThreadInstance.get(); &#125; .......&#125; 注释1处，通过Looper.myLooper()获取Looper，我们知道Choreographer主要是在ViewRootImpl的构造函数中初始化的，并且ViewRootImpl是运行在主线程中的，所以此处的Looper也即主线程的Looper。下面让我们继续来看看Choreographer中的postCallback()方法：123456789101112131415public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException(\"action must not be null\"); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException(\"callbackType is invalid\"); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125; 我们继续看看postCallbackDelayedInternal()方法12345678910111213141516171819202122232425private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG) &#123; Log.d(TAG, \"PostCallback: type=\" + callbackType + \", action=\" + action + \", token=\" + token + \", delayMillis=\" + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //1.将一个遍历操作Action加入数组队列,callbackType = Choreographer.CALLBACK_TRAVERSAL mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); //2.根据延迟时间来执行不同的操作 if (dueTime &lt;= now) &#123; scheduleFrameLocked(now);//3 &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125; 此方法主要就是将操作Action加入数组队列mCallbackQueues中，然后通过判断延迟时间执行操作，下面我们继续来看一下注释3，方法scheduleFrameLocked()1234567891011121314151617181920212223242526272829private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123;//是否用VSYNC脉冲 if (DEBUG) &#123; Log.d(TAG, \"Scheduling next frame on vsync.\"); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / NANOS_PER_MS + sFrameDelay, now); if (DEBUG) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 由英文注释知，当用VSYNC脉冲时，看是否在Looper线程也即主线程，如果在直接执行，如果不在就利用Handler消息机制，发送消息，然后执行；如果不用VSYNC脉冲，也是利用handler消息机制发送MSG_DO_FRAME消息执行，我们先来看立即执行方法scheduleVsyncLocked(),然后再看handler消息处理方法123private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 这里的mDisplayEventReceiver为FrameDisplayEventReceiver，也即调用FrameDisplayEventReceiver的scheduleVsync()方法，这里我们知道：FrameDisplayEventReceiver是绘制帧显示的接收器，专门接收系统层发送来的绘制消息。我们来看一下FrameDisplayEventReceiver123456789101112131415161718192021private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; private boolean mHavePendingVsync; private long mTimestampNanos; private int mFrame; public FrameDisplayEventReceiver(Looper looper) &#123; super(looper); &#125; @Override public void onVsync(long timestampNanos, int frame) &#123; ..... &#125; @Override public void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame); &#125; &#125; 由上知道FrameDisplayEventReceiver继承于抽象类DisplayEventReceiver，我们再来看抽象类的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class DisplayEventReceiver &#123; private static final String TAG = \"DisplayEventReceiver\"; private final CloseGuard mCloseGuard = CloseGuard.get(); private int mReceiverPtr; // We keep a reference message queue object here so that it is not // GC'd while the native peer of the receiver is using them. private MessageQueue mMessageQueue; //原生方法 private static native int nativeInit(DisplayEventReceiver receiver, MessageQueue messageQueue); private static native void nativeDispose(int receiverPtr); private static native void nativeScheduleVsync(int receiverPtr); /** * Creates a display event receiver. * * @param looper The looper to use when invoking callbacks. */ public DisplayEventReceiver(Looper looper) &#123; if (looper == null) &#123; throw new IllegalArgumentException(\"looper must not be null\"); &#125; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(this, mMessageQueue); mCloseGuard.open(\"dispose\"); &#125; ....... /** * Called when a vertical sync pulse is received. * The recipient should render a frame and then call &#123;@link #scheduleVsync&#125; * to schedule the next vertical sync pulse. * 当收到一个VSYNC脉冲时就会执行此方法 * * @param timestampNanos The timestamp of the pulse, in the &#123;@link System#nanoTime()&#125; * timebase. * @param frame The frame number. Increases by one for each vertical sync interval. */ public void onVsync(long timestampNanos, int frame) &#123; &#125; /** * Schedules a single vertical sync pulse to be delivered when the next * display frame begins. */ public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125; &#125; // Called from native code. @SuppressWarnings(\"unused\") private void dispatchVsync(long timestampNanos, int frame) &#123; onVsync(timestampNanos, frame); &#125;&#125; 从此类知，最后调用了原生方法nativeScheduleVsync()，系统发出一个VSYNC脉冲。 我们再来看非Looper线程的情况，Handler消息是怎么处理操作的，我们继续来看handler的处理方法：1234567891011121314151617181920private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME://直接执行绘制帧 doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync();//通过上面，我们知道这方法最后会发出一个VSYNC信号，从而触发绘制操作 break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125; &#125; 我们来看看doScheduleCallback(msg.arg1)方法12345678910void doScheduleCallback(int callbackType) &#123; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; final long now = SystemClock.uptimeMillis(); if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123; scheduleFrameLocked(now);//核心方法 &#125; &#125; &#125;&#125; 此方法最后又回到我们前面的方法，又会按相关逻辑执行一遍。所以这里我们主要来看执行绘制帧的方法doFrame()12345678void doFrame(long frameTimeNanos, int frame) &#123; ...... doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); ...... &#125; 在doFrame()中，我们了解到在Choreographer中，主要就是同步处理输入(CALLBACK_INPUT)、动画(CALLBACK_ANIMATION)、绘制(CALLBACK_TRAVERSAL)三个UI操作，也即应用层绘制操作，doFrame()方法主要就是绘制帧。我们具体来看看doCallbacks()方法123456789101112131415161718192021222324252627282930313233void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; // We use \"now\" to determine when callbacks become due because it's possible // for earlier processing phases in a frame to post callbacks that should run // in a following phase, such as an input event that causes an animation to start. final long now = SystemClock.uptimeMillis(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now); if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true; &#125; try &#123; for (CallbackRecord c = callbacks; c != null; c = c.next) &#123;//循环操作数组队列 if (DEBUG) &#123; Log.d(TAG, \"RunCallback: type=\" + callbackType + \", action=\" + c.action + \", token=\" + c.token + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; &#125; &#125; 通过此方法知，主要就是执行数组队列中的run方法，从而实现View的绘制。 主动执行绘制操作的流程我们清楚了，但当系统层发出VSYNC信号，Android系统又是怎么接收的呢？我们在阅读FrameDisplayEventReceiver和DisplayEventReceiver源码时，通过注释发现，当FrameDisplayEventReceiver收到VSYNC信号时，就会调用onVsync()方法，我们来看看此方法：1234567891011121314@Override public void onVsync(long timestampNanos, int frame) &#123; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. ....... mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS); &#125; 这里msg.what没有赋值，我们知道默认值为0，而MSG_DO_FRAME的值也为0，也就说最后调用了doFrame()方法，所以当收到系统层发出VSYNC信号时，就会执行绘制帧的方法。所以当系统间隔16ms发出VSYNC信号脉冲，就会执行绘制方法doFrame()。 到此，Android显示原理的源码就分析完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 四、参考文档Android绘制优化—-系统显示原理 Android UI绘制原理(二) Android Choreographer 源码分析 Android SurfaceFlinger服务启动过程源码分析","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"Android事件分发机制源码分析","date":"2018-01-09T11:17:17.000Z","path":"2018/01/09/tech_android_framework_dispatch_event/","text":"昨天我们对View绘制三大流程源码已做了深入分析，所以关于View的绘制流程，我相信大家也有了一个大致的了解(如果不了解，请回看博文)。然而对于View，还有一个知识点，也是极其重要的，那就是View的事件分发机制(也即Android事件分发机制)。所以，今天我们就来谈谈View的事件分发机制，从源码的角度，跟随Touch事件流，走一遍流程。 在开始分析之前，我们需要了解一些概念，如一次Touch事件，可能包括下面三个事件： MotionEvent.ACTION_DOWN： 表示手指按下事件，一个事件的开始。 MotionEvent.ACTION_MOVE： 表示手指移动事件，事件的持续移动。 MotionEvent.ACTION_UP： 表示手指抬起事件，一个事件的结束。 一、View事件分发流程图在具体分析之前，我们先来看一下事件分发流程图，以便我们更好的理解内容。图如下 二、View事件分发机制分析由Android系统的启动，Lancher系统的启动相关知识，我们知道，当我们点击手机屏幕，主要是通过硬件传感器传输事件，传感器会将其Touch事件传给我们界面使者Activity。当事件传给Activity后，Activity会进行事件分发，会调用Activity的dispatchTouchEvent()方法进行事件分发，我们就从此方法开始来分析。我们来看具体源码123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;//1. onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123;//2.事件继续分发 return true; &#125; return onTouchEvent(ev);//3.Activity自身onTouchEvent()方法&#125; 在注释1处，主要对事件进行判断，当Touch事件为MotionEvent.ACTION_DOWN事件时，会执行onUserInteraction()方法，查看源码发现，此方法是一个空方法。主要作用就是当各种事件key，touch或trackball分发到Activity时，都会执行此方法。 我们先来看注释3，当事件都没有被消费，及getWindow().superDispatchTouchEvent(ev)返回falses时，就会调用Activity自己的onTouchEvent()方法，自己对事件进行消费。 我们再来看注释2，getWindow().superDispatchTouchEvent(ev)，从Activity布局加载流程源码分析(I)中，我们知道getWindow()返回的是PhoneWindow,所以我们来看看PhoneWindow中的superDispatchTouchEvent()方法1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 由Activity布局加载流程源码分析(I)，我们也知，mDecor就是DecorView，所以我们继续来看DecorView中的superDispatchTouchEvent()方法123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 由DecorView绘制流程源码分析博文，我们知道，DecorView继承于FrameLayout,FrameLayout由继承于ViewGroup,ViewGroup又继承于View。通过分析相互关系，知最后调用的是ViewGroup的dispatchTouchEvent()方法(FrameLayout没有实现此方法)，所以我们继续来看看ViewGroup中的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123;//1.过滤Touch事件 final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //初始化down事件 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev);//清除前一个事件的目标及事件状态 resetTouchState();//重置事件状态 &#125; // 检测是否拦截事件 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev);//2.拦截事件调用方法 ev.setAction(action); //重置Action事件，以防被修改 &#125; else &#123; intercepted = false; &#125; &#125; else &#123; //没有touch目标直接拦截事件 intercepted = true; &#125; // 检测事件是否取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123;//当事件没有取消并没有被拦截时，执行事件分发 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; ....... final int childrenCount = mChildrenCount; if (childrenCount != 0) &#123; // Find a child that can receive the event. // Scan children from front to back. final View[] children = mChildren; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;//3.子View事件分发 // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = i; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; ........//省略部分，如果事件被取消，那就分发取消事件 return handled; &#125; 我们来看注释1处，事件过滤onFilterTouchEventForSecurity(),此方法为View中的方法，我们来看看此方法123456789public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123; //noinspection RedundantIfStatement if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123; // 当Window被遮盖，就丢弃此事件 return false; &#125; return true;&#125; 这里主要就是对Window是否被遮盖进行判断，从而决定事件是否进行传递。事件要进行传递，首先就是Window没有被遮盖。我们再来看看注释2，拦截方法onInterceptTouchEvent(),此方法是ViewGroup特有的，也只有ViewGroup可以进行事件拦截。我们来看看ViewGroup的此方法123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false;&#125; 这里是直接返回了false，也就是不拦截事件。如果返回true,也就会拦截事件。在我们开发的过程中，经常会出现一些事件冲突，而往往解决这些事件冲突的途径，也都是在我们自定义的ViewGroup中复写拦截方法onInterceptTouchEvent()，重写返回值，从而解决事件冲突问题。我们继续往下走，当不拦截事件后，我们就对子View进行事件分发，这里我们继续来看注释3，方法dispatchTransformedTouchEvent()12345678910111213141516171819202122232425262728293031323334353637private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //当为取消事件时，就分发取消事件ACTION_CANCEL final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ........ //ViewGroup是否有子View if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 这里主要对ViewGroup是否有子View做了一个判断，如果ViewGroup无子View，那直接调用ViewGroup父类View的dispatchTouchEvent()方法;如果有子View，那就调用子View的dispatchTouchEvent()方法；其实也都是View类的dispatchTouchEvent()方法，但这里需要注意一下，如果子View又是ViewGroup，那样当调用dispatchTouchEvent()方法时，那就调用ViewGroup的dispatchTouchEvent()事件分发方法，需要重走一遍分发流程。我们这里把子View就看成View了，所以我们就来看看此方法1234567891011121314151617181920212223public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;//1.实现OnTouchListener接口 return true; &#125; if (onTouchEvent(event)) &#123;//2.View自身的OnTouchEvent事件 return true; &#125; &#125; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; return false; &#125; 从注释1处知，当事件分发到View后，首先调用的接口OnTouchListener的实现方法(在我们开发的时候，经常会对View或ViewGroup设置一些Touch的监听事件)，然后才调用注释2的OnTouchEvent()方法，我们也来看看View的OnTouchEvent()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Touch事件的具体实现方法 * * @param event The motion event. * @return 返回true，此事件被消费，返回false,则没被消费 */public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; ........ //对View是否可以消费点击事件做判断，是否设置点击事件，是否可点击 if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||(viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP://手指抬起up事件 boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; setPressed(true);//Button按压状态变化通知 &#125; if (!mHasPerformedLongPress) &#123; removeLongPressCallback();//去除长按状态 //执行点击事件 if (!focusTaken) &#123; if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick();//消费点击事件 &#125; &#125; &#125; ....... removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN://手指按下down事件 ...... break; case MotionEvent.ACTION_CANCEL://事件取消 setPressed(false); removeTapCallback(); break; case MotionEvent.ACTION_MOVE://手指移动move事件 final int x = (int) event.getX(); final int y = (int) event.getY(); ....... break; &#125; return true; &#125; return false;&#125; 此方法主要是消费事件的方法，当View设置了点击事件或长按事件，那就会对事件进行消费。当手指抬起，也就是ACTION_UP事件时，就执行点击事件方法performClick(),我们也再来看看此方法123456789101112public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this);//实现OnClickListener接口 return true; &#125; return false;&#125; 到这里，主要就是实现了View的onClickListener接口的方法onClick(),也就消费了点击事件。但如果View没有设置点击事件，那就不会消费此方法，而在ViewGroup分发事件的时候就已判断过是否有子View，此时当子View和ViewGroup都没有设置点击事件时，就会直接返回false给上一级，上一级如果也是ViewGroup，那也是类似，如果都返回false，那样事件就将会被Activity的OnTouchEvent()消费掉。 到这里，Android的事件传递我们就分析完了。 注意： 只要有一个View消费了ACTION_DOWN事件，剩余的所有事件(ACTION_MOVE、ACTION_UP等)都将由此View消费。 源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、参考文档Android View 事件分发机制 源码解析（ViewGroup篇） Activity布局加载流程源码分析(I) DecorView绘制流程源码分析","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"View绘制三大流程源码分析","date":"2018-01-08T11:39:30.000Z","path":"2018/01/08/tech_android_framework_view_draw/","text":"在上篇博文DecorView绘制流程源码分析中，关于DecorView作为Activity、Window中的顶级View的绘制，我们已经作了一个详细的分析。但在具体说到View的绘制的时候，我们没有详细说明，所以本篇博文将会对View的绘制原理作深度分析。 在开始分析之前，我们需要了解一些概念，如： View：是所有UI组件的基类,是Android平台中用户界面体现的基础单位。 ViewGroup:是容纳UI组件的容器,它本身也是View的子类。 ViewRootImpl:是View的绘制的辅助类，所有View的绘制都离不开ViewRootImpl。 MeasureSpec： View的内部类，主要就是View测量模式的工具类 一、View绘制三大流程分析在DecorView的具体绘制中，我们涉及了View绘制的三大流程，具体分别为measure(测量)、layout(布局)和draw(绘制)。下面我们就来一一分析： 1.performMeasure(测量) 我们知道ViewRootImpl是View绘制的辅助类，View的绘制都是在ViewRootImpl的帮助下完成的，所以要了解View的measure(测量)，我们就必须看看ViewRootImpl中的performMeasure()方法12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 在DecorView绘制流程源码分析中，我们知道mView就是DecorView,而DecorView继承于FrameLayout,FrameLayout又继承于ViewGroup，ViewGroup又继承于View，根据他们之间的关系，我们知道，mView.measure()是调用了父类View的measure()方法(因为只有View有measure方法)，所以来分析View的measure()方法12345678910111213public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; if ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || ........ onMeasure(widthMeasureSpec, heightMeasureSpec);//核心方法 ........ &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec;&#125; 此onMeasure()方法，在DecorView，Framelayout和View中都有定义，并且DecorView和FrameLayout重载了此方法，根据调用关系，这里调用了DecorView的onMeasure(),我们来看看此方法1234567891011121314@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; final DisplayMetrics metrics = getContext().getResources().getDisplayMetrics(); final boolean isPortrait = metrics.widthPixels &lt; metrics.heightPixels; final int widthMode = getMode(widthMeasureSpec); final int heightMode = getMode(heightMeasureSpec); ...... super.onMeasure(widthMeasureSpec, heightMeasureSpec); ...... &#125; 关于测量模式，这里我们先不说，后面我们会说到，这里调用了父类FrameLayout中的onMeasure()方法，这里我们来看一下源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); ........//计算top,left,bottom,right的margin值，从而确定FrameLayout的宽高 //设置宽高 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = mMatchParentChildren.get(i);//获取子View final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();//子View配置参数 int childWidthMeasureSpec; int childHeightMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) &#123; childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin, MeasureSpec.EXACTLY); &#125; else &#123; childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); &#125; if (lp.height == LayoutParams.MATCH_PARENT) &#123; childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin, MeasureSpec.EXACTLY); &#125; else &#123; childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); &#125; child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; &#125; &#125; 由于FrameLayout是一个容器，可以装载其他的View，所以这里需要进行遍历其中的子View，并一一进行measure(测量)。 在具体说此方法前，我们先要了解一下View的测量模式及MeasureSpec类，具体我们先来看看MeasureSpec类的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. * 父View不对子View有任何限制，子View需要多大就多大 */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. * 父View已经测量出子View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值。对应于match_parent和精确数* 值这两种模式 */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. * 子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值，即对应wrap_content这种模式。 */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; /** * 用实际值和测量模式组装成measureSpec测量规格 * 将size和mode打包成一个32位的int型数值 * 高2位表示SpecMode，测量模式，低30位表示SpecSize，某种测量模式下的规格大小 */ public static int makeMeasureSpec(int size, int mode) &#123; return size + mode; &#125; //将32位的MeasureSpec解包，返回SpecMode,测量模式(EXACTLY、UNSPECIFIED或AT_MOST） public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //将32位的MeasureSpec解包，返回SpecSize public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125;&#125; 这里主要通过位运算，来实现View的三种测量模式UNSPECIFIED、EXACTLY和AT_MOST。相关定义如下： UNSPECIFIED：父View不对子View有任何限制，子View需要多大就多大 EXACTLY：父View已经测量出子View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值。对应于match_parent和精确数值这两种模式 AT_MOST： 子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值，即对应wrap_content这种模式。 我们继续上面FrameLayout的onMeasure()方法继续分析，可以发现，此方法主要就是组装子View宽高的测量规格MeasureSpec，然后作为参数传给子View的measure()方法。这里我们只来看一个组装就好，我们来看宽的组装的测量规格MeasureSpec，我们来看看相关代码12345678910111213141516171819202122 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ........ final View child = mMatchParentChildren.get(i);//获取子View final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();//子View配置参数 int childWidthMeasureSpec; int childHeightMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) &#123; childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin, MeasureSpec.EXACTLY); &#125; else &#123; childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); &#125; ........&#125; 当子View的布局参数lp.width为LayoutParams.MATCH_PARENT时，生成后的测量规格MeasureSpec是以测量模式为MeasureSpec.EXACTLY的值。当lp.width不为LayoutParams.MATCH_PARENT时，这是调用了ViewGroup中的getChildMeasureSpec()方法，来生成相关值，这里我们来看此方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 这里主要传入了FrameLayout的测量规格MeasureSpec，根据FrameLayout的测量规格和子View具体的padding和childDimension值，从而决定子view宽的测量规格MeasureSpec。具体创建细节，这里就不说。回到FrameLayout的onMeasure()方法，这样当子View的宽高的测量规格都计算出来之后，就会调用子View的measure()方法。如果子View不再是ViewGroup，那样就会调用子View(或自定义View)的onMeasure()方法，从而完成View的测量；如果子View还是ViewGroup，那就会按我们说的逻辑再走一遍measure方法。 2.performLayout(布局)说完View绘制的measure(测量)，我们来看看View绘制的layout(布局)。同样的，我们先来看ViewRootImpl中的performLayout()方法1234567891011121314151617private void performLayout() &#123; mLayoutRequested = false; mScrollMayChange = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123; Log.v(TAG, \"Laying out \" + host + \" to (\" + host.getMeasuredWidth() + \", \" + host.getMeasuredHeight() + \")\"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"layout\"); try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 由相关继承类的关系，我们知道，这里调用的是View的layout()方法123456789101112131415161718192021222324public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b);//核心方法 mPrivateFlags &amp;= ~LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT; &#125; 通过源码我们知道，ViewGroup是一个抽象的View的子类，而FrameLayout是ViewGroup的实现类，所以这里onLayout()是FrameLayout中的方法，我们来看一下此方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); mForegroundBoundsChanged = true; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getResolvedLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.LEFT: childLeft = parentLeft + lp.leftMargin; break; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = parentRight - width - lp.rightMargin; break; default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; &#125; 这里主要就是通过padding和margin算出子View的top,left,bottom,right四个顶点的值，从而再调其子View的layout方法。如果子View child不是ViewGroup，最后直接调用子View(或自定义View)的onLayout()方法，如果child是ViewGroup，那就再走一遍流程。 3.performDraw(绘制) 从DecorView绘制流程源码分析中，我们知道performDraw()绘制有两种方式，分别为Hardware渲染(硬件加速)和Software渲染，因为两种绘制方式最后也都走到调用View的draw()方法，所以这里我们来看看software渲染方式的绘制1234567891011121314151617181920212223242526272829303132333435363738private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. Canvas canvas; try &#123; ....... canvas = mSurface.lockCanvas(dirty); ...... &#125; catch (Surface.OutOfResourcesException e) &#123; ..... &#125; catch (IllegalArgumentException e) &#123; ..... &#125; try &#123; ....... try &#123; ...... mView.draw(canvas);//核心方法 drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125; finally &#123; if (!attachInfo.mSetIgnoreDirtyState) &#123; // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; &#125; &#125; &#125; finally &#123; ..... &#125; return true; &#125; 同上，通过分析知，这里mView.draw(canvas)其实是调用View.draw(canvas)方法，让我们来看看此方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // 第一步,如果有背景，绘制背景 int saveCount; if (!dirtyOpaque) &#123; final Drawable background = mBackground; if (background != null) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; if (mBackgroundSizeChanged) &#123; background.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; &#125; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125; &#125; &#125; ........ //第二步,保存画布的层级 int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) &#123; paddingLeft += getLeftPaddingOffset(); &#125; int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) &#123; right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); &#125; final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123; length = (bottom - top) / 2; &#125; // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123; length = (right - left) / 2; &#125; if (verticalEdges) &#123; topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; &#125; if (horizontalEdges) &#123; leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; &#125; saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // 第三步，绘制内容 if (!dirtyOpaque) onDraw(canvas);//核心方法 //第四步，分发绘制子View dispatchDraw(canvas); //第五步，绘制fade效果和restore Layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, right, top + length, p); &#125; if (drawBottom) &#123; matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); canvas.drawRect(left, bottom - length, right, bottom, p); &#125; if (drawLeft) &#123; matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, left + length, bottom, p); &#125; if (drawRight) &#123; matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); canvas.drawRect(right - length, top, right, bottom, p); &#125; canvas.restoreToCount(saveCount); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 从此方法，我们知道View的draw()分五步,分别为： 第一步，如果有背景，绘制背景 第二步，保存画布的层级 第三步，绘制内容 第四步，分发绘制子View 第五步，绘制fade效果和restore Layers 由于我们的DecorView是FrameLayout,是ViewGroup，所以我们来看一下第四步，分发绘制子View，来看ViewGroup中dispatchDraw()方法(此方法主要是ViewGroup中实现)12345678910111213141516171819202122232425262728293031323334353637protected void dispatchDraw(Canvas canvas) &#123; final int count = mChildrenCount; final View[] children = mChildren; ....... if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; // Draw any disappearing views that have animations if (mDisappearingChildren != null) &#123; final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren; final int disappearingCount = disappearingChildren.size() - 1; // Go backwards -- we may delete as animations finish for (int i = disappearingCount; i &gt;= 0; i--) &#123; final View child = disappearingChildren.get(i); more |= drawChild(canvas, child, drawingTime); &#125; &#125; ....... &#125; protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime); &#125; 通过遍历ViewGroup中的子View，然后在调用子View的draw方法，这里draw()方法和我们前面的view的draw()有点不一样，因为是三个参数的，我们再来看此方法1234567891011121314151617181920212223242526272829303132/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * This draw() method is an implementation detail and is not intended to be overridden or * to be called from anywhere else other than ViewGroup.drawChild(). */ boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ...... if (hasNoCache) &#123; ....... if (!layerRendered) &#123; if (!hasDisplayList) &#123; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; SKIP_DRAW) == SKIP_DRAW) &#123; mPrivateFlags &amp;= ~DIRTY_MASK; dispatchDraw(canvas); &#125; else &#123; draw(canvas); &#125; &#125; else &#123; mPrivateFlags &amp;= ~DIRTY_MASK; ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags); &#125; &#125; &#125; else if (cache != null) &#123; ..... &#125; ...... return more; &#125; 可以发现，最后还是调用回了View的draw(canvas)方法。所以对于View的draw(绘制)，其实也和measure(测量)和layout(布局)一样，如果View是ViewGroup，就是在draw的时候会进行分发绘制子View，如果view就是View,那就会调用View(或自定义View)的onDraw()方法，绘制内容。 到这里，我们View的三大绘制原理就分析完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、参考文档Android View 测量流程(Measure)完全解析 View的绘制原理","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"DecorView绘制流程源码分析","date":"2018-01-05T09:24:04.000Z","path":"2018/01/05/tech_android_framework_activity_decorview/","text":"通过Activiyt布局加载流程源码分析(I)和Activiyt布局加载流程源码分析(II)两篇博文，我们知道，首先，Activity的布局内容被加载进入装饰器DecorView中，然后WindowManager将DecorView添加到PhoneWindow中，也即Window中，最后ViewRootImpl对DecorView进行绘制操作，将其内容显示到手机上。但前两篇博文中，对于DecorView的绘制原理，没有作详细说明，所以本篇博文重在梳理这部分逻辑。 在开始分析之前，我们需要了解一些概念，如： DecorView：是PhoneWindow中的一个内部类，也是Window的顶级View，主要负责装载各种View和Activity布局。 ViewRootImpl:是View的绘制的辅助类，所有View的绘制都离不开ViewRootImpl。 Choreographer：是”舞蹈指挥”者，控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。 DisplayEventReceiver：是一个抽象类，主要是接收显示绘制帧的垂直脉冲vsync,从而开始绘制帧。 FrameDisplayEventReceiver： Choreographer的内部类，也是DisplayEventReceiver具体实现类。 在说DecorView的绘制之前，我们先来说说Android的绘制原理，这样方便我们理解后面内容。 一、Android的绘制原理简介Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity)。为什么是16ms, 因为Android设定的刷新率是60FPS(Frame Per Second), 也就是每秒60帧的刷新率, 约合16ms刷新一次。如下图所示： 二、DecorView绘制原理分析在Activity布局加载流程分析中，我们知道DecorView被添加进入了WindowManager,并且最后ViewRootImpl通过setView()方法开始绘制DecorView，所以下面我们就来看看ViewRootImpl的setView()方法123456789101112131415161718192021222324252627282930313233343536373839404142public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view;//1.DecorView赋值为mView mFallbackEventHandler.setView(view); ...... requestLayout();//2.DecorView的绘制 if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //3.Window的权限判断，主要是Window添加的控制，由于本篇博文重在DecorView绘制，所以这里将不会分析 res = sWindowSession.add(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mAttachInfo.mContentInsets, mInputChannel); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; ........ &#125; &#125; &#125; 首先，我们来关注一下注释1，这里主要是对mView进行赋值DecorView，mView是ViewRootImpl的属性变量，这里需要注意一下，因为后面绘制需要用到。我们再来看注释2，ViewRootImpl的requestLayout()方法，我们具体来看看其方法逻辑12345public void requestLayout() &#123; checkThread(); mLayoutRequested = true; scheduleTraversals();//核心方法&#125; 这里我们直接来看核心方法scheduleTraversals()123456789void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); scheduleConsumeBatchedInput(); &#125;&#125; 这里我们需要特别关注mChoreographer，即Choreographer类，从字面意思来说是“舞蹈指挥”者，是Android绘制原理的核心类，控制Android显示帧的绘制。关于Choreographer类，这里不做过多的分析，想了解其原理的同学，可以看看博文Android Choreographer 源码分析。 由Android绘制原理，我们知道每隔16ms,Android系统就会发出垂直信号VSYNC脉冲重绘我们的界面，而Choreographer中postCallback()方法主要功能就是向系统添加回调并加入绘制帧，从而实现View的绘制。这里我们来看看添加的回调mTraversalRunnable1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal();//核心方法 &#125; &#125; final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 我们继续来看doTraversal()方法12345678910111213141516171819202122void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"performTraversals\"); try &#123; performTraversals();//核心方法 &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 我们继续分析方法performTraversals()12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void performTraversals() &#123; .......//1.代码省略。省略主要内容，Surface和SurfaceHolder初始化及条件判断 if (!mStopped) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerImpl.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//2.执行View的宽高测量 ........ layoutRequested = true; &#125; &#125; &#125; final boolean didLayout = layoutRequested &amp;&amp; !mStopped; boolean triggerGlobalLayoutListener = didLayout || attachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout();//3.执行View的布局 ..... &#125; ...... boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) &#123; if (!skipDraw || mReportNextDraw) &#123; ........ performDraw();//执行View绘制 &#125; &#125; else &#123; ........ &#125; &#125; 此方法，可以说是Android系统绘制的核心方法。View绘制原理的三大流程:View的测量onMeasure -&gt; View的布局onLayout -&gt; View的绘制onDraw，都在此方法中提现出来了。下面我们一一来看一下相关方法，首先我们来看一下performMeasure()方法12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);//核心方法 &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 根据上面的分析，我们知道mView就是DecorView,所以这里就是调用DecorView的measure()方法。由Activity布局加载流程源码分析(I)博文，我们知道DecorView是继承至FrameLayout,而FrameLayout又继承至ViewGroup，ViewGroup又继承至View,所以这里的measure()方法就是调用View中的measure()方法，具体怎么调用，这里不细说了，想了解的同学可以看看这篇博文View的绘制原理。下面让我们来看看performLayout()方法1234567891011121314151617private void performLayout() &#123; mLayoutRequested = false; mScrollMayChange = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123; Log.v(TAG, \"Laying out \" + host + \" to (\" + host.getMeasuredWidth() + \", \" + host.getMeasuredHeight() + \")\"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"layout\"); try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 这里逻辑与测量measure类似，也就是调用DecorView的layout方法，具体View的布局控制细节略。我们再来看看performDraw()方法123456789101112131415161718private void performDraw() &#123; if (!mAttachInfo.mScreenOn &amp;&amp; !mReportNextDraw) &#123; return; &#125; final boolean fullRedrawNeeded = mFullRedrawNeeded; mFullRedrawNeeded = false; mIsDrawing = true; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"draw\"); try &#123; draw(fullRedrawNeeded);//核心方法 &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ...... &#125; 我们继续来看看draw()方法123456789101112131415161718192021222324252627282930private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ....... if (!dirty.isEmpty() || mIsAnimating) &#123; if (attachInfo.mHardwareRenderer != null &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123; // Draw with hardware renderer. mIsAnimating = false; mHardwareYOffset = yoff; mResizeAlpha = resizeAlpha; mCurrentDirty.set(dirty); mCurrentDirty.union(mPreviousDirty); mPreviousDirty.set(dirty); dirty.setEmpty(); //1.Hardware渲染(Hardware加速) if (attachInfo.mHardwareRenderer.draw(mView, attachInfo, this,animating ? null :mCurrentDirty)) &#123; mPreviousDirty.set(0, 0, mWidth, mHeight); &#125; &#125; else if (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123;//2.Software渲染 return; &#125; &#125; if (animating) &#123; mFullRedrawNeeded = true; scheduleTraversals(); &#125; &#125; 这里的绘制方法涉及到两种绘制方式，分别为Hardware渲染(硬件加速)和Software渲染，关于选择那种绘制方式，这里还需要回溯到ViewRootImpl的setView()方法,我们再来看看此方法123456789101112131415161718192021222324252627 /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ...... if (view instanceof RootViewSurfaceTaker) &#123;//1.mSurfaceHolder赋值 mSurfaceHolderCallback = ((RootViewSurfaceTaker)view).willYouTakeTheSurface(); if (mSurfaceHolderCallback != null) &#123; mSurfaceHolder = new TakenSurfaceHolder(); mSurfaceHolder.setFormat(PixelFormat.UNKNOWN); &#125; &#125; ........ if (mSurfaceHolder == null) &#123;//2.是否需要硬件加速 enableHardwareAcceleration(mView.getContext(), attrs); &#125; ....... &#125;&#125; 我们知道DecorView是实现了RootViewSurfaceTaker接口的，所以当View为DecorView时，就不会开启硬件加速，不会走Hardware渲染，而其他的View会选择Hardware渲染。因为WindowManager添加的View可能使DecorView，也可能不是DecorView，也可能是一般的View。我们来看看enableHardwareAcceleration()方法123456789101112131415161718192021222324252627282930313233private void enableHardwareAcceleration(Context context, WindowManager.LayoutParams attrs) &#123; mAttachInfo.mHardwareAccelerated = false; mAttachInfo.mHardwareAccelerationRequested = false; if (mTranslator != null) return; final boolean hardwareAccelerated = (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != 0; if (hardwareAccelerated) &#123; if (!HardwareRenderer.isAvailable()) &#123; return; &#125; final boolean fakeHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED) != 0; final boolean forceHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED) != 0; if (!HardwareRenderer.sRendererDisabled || (HardwareRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) &#123; ........ final boolean translucent = attrs.format != PixelFormat.OPAQUE; mAttachInfo.mHardwareRenderer = HardwareRenderer.createGlRenderer(2, translucent);//核心方法 mAttachInfo.mHardwareAccelerated = mAttachInfo.mHardwareAccelerationRequested = mAttachInfo.mHardwareRenderer != null; &#125; else if (fakeHwAccelerated) &#123; mAttachInfo.mHardwareAccelerationRequested = true; &#125; &#125; &#125; 这方法主要是对mAttachInfo.mHardwareRenderer进行赋值，从而在performDraw()方法中可以执行绘制。下面我们来看看上面的绘制方式1，Hardware渲染(硬件加速)，由上知主要是通过attachInfo.mHardwareRenderer.draw()绘制，所以我们来看看HardwareRenderer中的draw()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Override boolean draw(View view, View.AttachInfo attachInfo, HardwareDrawCallbacks callbacks, Rect dirty) &#123; if (canDraw()) &#123; ....... try &#123; ....... DisplayList displayList;//渲染列表 Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"getDisplayList\"); try &#123; displayList = view.getDisplayList(); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ....... if (displayList != null) &#123; ..... try &#123; status |= canvas.drawDisplayList(displayList, mRedrawClip, DisplayList.FLAG_CLIP_CHILDREN); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ..... handleFunctorStatus(attachInfo, status); &#125; else &#123; view.draw(canvas);//核心方法 &#125; &#125; finally &#123; .... &#125; ...... return dirty == null; &#125; &#125; return false; &#125; 当displayList为空的时候，也就会调用 view.draw(canvas)方法，即DeocorView的draw()方法。关于DisplayList这里也不细说，它主要是View中的显示列表记录，具体作用这里不作详述了。我们再来看看第二种绘制方式SoftWare渲染,drawSoftware()方法1234567891011121314151617181920212223242526272829303132333435363738private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. Canvas canvas; try &#123; ....... canvas = mSurface.lockCanvas(dirty); ...... &#125; catch (Surface.OutOfResourcesException e) &#123; ..... &#125; catch (IllegalArgumentException e) &#123; ..... &#125; try &#123; ....... try &#123; ...... mView.draw(canvas);//核心方法 drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125; finally &#123; if (!attachInfo.mSetIgnoreDirtyState) &#123; // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; &#125; &#125; &#125; finally &#123; ..... &#125; return true; &#125; 这里发现，最后也还是调用DecorView的draw方法，具体流程也与measure和layout类似。可以说两种绘制方式最后也还是调用了View的draw方法，可以说是殊途同归。 到这里我们就把添加的回调绘制帧mTraversalRunnable这个说完了。上面说到，Choreographer通过postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)方法向系统添加回调并加入绘制帧，然后Android系统通过16ms间隔脉冲实现帧的绘制，从而才将布局内容显示到手机上。 说到这里，DecorView的绘制流程我们就说完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、参考文档Android Choreographer 源码分析 Android App卡顿分析，以及使用Choreographer进行帧率统计监测 View的绘制原理","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"DecorView绘制流程","slug":"DecorView绘制流程","permalink":"http://awenzeng.me/tags/DecorView绘制流程/"}]},{"title":"Activity布局加载流程源码分析(II)","date":"2018-01-03T10:55:03.000Z","path":"2018/01/03/tech_android_framework_activity_loadLayout_II/","text":"在Activity布局加载流程源码分析(I)文章中，已经详细分析了setContentView()加载流程，但对于装饰器DecorView怎么被加载到Window上的，上篇博文没有说到，所以本篇博文将会接着上篇博文，继续分析Activity布局的加载流程。 在开始分析之前，我们需要了解一些概念，如： Window： 是一个抽象类，表示是一个窗口。Android系统中的界面，也都是以窗口的形式存在的。 PhoneWindow： 是Window类具体实现类，Activity中布局加载逻辑主要就是在此类中完成的。 DecorView：是PhoneWindow中的一个内部类，也是Window的顶级View，主要负责装载各种View。 WindowManager： 是Window的管理类，管理着Window的添加、更新和删除。 WindowManagerService(AMS)：是系统窗口管理服务类，具体管理着系统各种各样的Window。 ViewRootImpl:是View的绘制的辅助类，所有View的绘制都离不开ViewRootImpl。 一、Activity布局及DecorView加载分析这里，我们接着Activity布局加载流程继续分析。在布局加载流程最后，主要是通过WindowManager添加装饰器DecorView到Window中，从而实现Activity布局的加载，这里继续来看那部分代码 1234567891011121314151617181920212223final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; ActivityClientRecord r = performResumeActivity(token, clearHide); ....... if (r != null) &#123; final Activity a = r.activity; ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; ...... &#125; &#125; 这里，简单解释一下参数。其中r.window为PhoneWindow,decor就是装饰器DecorView,wm就是WindowManager。最后通过wm.addView(decor, l)方法，实现Activity布局的加载。这里还注意到WindowManager.LayoutParams的type参数为WindowManager.LayoutParams.TYPE_BASE_APPLICATION，也即是应用窗口类型(所有程序窗口的base窗口，其他应用程序窗口都显示在它上面),具体有关Window的窗口属性，可以参考博文Android悬浮窗原理解析(Window),想了解的同学，可以点击看看，这里有比较全的Window属性解释。 我们再来看一下wm,这里定义的类型是接口ViewManager，其实它就是WindowManager，这里主要是使用设计模式的里氏替换原则(源码中很多地方都用这原则)。wm主要是通过a.getWindowManager()赋值的，所以我们主要来看看Activity中的getWindowManager()方法123public WindowManager getWindowManager() &#123; return mWindowManager;&#125; mWindowMananger是Activity的一个属性变量，通过Activity的启动加载流程,Activity初始化过程中就会对mWindowManager进行赋值，而Activity初始化主要通过attach方法完成，所以我们继续来看Activity的attach方法123456789101112131415161718192021final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; ....... mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ...... mWindow.setWindowManager(null, mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; 这里是通过mWindow.getWindowManager()来赋值mWindowManager，而mWindow即PhoneWindow，这点在Activity布局加载流程中，已分析过。由于PhoneWindow是继承至Window，通过阅读源码分析知道，getWindowManager()方法，主要是window中完成实现的，所以我们具体来看看Window中的getWindowManager()方法1234567891011121314public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; if (wm == null) &#123; wm = WindowManagerImpl.getDefault();//1.核心代码 &#125; mWindowManager = new LocalWindowManager(wm, hardwareAccelerated);//2.核心代码&#125;public WindowManager getWindowManager() &#123; return mWindowManager;&#125; 这里，我们先来看一下注释1，WindowManagerImpl.getDefault()，这很明显是单例模式。我们继续来看看源码123456private final static WindowManagerImpl sWindowManager = new WindowManagerImpl();public static WindowManagerImpl getDefault() &#123; return sWindowManager;&#125; 这里wm就是WindowManagerImpl。我们来看看WindowManagerImpl类123public class WindowManagerImpl implements WindowManager &#123; ......省略细节&#125; 我们再来看看注释2,也即LocalWindowManager类123456789101112131415161718192021private class LocalWindowManager extends WindowManagerImpl.CompatModeWrapper &#123; private static final String PROPERTY_HARDWARE_UI = \"persist.sys.ui.hw\"; private final boolean mHardwareAccelerated; LocalWindowManager(WindowManager wm, boolean hardwareAccelerated) &#123; super(wm, getCompatInfo(mContext)); mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); &#125; public boolean isHardwareAccelerated() &#123; return mHardwareAccelerated; &#125; public final void addView(View view, ViewGroup.LayoutParams params) &#123; ........ super.addView(view, params); &#125; &#125; 我们继续来看看LocalWindowManager类继承的WindowManagerImpl的内部类CompatModeWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static class CompatModeWrapper implements WindowManager &#123; private final WindowManagerImpl mWindowManager; private final Display mDefaultDisplay; private final CompatibilityInfoHolder mCompatibilityInfo; CompatModeWrapper(WindowManager wm, CompatibilityInfoHolder ci) &#123; mWindowManager = wm instanceof CompatModeWrapper ? ((CompatModeWrapper)wm).mWindowManager : (WindowManagerImpl)wm; if (ci == null) &#123; mDefaultDisplay = mWindowManager.getDefaultDisplay(); &#125; else &#123; mDefaultDisplay = Display.createCompatibleDisplay( mWindowManager.getDefaultDisplay().getDisplayId(), ci); &#125; mCompatibilityInfo = ci; &#125; @Override public void addView(View view, android.view.ViewGroup.LayoutParams params) &#123; mWindowManager.addView(view, params, mCompatibilityInfo); &#125; @Override public void updateViewLayout(View view, android.view.ViewGroup.LayoutParams params) &#123; mWindowManager.updateViewLayout(view, params); &#125; @Override public void removeView(View view) &#123; mWindowManager.removeView(view); &#125; @Override public Display getDefaultDisplay() &#123; return mDefaultDisplay; &#125; @Override public void removeViewImmediate(View view) &#123; mWindowManager.removeViewImmediate(view); &#125; @Override public boolean isHardwareAccelerated() &#123; return mWindowManager.isHardwareAccelerated(); &#125; &#125; WindowManagerImpl的内部类CompatModeWrapper实现了WindowManager接口，而WindowManager又实现了ViewManager接口123public interface WindowManager extends ViewManager &#123; ......&#125; 我们来看看ViewManager接口123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 这里实现ViewManager接口的有WindowManager,而WindowManagerImpl和CompatModeWrapper也都实现WindowManager接口，从而间接实现了ViewManager接口，也都实现的添加，更新和删除View的方法。 所以，在最开始处，以ViewManager定义的wm其实也就是LocalWindowManager,通过相互继承调用，其实最后调用的是WindowManagerImpl中的addView()方法，我们继续来看看此方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void addView(View view) &#123; addView(view, new WindowManager.LayoutParams( WindowManager.LayoutParams.TYPE_APPLICATION, 0, PixelFormat.OPAQUE)); &#125; public void addView(View view, ViewGroup.LayoutParams params) &#123; addView(view, params, null, false); &#125; public void addView(View view, ViewGroup.LayoutParams params, CompatibilityInfoHolder cih) &#123; addView(view, params, cih, false); &#125; private void addView(View view, ViewGroup.LayoutParams params, CompatibilityInfoHolder cih, boolean nest) &#123; if (false) Log.v(\"WindowManager\", \"addView view=\" + view); if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException( \"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; ViewRootImpl root; View panelParentView = null; ....... root = new ViewRootImpl(view.getContext()); root.mAddNesting = 1; if (cih == null) &#123; root.mCompatibilityInfo = new CompatibilityInfoHolder(); &#125; else &#123; root.mCompatibilityInfo = cih; &#125; view.setLayoutParams(wparams); if (mViews == null) &#123; index = 1; mViews = new View[1]; mRoots = new ViewRootImpl[1]; mParams = new WindowManager.LayoutParams[1]; &#125; else &#123; index = mViews.length + 1; Object[] old = mViews; mViews = new View[index]; System.arraycopy(old, 0, mViews, 0, index-1); old = mRoots; mRoots = new ViewRootImpl[index]; System.arraycopy(old, 0, mRoots, 0, index-1); old = mParams; mParams = new WindowManager.LayoutParams[index]; System.arraycopy(old, 0, mParams, 0, index-1); &#125; index--; mViews[index] = view; mRoots[index] = root; mParams[index] = wparams; &#125; // do this last because it fires off messages to start doing things root.setView(view, wparams, panelParentView); &#125; 这里有三个数组mViews，mRoots，mParams变量，mViews主要保存向Window中添加的View,mRoots主要保存实现绘制View的ViewRootImpl,mParams主要保存添加的Window参数，最后每一个添加的View都会调用root.setView(view, wparams, panelParentView)方法，实现View的绘制。关于这三个参数的作用，是因为WindowManager中可能添加多个Window，多个View，所以需要保存起来，方便删除和更新。 关于WindowManagerImpl的源码，这里需要注意一下，由于我用的版本是Andorid4.1.1_r1，源码如上，而在大于Andorid4.1.1_r11的版本，如Android5.1.1中的WindowManagerImpl源码的addView方法，主要是通过WindowManagerGlobal来实现的,逻辑也都和Andorid4.1.1_r1一样，只是把部分逻辑封装成WindowManagerGlobal，这里我就不多说，想了解的同学，可以自行查看。 到这里，DecorView添加入Window的流程就分析完了。接下来主要就是DecorView的绘制流程，也即View的绘制流程。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 二、参考文档Activity布局加载流程源码分析 Activity启动流程源码分析(应用中) Android悬浮窗原理解析(Window)","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"Activity布局加载流程源码分析(I)","date":"2017-12-29T11:20:32.000Z","path":"2017/12/29/tech_android_framework_activity_loadLayout_I/","text":"最近阅读Android源码，似乎有点发现新大陆的感觉。以前经常接触Android知识，在阅读源码中，开始变得豁然开朗。前两天才写完两篇博文Activity启动流程源码分析(应用中)和Activity启动流程源码分析(Launcher中)，今天，就急不可耐的想写写Activity布局加载流程，其实，也就是想趁热打铁，好好梳理梳理这部分知识。 在开始梳理之前，我们需要了解一些概念，如： Window： 是一个抽象类，表示是一个窗口。Android系统中的界面，也都是以窗口的形式存在的。 PhoneWindow： 是Window类具体实现类，Activity中布局加载逻辑主要就是在此类中完成的。 WindowManager： 是Window的管理类，管理着Window的添加、更新和删除。 WindowManagerService(AMS)：是系统窗口管理服务类，具体管理着系统各种各样的Window. DecorView：是Window的顶级View，主要负责装载各种View。 一、Activity布局加载分析我们知道，设置Activity布局内容，主要是在Activity的onCreate()中调用setContentView()方法，下面让我们来看看此方法12345 public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID);//核心代码 initActionBar();&#125; 这里主要调用了getWindow().setContentView()方法，我们来看看Activity中getWindow()123public Window getWindow() &#123; return mWindow;&#125; 由此知mWindow是Activity一个属性变量，在前面Activity启动流程介绍中，我们知道在Activity启动前都会先调用attach()，而这mWindow就是在attach初始化的时候赋值的，我们来看看Activity的attach源码123456789101112131415161718192021222324252627282930313233343536final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; attachBaseContext(context); mFragments.attachActivity(this); mWindow = PolicyManager.makeNewWindow(this);//核心代码 ...... mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; mWindow.setWindowManager(null, mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; &#125; 这里我们来关注一下PolicyManager.makeNewWindow(this)方法，创建Window，我们来看看PolicyManager类1234567891011121314151617181920212223242526272829public final class PolicyManager &#123; private static final String POLICY_IMPL_CLASS_NAME = \"com.android.internal.policy.impl.Policy\"; private static final IPolicy sPolicy; static &#123; try &#123; Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME); sPolicy = (IPolicy)policyClass.newInstance();//反射初始化Policy &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be loaded\", ex); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; &#125; public static Window makeNewWindow(Context context) &#123; return sPolicy.makeNewWindow(context); //核心方法 &#125; .......&#125; 由上易知，这里主要是通过反射初始化Policy，然后利用设计模式里氏替换原则调用Policy的makeNewWindow()方法，我们继续来看Policy中的方法123456789public class Policy implements IPolicy &#123; ........ public PhoneWindow makeNewWindow(Context context) &#123; return new PhoneWindow(context);//核心代码 &#125; ......&#125; 我们可以发现mWindow其实就是PhoneWindow,在Activity中getWindow().setContentView()方法，就是调用PhoneWindow中的setContentView方法，所以我们这里来看看PhoneWindow中的setContentView()方法12345678910111213@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null)&#123; installDecor();//1.安装装饰器 &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent);//2.填充我们的布局文件 final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 从注释2,我们知道布局填充器mLayoutInflater向mContentParent填充我们的布局内容，而mContentParent是一个ViewGroup,它是怎么赋值的呢？这里我们要来看注释1，当mContentParent为空时，会安装装饰器，我们继续来看phoneWindow中installDecor()方法1234567891011121314151617181920212223242526private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor();//1.生成装饰器 mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor);//2.对填充我们布局的ViewGroup赋值 mDecor.makeOptionalFitsSystemWindows(); mTitleView = (TextView)findViewById(com.android.internal.R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; ....... &#125; else &#123; mTitleView.setText(mTitle);//设置Activity的title &#125; &#125; else &#123; mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar); if (mActionBar != null) &#123; .......mActionBar的处理 &#125; &#125; &#125; &#125; 首先，我们先来看看注释1装饰器的生成方法generateDecor()123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 这里主要就是装饰器DecorView的初始化，我们再来看一下DecorView的源码12345678private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ...... public DecorView(Context context, int featureId) &#123; super(context); mFeatureId = featureId; &#125; ....... DecorView类包括内容还有许多，这里就不介绍了，我们只需知道DecorView是PhoneWindow的内部类，DecorView继承于FrameLayout，实现RootViewSurfaceTaker接口。下面我们来看一下mContentParent的生成，即generateLayout(mDecor)方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576protected ViewGroup generateLayout(DecorView decor) &#123; .......//初始化一些window属性 // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); //通过判断Activity的不同feature加载不同的系统默认布局 if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( com.android.internal.R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; //带进度系统布局 layoutResource = com.android.internal.R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( com.android.internal.R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; //无Titile系统布局 if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( com.android.internal.R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR_OVERLAY)) != 0) &#123; layoutResource = com.android.internal.R.layout.screen_action_bar_overlay; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_action_bar; &#125; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = com.android.internal.R.layout.screen_simple_overlay_action_mode; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_simple;//1.一般系统布局 &#125; mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));//2.向装饰View加入系统布局View ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//3.获取我们Activity能填充的内容ViewGroup ...... &#125; mDecor.finishChanging(); return contentParent; &#125; 这里我们来看一下，系统默认的几种Activity的头部布局xml文件，布局文件的源码位置为：android4.1.1_r1\\frameworks\\base\\core\\res\\res\\layout,我们挑两个文件来看一下： 第一个screen_title.xml12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- Popout bar for action modes --&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"?android:attr/windowTitleSize\" style=\"?android:attr/windowTitleBackgroundStyle\"&gt; &lt;TextView android:id=\"@android:id/title\" style=\"?android:attr/windowTitleStyle\" android:background=\"@null\" android:fadingEdge=\"horizontal\" android:gravity=\"center_vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"0dip\" android:layout_weight=\"1\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; 第二个，screen_simple.xml123456789101112131415161718&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:foregroundInsidePadding=\"false\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; 通过对比，我们发现这两个布局文件都有一个共同id为@android:id/content的FrameLayout,其实这也就是我们Activity布局填充容器。我们还发现，这两个布局父布局都是一个线性布局LinearLayout，并且方向都是垂直的，这也验证了我们Activity内容布局一般都是状态栏的下边的模式。我们再来看后面的代码1234View in = mLayoutInflater.inflate(layoutResource, null);decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));//2.向装饰View加入系统布局ViewViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//3.获取我们Activity能填充的内容ViewGroup 这里向装饰器添加了系统布局View，并从系统布局View中获取了Activity填充内容的容器ViewGroup。其中ID_ANDROID_CONTENT就是com.android.internal.R.id.content，通过(ViewGroup)findViewById(ID_ANDROID_CONTENT)就获取了布局文件中的FrameLayout，即Activity内容填充布局的ViewGroup。这样我们再回到PhoneWindow的setContentView方法12345678910111213@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent);//核心代码 final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 现在mContentParent已经赋完值了，再通过布局填充器mLayoutInflater的inflate()方法，这样我们就把Activity的布局文件添加到装饰器上了。然而，现在虽然装饰器DecorView上已经有了Activity布局内容，但是是什么时候添加到Window上的呢？这里就需要了解Activity的启动流程，在Activity的启动流程最后几步会执行ActivityThread中handleLaunchActivity()方法，我们接着此方法继续分析1234567891011121314151617private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ....... Activity a = performLaunchActivity(r, customIntent);//1.创建Activity实例 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward);//2.调用Activity onResume方法 ....... &#125; else &#123; ....... &#125; &#125; 在注释1处，已经建立Activity的实例，并且执行Activity生命周期的attach()和onCreate()方法。我们知道setContentView()也就在onCreate()方法中调用的,所以这个时候，我们Activity布局文件内容已经装入了装饰器DecorView中，接下来就是把DecorView和Window关联起来，所以下面我们继续来看handleResumeActivity()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); ActivityClientRecord r = performResumeActivity(token, clearHide);//1.执行Activity的onResume方法 if (r != null) &#123; final Activity a = r.activity; ........ boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());//2.Activity显示可见 &#125; catch (RemoteException e) &#123; &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l);//3.通过WindowManager将DecorView加入Window,从而显示Window，Activity变为可见。 &#125; &#125; else if (!willBeVisible) &#123; r.hideForNow = true; &#125; cleanUpPendingRemoveWindows(r); if (!r.activity.mFinished &amp;&amp; willBeVisible&amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l);//4.更新DecorView,更新Activity界面 &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ....... &#125; else &#123; ....... &#125; &#125; 在注释1处，调用performResumeActivity(token, clearHide)方法，实际上就是调用activity生命周期的onResume()方法。注释2处，通过Binder跨进程通信，调用ActivityManagerService中willActivityBeVisible()获取显示Activity的控制开关，从而在注释3处，通过WindowManager添加装饰器DecorView到Window,然后，再调用相关View的绘制流程，这样一个有布局的Activity就被加载出来了。 到这里，Activity布局加载流程就是梳理完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 二、参考文档 Binder通信机制原理解析 Activity启动流程源码分析(应用中) Activity启动流程源码分析(Launcher中)","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"Activity启动流程源码分析(Launcher中)","date":"2017-12-27T10:47:13.000Z","path":"2017/12/27/tech_android_framework_startactivity_launcher/","text":"Activity的启动方式，严格来说有两种形式。第一种是在Android应用中启动,第二种是从Launcher中点击应用快捷图标启动。Android应用中Activity启动流程，在上篇博文Activity启动流程源码分析(应用中)已介绍过了，想了解的同学，可以看看一下。本篇博文将会介绍从Launcher中启动Activity具体流程。 在开始介绍之前，我们需要了解一些概念，如： ActivityThread： 应用的启动入口类，当应用启动，会首先执行其main方法，开启主线程消息循环机制。 ApplicationThread： ActivityThread的内部类，主要与系统进程AMS通信，从而对应用进程的具体Activity操作进行管理。 Instrumentation： ActivityThread的属性变量，主要辅助ActivityThread类调用Activity的生命周期相关方法。 ActivityManagerService(AMS)： Activity管理系统服务类，主要是对所有的Activity进行管理。 ActivityStack： Activity任务栈，AMS的属性变量，AMS中Activtiy的实际管理者。 一、什么是Launcher?通俗的来说，就是我们正常解锁后，进入的第一个界面，即桌面(HomeScreen)。Launcher本身就是一个app，它主要作用是用来显示widget和管理手机上其他应用软件app。通过查看源码，我们知道Android系统会内置一些系统应用，如Launcher，联系人、照相机等，并且在Android系统启动后，会自动启动Launcher，让用户可以通过Launcher启动其他应用。 二、Launcher中启动应用源码分析Launcher中启动应用，也即是Launcher中启动Activity,因为每个应用都是由多个Activities组成的。下面我们就从Launcher源码开始分析：1234567891011View createShortcut(ShortcutInfo info) &#123; return createShortcut(R.layout.application, (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);&#125;View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) &#123; BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false); favorite.applyFromShortcutInfo(info, mIconCache); favorite.setOnClickListener(this);//核心代码 return favorite;&#125; 在创建应用快捷图标的时候，都会给应用快捷图标View设置监听事件setOnClickListener(this),从这监听事件的设定，我们也就知道Launcher类实现了View.OnTouchListener接口，所以我们来看看Onclick()方法123456789101112131415161718192021222324252627282930public void onClick(View v) &#123; ....... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // Open shortcut final Intent intent = ((ShortcutInfo) tag).intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); boolean success = startActivitySafely(v, intent, tag);//核心代码 if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125; &#125; else if (tag instanceof FolderInfo) &#123; if (v instanceof FolderIcon) &#123; FolderIcon fi = (FolderIcon) v; handleFolderClick(fi); &#125; &#125; else if (v == mAllAppsButton) &#123; if (mState == State.APPS_CUSTOMIZE) &#123; showWorkspace(true); &#125; else &#123; onClickAllAppsButton(v); &#125; &#125; &#125; 点击应用快捷图标，就会执行onClick(),然后就会调用startActivitySafely方法，我们继续来看此方法12345678910boolean startActivitySafely(View v, Intent intent, Object tag) &#123; boolean success = false; try &#123; success = startActivity(v, intent, tag);//核心代码 &#125; catch (ActivityNotFoundException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e); &#125; return success;&#125; 这里就开始startActivity了，我们继续看这方法1234567891011121314151617181920212223242526boolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); if (useLaunchAnimation) &#123; ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); startActivity(intent, opts.toBundle()); &#125; else &#123; startActivity(intent); &#125; return true; &#125; catch (SecurityException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Launcher does not have the permission to launch \" + intent + \". Make sure to create a MAIN intent-filter for the corresponding activity \" + \"or use the exported attribute for this activity. \" + \"tag=\"+ tag + \" intent=\" + intent, e); &#125; return false;&#125; 前面说了，Launcher本身就是一个应用，通过阅读源码知道，Launcher类也是继承于Activity，到这里，startActivity()也就是和我们上篇博文Activity启动流程源码分析(应用中)中startActivity是一样的，具体流程也是相同的，唯一不同的是在startSpecificActivityLocked()时，Launcher启动的Activity没有进程，需要新建应用进程。让我们来看看startSpecificActivityLocked()源码12345678910111213141516171819202122232425262728293031323334private final void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid); if (r.launchTime == 0) &#123; r.launchTime = SystemClock.uptimeMillis(); if (mInitialStartTime == 0) &#123; mInitialStartTime = r.launchTime; &#125; &#125; else if (mInitialStartTime == 0) &#123; mInitialStartTime = SystemClock.uptimeMillis(); &#125; if (app != null &amp;&amp; app.thread != null) &#123;//Activity所在进程判断，进程存在时，直接启动Activity try &#123; app.addPackage(r.info.packageName); realStartActivityLocked(r, app, andResume, checkConfig);//核心代码 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false); &#125; 因为从Launcher启动的Activity进程不存在，所以就会执行mService.startProcessLocked()来新建进程，其中mService为ActivityManagerService，我们来看看具体代码：1234567891011121314151617181920212223242526final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated) &#123; ProcessRecord app; ....... if (app == null) &#123; app = newProcessRecordLocked(null, info, processName, isolated); if (app == null) &#123; Slog.w(TAG, \"Failed making new process record for \" + processName + \"/\" + info.uid + \" isolated=\" + isolated); return null; &#125; mProcessNames.put(processName, app.uid, app); if (isolated) &#123; mIsolatedProcesses.put(app.uid, app); &#125; &#125; else &#123; // If this is a new package in the process, add the package to the list app.addPackage(info.packageName); &#125; ....... startProcessLocked(app, hostingType, hostingNameStr);//核心代码 return (app.pid != 0) ? app : null;&#125; 在创建进程记录后，就会执行startProcessLocked(app, hostingType, hostingNameStr)来创建进程，我们继续12345678910111213141516171819private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; ...... try &#123; ....... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. //核心代码，开始创建进程 Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\", app.processName, uid, uid, gids, debugFlags, app.info.targetSdkVersion, null); ...... &#125; catch (RuntimeException e) &#123; ....... &#125; &#125; 这里Process.start()进程启动传入了ActivityThread类，我们知道ActivityThread类是应用的入口类，所以这里开始正式启动快捷图标的应用。关于Android应用程序的入口，我已写过一篇博文Android应用程序入口源码解析,想了解的同学可以看看。让我们继续来看看Process中的start方法123456789101112131415public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int targetSdkVersion, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, targetSdkVersion, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; startViaZygote()从方法名中，我们知开始通过Zygote启动进程，我们继续看123456789101112131415private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int targetSdkVersion, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); ...... return zygoteSendArgsAndGetResult(argsForZygote); &#125; &#125; 我们继续看zygoteSendArgsAndGetResult()方法1234567891011121314151617181920212223242526272829303132333435363738394041private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; openZygoteSocketIfNeeded(); try &#123; sZygoteWriter.write(Integer.toString(args.size())); sZygoteWriter.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx( \"embedded newlines not allowed\"); &#125; sZygoteWriter.write(arg); sZygoteWriter.newLine(); &#125; sZygoteWriter.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = sZygoteInputStream.readInt(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; result.usingWrapper = sZygoteInputStream.readBoolean(); return result; &#125; catch (IOException ex) &#123; try &#123; if (sZygoteSocket != null) &#123; sZygoteSocket.close(); &#125; &#125; catch (IOException ex2) &#123; // we're going to fail anyway Log.e(LOG_TAG,\"I/O exception on routine close\", ex2); &#125; sZygoteSocket = null; throw new ZygoteStartFailedEx(ex); &#125; &#125; 到这里就会执行Zygote的一些原生方法，通过对Zygote的机制的了解，我们知道Zygote会fork自身进程来创建应用进程，进而执行ActivityThread的main方法，初始化相关应用参数，我们来看看ActivityThread的main方法1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false);//核心方法 AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 通过博文Android消息机制源码解析(Handler)知，Android的消息循环机制就是这个时候创建的，这里我们着重需要来看看ActivityThead的attach方法12345678910111213141516171819202122232425private void attach(boolean system) &#123; sThreadLocal.set(this); mSystemThread = system; if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\"); RuntimeInit.setApplicationObject(mAppThread.asBinder()); //Binder通信机制 IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; else &#123; ....... &#125; ....... &#125;); &#125; 这里通过Binder跨进程通信机制调用了ActivityManagerService中的attachApplication()方法，我们继续12345678910public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//核心方法 Binder.restoreCallingIdentity(origId); &#125;&#125; 我们继续看attachApplicationLocked()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; ...... try &#123; ...... //1.建立应用Application thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, true); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; ..... &#125; ..... // See if the top visible activity is waiting to run in this process... ActivityRecord hr = mMainStack.topRunningActivityLocked(null); if (hr != null &amp;&amp; normalMode) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (mHeadless) &#123; Slog.e(TAG, \"Starting activities not supported on headless device: \" + hr); &#125; else if (mMainStack.realStartActivityLocked(hr, app, true, true)) &#123;//2.启动应用Activity didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception in new application when starting activity \" + hr.intent.getComponent().flattenToShortString(), e); badApp = true; &#125; &#125; else &#123; mMainStack.ensureActivitiesVisibleLocked(hr, null, processName, 0); &#125; &#125; ...... return true; &#125; 注释1处，在Android应用程序入口源码解析中，已经分析过，这里主要就是通过Binder跨进程通信，创建应用Application,执行Application的attachBaseContext和onCreate方法，两方法也为应用程序的开发入口。注释2处，调用了ActivitStack中realStartActivityLocked()方法，主要就是启动Activity，也即我们从Launcher点击应用快捷图标应用的入口Activity，在博文Activity启动流程源码分析(应用中)中，已经介绍过剩余的Activity的启动流程，这里就不再介绍了。想了解的同学，可以看一下上篇博文。 到这里，从Launcher中启动Activity的流程就讲解完了。最后再附上Activity启动流程图： 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、参考文档Launcher开发——入门篇 Android Activity启动流程源码全解析（2）","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"Activity启动流程","slug":"Activity启动流程","permalink":"http://awenzeng.me/tags/Activity启动流程/"}]},{"title":"Activity启动流程源码分析(应用中)","date":"2017-12-26T12:25:27.000Z","path":"2017/12/26/tech_android_framework_startactivity/","text":"在移动应用开发中，Android四大组件之一Activity是最常用的。很多界面，如：闪屏、主界面、次功能界面等都需要Activity来作为主要的载体；界面与界面之间，即不同的Activity之间也都存在跳转切换，弄懂这其中跳转切换原理，将有助于我们更好的理解Android中Activity之间的交互逻辑，从而更好的开发Android应用。本篇博文将会重点介绍Android应用中的Activity的启动流程。 在开始介绍之前，我们需要了解一些概念，如： ActivityThread： 应用的启动入口类，当应用启动，会首先执行其main方法，开启主线程消息循环机制。 ApplicationThread： ActivityThread的内部类，主要与系统进程AMS通信，从而对应用进程的具体Activity操作进行管理。 Instrumentation： ActivityThread的属性变量，主要辅助ActivityThread类调用Activity的生命周期相关方法。 ActivityManagerService(AMS)： Activity管理系统服务类，主要是对所有的Activity进行管理。 ActivityStack： Activity任务栈，AMS的属性变量，AMS中Activtiy的实际管理者。 一、Activity启动流程Activity启动流程图： 此流程图，主要是根据Android源码中代码执行顺序来梳理的。浅绿色部分为应用进程，浅蓝色部分为系统服务进程，两个进程间通过Binder驱动来进行通信，第一次Binder通信主要的类有：ActivityManagerService(AMS),ActivityManagerNative(AMN),ActivityManagerProxy(AMP)；第二次Binder通信主要的类有:ApplicationThread(AT),ApplicationThreadNative(ATN)，ApplicationThreadProxy(ATP)。 二、Activity启动流程源码分析根据上面流程图，下面让我们一起来看看源码，首先从Activity的startActivity开始：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic void startActivity(Intent intent) &#123; startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123; if (mParent == null) &#123;//1.核心代码 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; &#125; else &#123;//2.核心代码 if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; 在Activity源码中，startActivity之后都会调用startActivityForResult；在注释1处，当mParent为空时，会直接调用Instrumentation中的execStartActivity方法，当mParent不为空时，调用mParent.startActivityFromChild方法。通过跟踪查找发现，mParent也是Activity，在Activity attach的时候会初始化，从ActivityRecord中获得值。我们继续来看看startActivityFromChild方法1234567891011121314151617public void startActivityFromChild(Activity child, Intent intent, int requestCode) &#123; startActivityFromChild(child, intent, requestCode, null);&#125;public void startActivityFromChild(Activity child, Intent intent, int requestCode, Bundle options) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, child, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, child.mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125;&#125; 由此发现，startActivityForResult之后都调用了Instrumentation中的execStartActivity方法。我们继续来看看execStartActivity方法：12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...... try &#123; intent.setAllowFds(false); intent.migrateExtraStreamToClipData(); //核心代码 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; 这里主要是调用了ActivityManagerNative.getDefault()中的startActivity(…)方法，这里就涉及到Binder的一次跨进程通信，通过跨进程通信调用了ActivityManagerService中的startActivity方法。具体Binder怎么跨进程通信的，我已写过文章 Android跨进程通信方式(IPC)解析，想了解的同学，可以点击看看。下面我们继续来看看AMS中的startActivity方法：12345678910public final int startActivity(IApplicationThread caller, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123; enforceNotIsolatedCaller(\"startActivity\"); ...... return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, null, null, options, userId);&#125; 在AMS的startActivity方法中，又调用ActivityStack中的startActivityMayWait()方法,我们再来看看ActivityStack的源码：123456789101112131415161718final int startActivityMayWait(IApplicationThread caller, int callingUid, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config, Bundle options, int userId) &#123; ...... //核心代码 int res = startActivityLocked(caller, intent, resolvedType, aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, startFlags, options, componentSpecified, null); ...... return res; &#125; &#125; 我们这里主要分析启动流程，所以省略掉部分细节。让我们继续看ActivityStack中的startActivityLocked()方法12345678910111213141516171819final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, int startFlags, Bundle options, boolean componentSpecified, ActivityRecord[] outActivity) &#123; ...... //创建一个新的ActivityRecord ActivityRecord r = new ActivityRecord(mService, this, callerApp, callingUid, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified); ...... err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options); ...... return err; &#125; 同上，也省略的部分细节。我们继续1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; ...... if (sourceRecord == null) &#123; if ((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; ......//省略代码：Activity四种启动模式standard,singleTop,singleTask,singleInstance的判断 if (sourceRecord != null) &#123; ....... if (!addingToTask &amp;&amp;(launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; // In this case, we are launching an activity in our own task // that may already be running somewhere in the history, and // we want to shuffle it to the front of the stack if so. int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId); if (where &gt;= 0) &#123; ActivityRecord top = moveActivityToFrontLocked(where); logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task); top.updateOptionsLocked(options); top.deliverNewIntentLocked(callingUid, r.intent); if (doResume) &#123; resumeTopActivityLocked(null);//核心代码 &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; // An existing activity is starting this new activity, so we want // to keep the new one in the same task as the one that is starting // it. r.setTask(sourceRecord.task, sourceRecord.thumbHolder, false); if (DEBUG_TASKS) Slog.v(TAG, \"Starting new activity \" + r + \" in existing task \" + r.task); &#125; else &#123; ...... &#125; ...... return ActivityManager.START_SUCCESS;&#125; 在startActivityUncheckedLocked()方法中，主要针对Activity的启动模式进行了检测判断，从而启动Activity。我们知道，Activity有四种启动模式，分别为standard,singleTop,singleTask和singleInstance,但这里我们主要是分析Activity的启动流程，所以具体启动模式的判断逻辑细节，这里就不展开分析了。我们主要来看一下，把Activity启动放到栈顶的方法resumeTopActivityLocked()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110final boolean resumeTopActivityLocked(ActivityRecord prev) &#123; return resumeTopActivityLocked(prev, null); &#125; final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; //找到一个栈顶的未finish的Activity的ActivityRecord ActivityRecord next = topRunningActivityLocked(null); ...... if (next == null) &#123;//栈顶无Activity，直接启动Launcher if (mMainStack) &#123; ActivityOptions.abort(options); return mService.startHomeActivityLocked(0); &#125; &#125; ...... //如果Activity所在的进程已经存在 if (next.app != null &amp;&amp; next.app.thread != null) &#123; ...... try &#123; ....... //重新显示Activity if (next.newIntents != null) &#123; next.app.thread.scheduleNewIntent(next.newIntents, next.appToken); &#125; EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, System.identityHashCode(next), next.task.taskId, next.shortComponentName); next.sleeping = false; showAskCompatModeDialogLocked(next); next.app.pendingUiClean = true; //执行Activity onResume方法 next.app.thread.scheduleResumeActivity(next.appToken, mService.isNextTransitionForward()); checkReadyForSleepLocked(); &#125; catch (Exception e) &#123; //如果启动异常，就重启Activity if (DEBUG_STATES) Slog.v(TAG, \"Resume failed; resetting state to \" + lastState + \": \" + next); next.state = lastState; mResumedActivity = lastResumedActivity; Slog.i(TAG, \"Restarting because process died: \" + next); if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW &amp;&amp; mMainStack) &#123; mService.mWindowManager.setAppStartingWindow( next.appToken, next.packageName, next.theme, mService.compatibilityInfoForPackageLocked( next.info.applicationInfo), next.nonLocalizedLabel, next.labelRes, next.icon, next.windowFlags, null, true); &#125; &#125; startSpecificActivityLocked(next, true, false);//核心代码，重启Activity return true; &#125; // From this point on, if something goes wrong there is no way // to recover the activity. try &#123; next.visible = true; completeResumeLocked(next); &#125; catch (Exception e) &#123; // If any exception gets thrown, toss away this // activity and try the next one. Slog.w(TAG, \"Exception thrown during resume of \" + next, e); requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null, \"resume-exception\"); return true; &#125; // Didn't need to use the icicle, and it is now out of date. if (DEBUG_SAVED_STATE) Slog.i(TAG, \"Resumed activity; didn't need icicle of: \" + next); next.icicle = null; next.haveState = false; next.stopped = false; &#125; else &#123; //Activity所在的进程不存在，启动Activity if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; mService.mWindowManager.setAppStartingWindow( next.appToken, next.packageName, next.theme, mService.compatibilityInfoForPackageLocked( next.info.applicationInfo), next.nonLocalizedLabel, next.labelRes, next.icon, next.windowFlags, null, true); &#125; if (DEBUG_SWITCH) Slog.v(TAG, \"Restarting: \" + next); &#125; startSpecificActivityLocked(next, true, true);//启动Activity &#125; return true; &#125; 通过上面注释中的分析，在判断Activity进程之后，就会通过startSpecificActivityLocked()方法来启动Activity,我们继续看12345678910111213141516171819202122232425262728293031323334private final void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid); if (r.launchTime == 0) &#123; r.launchTime = SystemClock.uptimeMillis(); if (mInitialStartTime == 0) &#123; mInitialStartTime = r.launchTime; &#125; &#125; else if (mInitialStartTime == 0) &#123; mInitialStartTime = SystemClock.uptimeMillis(); &#125; if (app != null &amp;&amp; app.thread != null) &#123;//Activity所在进程判断，进程存在时，直接启动Activity try &#123; app.addPackage(r.info.packageName); realStartActivityLocked(r, app, andResume, checkConfig);//核心代码 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false); &#125; 在startSpecificActivityLocked()方法中也对Activity的进程是否存在做了判断，当进程存在时直接调用realStartActivityLocked()方法启动Activity；当Activity的进程不存在时，就会调用AMS的startProcessLocked()方法创建进程，这里其实是Activity的另一种启动流程，从Laucher启动，只有从Launcher启动才会没有进程，这里先不做深度分析，后续我们针对Activity的Launcher启动再写一篇博文。已补博文Activity启动流程源码分析(Launcher中)。下面让我们继续看realStartActivityLocked()方法：1234567891011121314151617final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ....... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.icicle, results, newIntents, !andResume, mService.isNextTransitionForward(), profileFile, profileFd, profileAutoStop); ...... return true; &#125; 这里主要通过调用app.thread.scheduleLaunchActivity(…)方法实现了跨进程通信，这里主要实现了流程图中的第二次Binder跨进程通信。通过Binder跨进程通信调用了ApplicationThread中的scheduleLaunchActivity(…)方法，具体Binder怎么跨进程通信的，我已写过文章 Android跨进程通信方式(IPC)解析，想了解的同学，可以点击看看。下面我们继续来看看ApplicationThread中的scheduleLaunchActivity方法：1234567891011121314151617181920212223242526 public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward, String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; ActivityClientRecord r = new ActivityClientRecord(); ...... queueOrSendMessage(H.LAUNCH_ACTIVITY, r); &#125; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null);//核心代码 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ....... &#125;&#125; 由上易知，通过Handler消息循环机制，从而执行handleLaunchActivity()方法，我们继续来看此方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ....... Activity a = performLaunchActivity(r, customIntent); ...... &#125; private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(\"##### [\" + System.currentTimeMillis() + \"] ActivityThread.performLaunchActivity(\" + r + \")\"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; //1.核心代码 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) &#123; ContextImpl appContext = new ContextImpl(); appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); //2.核心代码 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //3.核心代码 mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; mInstrumentation.callActivityOnPostCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); &#125; &#125; return activity; &#125; 注释1处，通过mInstrumentation.newActivity()方法对Activity进行初始化123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125; 由上我们知道，主要通过反射机制实现Activity的初始化。再来看注释2，调用了Activity.attach(…)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; attach(context, aThread, instr, token, 0, application, intent, info, title, parent, id, lastNonConfigurationInstances, config); &#125; final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; attachBaseContext(context); mFragments.attachActivity(this); mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; mWindow.setWindowManager(null, mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; &#125; 此方法主要就是对Activity进行了初始化，初始化了许多的属性，具体如上。我们再看注释3，方法mInstrumentation.callActivityOnCreate(activity, r.state)，我们也来看看源码123456789101112131415161718192021222324252627public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; if (mWaitingActivities != null) &#123; synchronized (mSync) &#123; final int N = mWaitingActivities.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityWaiter aw = mWaitingActivities.get(i); final Intent intent = aw.intent; if (intent.filterEquals(activity.getIntent())) &#123; aw.activity = activity; mMessageQueue.addIdleHandler(new ActivityGoing(aw)); &#125; &#125; &#125; &#125; activity.performCreate(icicle);//核心代码 if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); &#125; &#125; &#125;&#125; 其实，主要也就是调用了Activity的OnCreate()方法，我们继续来看看123456final void performCreate(Bundle icicle) &#123; onCreate(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); mFragments.dispatchActivityCreated();&#125; 的确如此，最后调用了Activity的OnCreate方法，从而就启动了Activity。好了，到这里，Activity的启动流程就说完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、参考文档Activity启动流程源码分析(Launcher中) Android Activity启动流程源码全解析（1） Android Activity启动流程源码全解析（2）","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"Activity启动流程","slug":"Activity启动流程","permalink":"http://awenzeng.me/tags/Activity启动流程/"}]},{"title":"Android跨进程通信方式(IPC)解析","date":"2017-12-15T08:05:27.000Z","path":"2017/12/15/tech_android_framework_ipc/","text":"在Android的圈子里，一直有一个声音，那就是：要学会看Android源码。在前期，android开发者比较缺乏阶段，似乎大家也没那么重视，但随着时间的发展，Android开发者早已供大于求，需要具备的技能也不在仅限于应用开发，还需要对Android运行机制原理有一个深度的了解，从而更好的为项目服务。所以，阅读Android源码，也就成为Android开发人员必须要做的事。 在阅读Android源码时，我们发现，Android系统中跨进程通信主要就是Binder。关于Binder跨进程通信原理，我已写过一篇文章Binder通信机制原理解析,想了解的同学可以看一下。其中也有说到为什么Andorid系统跨进程通信要使用Binder。在Android系统中多数服务如ActivitManagerService,WindowManagerService,PackageManagerService等都是通过Binder进行通信的，在阅读源码时，我们会时时与其打交道，所以本篇博文主要是想梳理一下Andorid源码中常见的Binder跨进程通信的方式，以便自己在读源码时，可以更好的理解。 在Binder通信机制原理解析博文中，我们说到Binder跨进程通信方式有两种，分别为AIDL方式、注册服务方式。AIDL方式在开发中是我们经常使用的方式，这里将会采用对比的方式来解析系统服务的Binder跨进程通信。 一、常用AIDL方式1.aidl接口创建 以aidl为后缀创建一个接口类。如1234interface IMainService &#123; void start(String temp);&#125; 项目编译时，系统会自动生成相对应的java文件，如12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public interface IMainService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.awen.codebase.IMainService &#123; private static final java.lang.String DESCRIPTOR = \"com.awen.codebase.IMainService\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.awen.codebase.IMainService interface, * generating a proxy if needed. */ public static com.awen.codebase.IMainService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.awen.codebase.IMainService))) &#123; return ((com.awen.codebase.IMainService) iin); &#125; return new com.awen.codebase.IMainService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_start: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _arg0; _arg0 = data.readString(); this.start(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.awen.codebase.IMainService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public void start(java.lang.String temp) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(temp); mRemote.transact(Stub.TRANSACTION_start, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_start = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public void start(java.lang.String temp) throws android.os.RemoteException;&#125; 抽象类Stub相当于服务端，代理类Proxy相当于客户端。抽象类Stub继承于Binder，代理类Proxy依赖于IBinder接口。 2.AIDL的使用 AIDL的使用是以Service为载体，进而实现跨进程通信。我们知道Android的四大组件，在Androidmanifest中注册的时候可以通过android：process来指定组件所在的进程，当组件间不在同进程时，就需要跨进程通信了。AIDLService代码如下： 1234567891011121314151617181920public class AIDLService extends Service &#123; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; LogUtil.androidLog(\"Received start command.\"); return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; LogUtil.androidLog(\"Received binding.\"); return mBinder; &#125; private final IMainService.Stub mBinder = new IMainService.Stub() &#123; @Override public void start(String temp) throws RemoteException &#123; LogUtil.androidLog(\"AIDLService服务端打印日志：\"+temp); &#125; &#125;;&#125; 其中mBinder通过匿名内部类的形式初始化了Stub抽象类，进而AIDLService也就变成了Server端。当AIDLService与项目不在同一进程时，其他组件想与其通信，就必须要跨进程通信了。我们来看Activity与AIDLService通信，如1234567891011121314151617181920212223242526272829303132public class AIDLServiceConnection implements ServiceConnection &#123; private IMainService mService; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = IMainService.Stub.asInterface(service);//核心代码 try&#123; mService.start(\"Android IPC机制，Bindler跨进程通信~~~~~~~\"); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; LogUtil.androidLog(\"AIDL服务断开连接\"); &#125;&#125;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //AIDL跨进程通信 Intent intent = new Intent(this, AIDLService.class); AIDLServiceConnection connection = new AIDLServiceConnection(); bindService(intent,connection,BIND_AUTO_CREATE); &#125; Activity通过bindService的方式，建立与AIDLService服务的联系。这中间主要是通过ServiceConnection这个接口，我们来看一下注释中的核心代码，IMainService.Stub.asInterface(service)，这里我们再来看一下，aidl接口生成的java类的asInterface方法。 12345678910public static com.awen.codebase.IMainService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);//查询是否本地进程 if (((iin != null) &amp;&amp; (iin instanceof com.awen.codebase.IMainService))) &#123; return ((com.awen.codebase.IMainService) iin); &#125; return new com.awen.codebase.IMainService.Stub.Proxy(obj); &#125; 这里主要判断IBinder是否是跨进程，如果不是就返回本身，如果是则返回代理类Proxy，从而进行跨进程通信。具体Binder是怎么跨进程通信的，可以参考我的博文Binder通信机制原理解析。最后运行程序，结果如下 这里跨进程通信AIDL方式就讲解完了，AIDL方式源码地址：https://github.com/awenzeng/AndroidCodeLibrary,欢迎star，fork。 二、注册服务方式Android的各种系统服务在Android系统启动的时候就也会启动和注册，具体启动流程，可以参考Android应用程序入口源码解析，这篇博文中有介绍，想了解的同学可以看一下。系统服务启动和注册流程具体如下： 通过此图，我想大家对系统服务的启动流程已有一个大概认识。各种系统服务启动后，都会在ServiceManager进行注册备注，以方便应用进程调用，这ServiceManager相当于各种系统服务的大管家。另外，Andorid的各种系统服务都运行在system_server进程中，应用进程想要获取系统服务，就需要与system_server进程通信，Binder在其中就起着桥梁的作用。 Android系统中服务大约有八十多个，我们也没必要一一分析，遇到相关服务时，再进一步分析就好。本篇博文主要是针对跨进程通信(IPC)，所以也主要分析Andorid源码中常见的通过Binder通信的C/S端，来加深对Android源码的理解。常见的Android源码Binder通信C/S端有： ActivityManagerService(AMS),ActivityManagerNative(AMN),ActivityManagerProxy(AMP) ApplicationThread(AT),ApplicationThreadNative(ATN)，ApplicationThreadProxy(ATP) 1.AMS跨进程通信首先我们来看一下ActivityManagerNative源码，如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** &#123;@hide&#125; */public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; .... public ActivityManagerNative() &#123; attachInterface(this, descriptor); &#125; static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); String profileFile = data.readString(); ParcelFileDescriptor profileFd = data.readInt() != 0 ? data.readFileDescriptor() : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; int result = startActivity(app, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; public IBinder asBinder() &#123; return this; &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\");//1.核心代码 if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b);//2.核心代码 if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125; &#125;;&#125;class ActivityManagerProxy implements IActivityManager&#123; private IBinder mRemote; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public int startActivity(IApplicationThread caller, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); ...... mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ........ &#125;&#125; 从此源码来看，这与我们AIDL方式的接口生成的java代码很像，抽象类ActivityManagerNative就相当于抽象类Stub,代理类ActivityManagerProxy就相当于代理类Proxy，所以抽象类AMN就相当于Server端，代理类ActivityManagerProxy就相当于Client端。我们再来看一下ActivityManagerService类12345public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;......省略代码&#125; 可以看出ActivityManagerService继承至ActivityManagerNative，所以ActivityManagerService也是Server端，类似AIDL方式的AIDLService。我们再来看看ActivityManagerService的获取，在ActivityManagerNative源码中 1234567891011121314151617181920212223242526272829303132333435public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; ....... static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);//核心代码 &#125; static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\");//1.核心代码 if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b);//2.核心代码 if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125; &#125;;.........&#125; 主要通过一个静态方法ActivityManagerNative.getDefault()获取，而gDefault就是一个单例，从注释1：ServiceManager.getService(“activity”)，我们知主要就是从大管家ServiceManager中获取ActivityManagerService服务，但由于AMS是在不同的进程，所以通过asInterface()获取代理类ActivityManagerProxy来进行Binder跨进程通信。通过调用代理类AMP中的方法，然后跨进程通信，从而调用AMS中的相关方法。 到这里ActivitManagerService的Binder跨进程通信方式就简单介绍完了。 对于AMS，我不得不提一下，因为Android中四大组件Activity、Service、BroadcastReceiver和ContentProvider启动和使用都与其有关，可以说Andorid系统中比较重要的一个类。 2.ApplicationThread跨进程通信 同样的，首先我们先来看一下ApplicationThreadNative此类，源码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; /** * Cast a Binder object into an application thread interface, generating * a proxy if needed. */ static public IApplicationThread asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IApplicationThread in = (IApplicationThread)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ApplicationThreadProxy(obj); &#125; public ApplicationThreadNative() &#123; attachInterface(this, descriptor); &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder b = data.readStrongBinder(); boolean finished = data.readInt() != 0; boolean userLeaving = data.readInt() != 0; int configChanges = data.readInt(); schedulePauseActivity(b, finished, userLeaving, configChanges); return true; &#125; ......... &#125; return super.onTransact(code, data, reply, flags); &#125; public IBinder asBinder() &#123; return this; &#125;&#125;class ApplicationThreadProxy implements IApplicationThread &#123; private final IBinder mRemote; public ApplicationThreadProxy(IBinder remote) &#123; mRemote = remote; &#125; public final IBinder asBinder() &#123; return mRemote; &#125; public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(finished ? 1 : 0); data.writeInt(userLeaving ? 1 :0); data.writeInt(configChanges); mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; ......&#125; Binder跨进程通信定义方式，差不多都一样，ApplicationThread跨进程通信也和AIDL方式类似。其中抽象类ApplicationThreadNative为Server端，代理类ApplicationThreadProxy为Client端。我们再来看ApplicationThread类，通过阅读源码，我们知ApplicationThread是ActivityThread中内部类，这里我们也来看看ApplicationThread的源码12345678public final class ActivityThread &#123;final ApplicationThread mAppThread = new ApplicationThread();......private class ApplicationThread extends ApplicationThreadNative &#123;......&#125;&#125; 可以发现，ApplicationThread继承至ApplicationThreadNative，所以ApplicationThread也是AT跨进程通信的Server端，这里与AIDL的调用方式类似，通过一定的转换获取到代理类ApplicationThreadProxy，从而进行跨进程通信。 ApplicationThread跨进程通信方式，在Android系统中还是比较重要的，它主要与AMS跨进程通信一起使用，当ActivityManagerService执行完响应的操作后，再通过跨进程通信方式与应用进程通信(ApplicationThread是在应用进程中)，从而对Andorid的四大组件进行调度，Activity，Service等的启动及生命周期，也就是通过AMS跨进程通信和AT跨进程通信实现的。这点在阅读Activity及Service启动源码的时候，会接触的比较频繁。 到这里，我想说的就说完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 三、相关文档Binder通信机制原理解析 Android应用程序入口源码解析","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"}]},{"title":"Binder通信机制原理解析","date":"2017-12-14T11:24:20.000Z","path":"2017/12/14/tech_android_framework_binder/","text":"Binder是什么？Binder有啥用？作为一个应用开发者，如果我们开发的应用不涉及跨进程通信(IPC)，我想我们也不会去接触Binder。但不知你有没有发现，近来的Andorid面试，都会问及Android跨进程通信方面的知识，这又是为什么呢？如果你喜欢看Android源码，你就会发现Binder无处不在，Android系统中很多服务都是通过Binder来进行跨进程通信，了解Binder,弄懂Binder原理，这就变得非常重要了。 Android的内核是Linux内核,但为什么没有采用Linux常用的跨进程通信方式呢？而是采用Binder呢？这里在知乎有一篇非常详细的帖子:为什么 Android 要采用 Binder 作为 IPC 机制？大家可以看一下，我相信此篇帖子下肚，你就可以了解当年Android之父Andy Rubin为什么会选择Binder作为android系统跨进程通信方式了。 一、什么Binder?Binder是Android系统中非常重要的一种跨进程通信方式(IPC)。 Binder是一种基于C/S的架构，主要包含四个部分：服务端（Server）,客户端（Client）,Binder驱动,ServiceManager。 Android四大组件Activity、Service、BroadcastReceiver和ContentProvider的启动原理也都与Binder IPC机制有关；Android源码中ActivityManagerService、PackageManagerService、WindowManagerService、PowerManagerService等服务的调用也都与Binder IPC机制有关。 二、Binder跨进程通信实现原理1.应用进程空间分配 每个Android应用程序的进程，只能运行在自己进程所拥有的虚拟地址空间上。对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。 2.Binder进程通信原理 Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中 Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 3.Binder跨进程通信数据流动图： Client端发起通信请求–&gt;服务代理Proxy通过Parcel打包数据–&gt;内核空间Binder驱动实现共享数据–&gt;Server端解包Parcel获取数据。这样就实现了Client端到Server端的跨进程通信。 具体详细实现，可以参考这篇文章彻底理解Android Binder通信架构 三、Binder两种跨进程通信方式1.注册服务的方式 Android系统多数服务，都需要先注册，并通过ServiceManager守护进程来管理，需要用时，直接从ServiceManager中获取相关服务。例如ActivityManagerService、PackageManagerService、WindowManagerService、PowerManagerService等系统服务都是通过此种方式。这些服务什么时候注册呢？在Android应用程序入口源码解析这篇文章中有说，当Zygote进程启动后，启动SystemServer进程时，就会注册各种服务。具体系统服务是怎么通信的，下篇博文会介绍。 2.AIDL方式 这种方式也是开发中我们经常使用的方式。首先定义一个后缀为aidl的接口，如123interface IMainService &#123; void start(String temp);&#125; 项目编译成功后，会自动生成相关的java文件如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public interface IMainService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.awen.codebase.IMainService &#123; private static final java.lang.String DESCRIPTOR = \"com.awen.codebase.IMainService\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.awen.codebase.IMainService interface, * generating a proxy if needed. */ public static com.awen.codebase.IMainService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.awen.codebase.IMainService))) &#123; return ((com.awen.codebase.IMainService) iin); &#125; return new com.awen.codebase.IMainService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_start: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _arg0; _arg0 = data.readString(); this.start(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.awen.codebase.IMainService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public void start(java.lang.String temp) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(temp); mRemote.transact(Stub.TRANSACTION_start, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_start = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public void start(java.lang.String temp) throws android.os.RemoteException;&#125; 其中Stub就相当于Server端，代理Proxy就相当于Client端。在AIDL开发中，一般都是结合Service一起使用的，通过bindService把客户端和服务端链接起来，从而就可以进行通信。如果Service在同一个进程，就在进程中通信，如果Service在另外一个进程，就属于跨进程通信。 四、总结Binder跨进程通信，主要就是利用进程间内核空间共享数据来实现的。Binder驱动主要就是在内核空间，通过Binder驱动实现进程间数据共享。 五、参考文档彻底理解Android Binder通信架构 Binder系列—开篇 简单理解Binder机制的原理 Android进程间通信（IPC）机制Binder简要介绍和学习计划","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"Binder通信机制","slug":"Binder通信机制","permalink":"http://awenzeng.me/tags/Binder通信机制/"}]},{"title":"设计模式-六大原则","date":"2017-12-13T08:14:35.000Z","path":"2017/12/13/tech_design_pattern/","text":"当初作为小白，提到设计模式，就会觉得很高大上，很牛叉。其实，在我们身边，在我们的项目中，设计模式的身影无处不在。然而，什么是设计模式呢？百度解释为：设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 经验总是值得学习的，特别是对我们编程有极大帮助的设计模式经验。在Java中常见的设计模式有23种，而这23种设计模式都遵循了设计模式的六大原则，这六大原则分别是： 单一职责原则 里氏替换原则 依赖倒转原则 接口隔离原则 迪米特法则 开放封闭原则 一、单一职责原则1.定义：不要存在多于一个导致类变更的原因。 2.通俗的说：一个类只负责一项职责。 3.优点 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 二、里氏替换原则1.定义：所有引用基类的地方必须能透明地使用其子类的对象。 2.通俗的说：子类可以扩展父类的功能，但不能改变父类原有的功能。 具体含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 三、依赖倒转原则1.定义:高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 2.通俗的说：面向接口编程。 实际操作应注意： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 四、接口隔离原则1.定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 2.通俗的说：建立单一接口，不要建立庞大臃肿的接口。 注意要点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 五、迪米特法则1.定义：一个对象应该对其他对象保持最少的了解。 2.通俗的说：只与直接的朋友通信。 什么是直接的朋友？只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。 六、开放封闭原则1.定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 2.通俗的说：用抽象构建框架，用实现扩展细节。 依赖倒转原则与里氏替换原则实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public interface ICar &#123; void controlDirection();//控制方向 void addGas();//加油 void brakeCar();//刹车&#125;public class CayenneCar implements ICar &#123; @Override public void controlDirection() &#123; &#125; @Override public void addGas() &#123; &#125; @Override public void brakeCar() &#123; &#125;&#125;public class HavardCar implements ICar &#123; @Override public void controlDirection() &#123; &#125; @Override public void addGas() &#123; &#125; @Override public void brakeCar() &#123; &#125;&#125;public class Person &#123; private ICar car; public Person(ICar car) &#123; this.car = car; &#125; public void drive()&#123; car.addGas(); car.brakeCar(); car.controlDirection(); &#125;&#125;public class DesignPattern &#123; public DesignPattern() &#123; HavardCar havardCar = new HavardCar(); Person boy = new Person(havardCar); boy.drive(); CayenneCar bydCar = new CayenneCar(); Person girl = new Person(bydCar); girl.drive(); &#125;&#125; 参考文献设计模式六大原则（1）：单一职责原则 设计模式六大原则（2）：里氏替换原则 设计模式六大原则（3）：依赖倒转原则 设计模式六大原则（4）：接口隔离原则 设计模式六大原则（5）：迪米特法则 设计模式六大原则（6）：开放封闭原则","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://awenzeng.me/tags/设计模式/"}]},{"title":"Logger框架源码解析","date":"2017-11-30T06:20:58.000Z","path":"2017/11/30/tech_logger/","text":"在移动软件开发中，我们经常会用到很多框架，如网络框架retrofit，图片加载框架glide，数据库框架litepal，日志框架Logger等。这些框架对应用都很重要，日志框架也是其中重要的一部分。因为很多操作如调试，优化，修改bug等都需要通过日志来验证我们的想法，所以日志框架就成项目的必需。本篇博文将会介绍Logger日志框架，主要从源码的角度分析。 一、什么是Logger框架？Simple, pretty and powerful logger for android。简单，功能强大日志框架，专为Android。 Logger有多强大呢？先让我们来看一张打印日志图： 从此图，就可看出Logger打印日志相当强大。Logger框架原理图： 二、Logger源码解析(Json)Logger源码地址：https://github.com/orhanobut/logger 本篇博文主要采用版本V2.1.1的源码。 1.Logger初始化1Logger.addLogAdapter(new AndroidLogAdapter());//1.初始化 打印结果类似上面的效果图。我们先来看注释1初始化，进入Logger类1234567891011/** * But more pretty, simple and powerful */public final class Logger &#123; private static Printer printer = new LoggerPrinter(); ...... public static void addLogAdapter(LogAdapter adapter) &#123; printer.addAdapter(adapter); &#125;......&#125; Logger的静态方法，主要就是向printer中添加了一个Adapter，通过定义我们知道printer为LoggerPrinter,我们继续看看LoggerPrinter12345678class LoggerPrinter implements Printer &#123; private final List&lt;LogAdapter&gt; logAdapters = new ArrayList&lt;&gt;(); ...... @Override public void addAdapter(LogAdapter adapter) &#123; logAdapters.add(adapter); &#125;......&#125; 从方法名addLogAdapter就知向LogAdapter列表添加LogAdapter,源码下来也的确如此，但这LogAdapters有啥用呢？后面会说到。让我们再来看看AndroidLogAdapter12345678910111213public class AndroidLogAdapter implements LogAdapter &#123; private final FormatStrategy formatStrategy; public AndroidLogAdapter() &#123; this.formatStrategy = PrettyFormatStrategy.newBuilder().build(); &#125; public AndroidLogAdapter(FormatStrategy formatStrategy) &#123; this.formatStrategy = formatStrategy; &#125;......&#125; 在AndroidLogAdapter中初始化了FormatStrategy，这类有啥用呢？让我们来看看123public interface FormatStrategy &#123; void log(int priority, String tag, String message);&#125; FormatStrategy就是一接口，应该是打印日志的。我们来看看他的实现类PrettyFormatStrategy.newBuilder().build(),继续看PrettyFormatStrategy源码1234567891011121314151617181920212223242526272829303132public class PrettyFormatStrategy implements FormatStrategy &#123; private final int methodCount; private final int methodOffset; private final boolean showThreadInfo; private final LogStrategy logStrategy; private final String tag; private PrettyFormatStrategy(Builder builder) &#123; methodCount = builder.methodCount; methodOffset = builder.methodOffset; showThreadInfo = builder.showThreadInfo; logStrategy = builder.logStrategy; tag = builder.tag; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; ....... private Builder() &#123; &#125; ...... public PrettyFormatStrategy build() &#123; if (logStrategy == null) &#123; logStrategy = new LogcatLogStrategy(); &#125; return new PrettyFormatStrategy(this); &#125; &#125; 由上易知，主要就是对PrettyFormatStrategy初始化，然后赋值给AndroidLogAdapter的FormatStrategy。PrettyFormatStrategy类对Logger来说是核心类，因为所有日志的打印控制主要也在此类实现，接下来我们会说到。 2.Logger打印日志12Logger.d(\"Hello world!\");//2.debug日志Logger.json(\"&#123; \\\"key\\\": 3, \\\"value\\\": something&#125;\");//3.Json日志 i.debug日志，一般日志打印首先，我们来看一般日志，debug日志,进入Logger源码123456789101112131415161718192021public final class Logger &#123; private static Printer printer = new LoggerPrinter(); ..... public static void d(String message, Object... args) &#123; printer.d(message, args); &#125; public static void d(Object object) &#123; printer.d(object); &#125; public static void e(String message, Object... args) &#123; printer.e(null, message, args); &#125; public static void e(Throwable throwable, String message, Object... args) &#123; printer.e(throwable, message, args); &#125; ......&#125; 主要是执行printer中的方法，我们继续看LoggerPrinter12345678910111213141516171819class LoggerPrinter implements Printer &#123; ...... @Override public void d(String message, Object... args) &#123; log(DEBUG, null, message, args); &#125; @Override public void d(Object object) &#123; log(DEBUG, null, Utils.toString(object)); &#125; @Override public synchronized void log(int priority, String tag, String message, Throwable throwable) &#123; ....... for (LogAdapter adapter : logAdapters) &#123; if (adapter.isLoggable(priority, tag))&#123; adapter.log(priority, tag, message); &#125; &#125; &#125;&#125; 可以发现，主要就是遍历LogAdapters列表，因为adapter是不同的适配器，不同适配器有不同的打印日志信息格式。从Logger的初始化，我们知道传入的是AndroidLogAdapter并且AndroidLogAdapter中主要执行的是PrettyFormatStrategy中的log方法，这里我们直接看PrettyFormatStrategy中的log方法123456789101112131415161718192021222324252627@Override public void log(int priority, String onceOnlyTag, String message) &#123; String tag = formatTag(onceOnlyTag); logTopBorder(priority, tag);//1.Log顶端的线格式 logHeaderContent(priority, tag, methodCount);//2.log头部内容 //get bytes of message with system's default charset (which is UTF-8 for Android) byte[] bytes = message.getBytes(); int length = bytes.length; if (length &lt;= CHUNK_SIZE) &#123; if (methodCount &gt; 0) &#123; logDivider(priority, tag);//日志分界线 &#125; logContent(priority, tag, message);//3.log日志内容 logBottomBorder(priority, tag);//4.log底端线格式 return; &#125; if (methodCount &gt; 0) &#123; logDivider(priority, tag);//日志分界线 &#125; for (int i = 0; i &lt; length; i += CHUNK_SIZE) &#123; int count = Math.min(length - i, CHUNK_SIZE); //create a new String with system's default charset (which is UTF-8 for Android) logContent(priority, tag, new String(bytes, i, count));//5.log日志内容 &#125; logBottomBorder(priority, tag);//6.log底端线格式&#125; 此方法是Logger框架打印日志的核心方法，上面图片中的日志，主要就是通过这个方法控制打印的。让我们来看相关方法12345678910111213141516171819202122232425262728293031323334public class PrettyFormatStrategy implements FormatStrategy &#123; private static final char TOP_LEFT_CORNER = '┌'; private static final char BOTTOM_LEFT_CORNER = '└'; private static final char MIDDLE_CORNER = '├'; private static final char HORIZONTAL_LINE = '│'; private static final String DOUBLE_DIVIDER = \"────────────────────────────────────────────────────────\"; private static final String SINGLE_DIVIDER = \"┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄\"; private static final String TOP_BORDER = TOP_LEFT_CORNER + DOUBLE_DIVIDER + DOUBLE_DIVIDER; private static final String BOTTOM_BORDER = BOTTOM_LEFT_CORNER + DOUBLE_DIVIDER + DOUBLE_DIVIDER; private static final String MIDDLE_BORDER = MIDDLE_CORNER + SINGLE_DIVIDER + SINGLE_DIVIDER; ..... private void logTopBorder(int logType, String tag) &#123; logChunk(logType, tag, TOP_BORDER); &#125; private void logBottomBorder(int logType, String tag) &#123; logChunk(logType, tag, BOTTOM_BORDER); &#125; private void logDivider(int logType, String tag) &#123; logChunk(logType, tag, MIDDLE_BORDER); &#125; private void logContent(int logType, String tag, String chunk) &#123; String[] lines = chunk.split(System.getProperty(\"line.separator\"));//核心方法 for (String line : lines) &#123; logChunk(logType, tag, HORIZONTAL_LINE + \" \" + line); &#125; &#125; private void logChunk(int priority, String tag, String chunk) &#123; logStrategy.log(priority, tag, chunk); &#125;......&#125; 由上易知，最后都调用logChunk()方法，最后主要也是调用了logStrategy的log方法，通过Logger初始化，知logStrategy就是LogcatLogStrategy类,我们来看LogcatLogStrategy中的log方法1234567import android.util.Log;public class LogcatLogStrategy implements LogStrategy &#123; @Override public void log(int priority, String tag, String message) &#123; Log.println(priority, tag, message); &#125;&#125; 这里主要调用了android原生的打印日志方法，从而日志就被打印在logCat中了。到这里，一般日志打印就介绍完了，其他日志可以类推的，这里不介绍了。 ii.Json日志的打印 打印调用方法 1Logger.json(\"&#123; \\\"key\\\": 3, \\\"value\\\": something&#125;\");//3.Json日志 从debug日志打印分析中，我们知道PrettyFormatStrategy的log类为打印日志核心方法，对于json日志打印，主要是打印内容的区别，其他打印没有区别，所以这里主要看看打印日志的方法123456private void logContent(int logType, String tag, String chunk) &#123; String[] lines = chunk.split(System.getProperty(\"line.separator\"));//核心方法 for (String line : lines) &#123; logChunk(logType, tag, HORIZONTAL_LINE + \" \" + line); &#125;&#125; 这里知道，对打印内容chunk进行了分割，主要以System.getProperty(“line.separator”)即换行符\\n进行分割。从打印Json内容中，我们没有发现换行符，这里需要看看最初调用的方法。由Logger初始化，我们知Logger.json()方法主要就是调用LoggerPrinter中的json方法，这里让我们来看LoggerPrinter.json()方法123456789101112131415161718192021222324@Override public void json(String json) &#123; if (Utils.isEmpty(json)) &#123; d(\"Empty/Null json content\"); return; &#125; try &#123; json = json.trim(); if (json.startsWith(\"&#123;\")) &#123; JSONObject jsonObject = new JSONObject(json); String message = jsonObject.toString(JSON_INDENT);//1 d(message); return; &#125; if (json.startsWith(\"[\")) &#123; JSONArray jsonArray = new JSONArray(json); String message = jsonArray.toString(JSON_INDENT);//2. d(message); return; &#125; e(\"Invalid Json\"); &#125; catch (JSONException e) &#123; e(\"Invalid Json\"); &#125; &#125; 通过调试，知道就是在注释中的位置，在进行转化的时候，字符串”{ \\”key\\”: 3, \\”value\\”: something}”转为”{\\n”key”: 3,\\n”value”: something\\n}”，从而在打印的时候，就可以分行打印键值对。这样也就再打印json的时候可以分行显示。 到这里，日志Logger框架原理分析就讲解完。其中logger框架还支持打印xml，具体原理如何，这里不做介绍了。 三、总结Logger日志框架，让Log日志变得整洁，简单，易看，一大功德。其中PrettyFormatStrategy通过静态内部类实现了Logger显示内容配置方式值得借鉴。 四、相关参考文档Looger官方介绍","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"开源框架源码解析","slug":"开源框架源码解析","permalink":"http://awenzeng.me/tags/开源框架源码解析/"},{"name":"Logger框架源码解析","slug":"Logger框架源码解析","permalink":"http://awenzeng.me/tags/Logger框架源码解析/"}]},{"title":"Android应用程序入口源码解析","date":"2017-11-23T13:43:41.000Z","path":"2017/11/23/tech_android_framework_appstart/","text":"我们在写C、C++或java应用时，都会有一个main函数，但Android的main函数在哪里呢？偶记得从第一个HelloWorld应用开始，就知道，只要在AndroidManifest配置表中对Activity的intent-filter进行配置，action为android.intent.action.MAIN，category为android.intent.category.LAUNCHER，应用程序启动的时候就会首先启动这个Activity，此Activity也就是应用的入口；后来又知道Application这个类，只要有类继承Application,并在AndroidManifest配置表中对application的name进行配置该类，android应用启动后会把该类的attachBaseContext和onCreate方法作为程序开发入口。实际上是不是这样的呢？本篇博文将会从源码角度来分析。 在说Android应用程序开发入口之前，我们有必要了解一下android系统的启动和Android应用程序的启动流程，这样有助于我们对Android系统有一个整体的认识。首先，让我们来简单了解一下Android系统的启动流程。 一、Android系统的启动Android系统的启动流程是怎样的呢？首先先来看一下流程图： 根据图，我们知Android启动流程的步骤如下： 1.启动电源当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。 2.引导程序BootLoader执行引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。 3.Linux内核启动内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找init.rc文件，并启动init进程。 4.init进程启动初始化和启动属性服务，并且启动Zygote进程。 5.Zygote进程启动创建JavaVM并为JavaVM注册JNI，创建服务端Socket，启动SystemServer进程。 6.SystemServer进程启动启动Binder线程池和SystemServiceManager，并且启动各种系统服务，例如：ActivityManagerService、PowerManagerService、PackageManagerService，BatteryService、UsageStatsService等其他80多个系统服务。 7.Launcher启动被SystemServer进程启动的ActivityManagerService会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到界面上。 关于Android系统的启动源码分析，这里推荐大神刘望舒的几篇文章，讲得比较详细： Android系统启动流程（一）解析init进程启动过程 Android系统启动流程（二）解析Zygote进程启动过程 Android系统启动流程（三）解析SyetemServer进程启动过程 Android系统启动流程（四）Launcher启动过程与系统启动流程 二、Android应用程序启动上面说到，当Android系统启动完成之后，Lancher也就启动完成了，在我们的桌面上就会看到已安装的应用快捷图标。点击快捷图标，就能启动我们的应用程序。我们知道，android系统中的每一个应用程序，都是独立运行在自己的进程中的，所以在点击应用快捷图标后，如果应用程序还没有进程，首先应该会先建立应用程序的进程。具体流程是怎样的呢？我们先来看流程图： 从流程图知，应用程序在没有创建进程的情况下，会通过ActivitServiceManager去请求服务端Socket，服务端Socket再去请求Zygote进程，让其帮忙建立进程，而Zygote进程会fork自身来创建应用程序进程。应用程序进程创建的同时，应用程序的主线程也会创建，与主线程息息相关的ActivityThread类也会创建，并调用自身的main方法，进行相关的初始化。 具体进程是怎么创建的，这里也还是推荐大神刘望舒的两篇文章，其中非常详细的分析了应用进程的创建过程，想了解的可以看一下。 Android应用程序进程启动过程（前篇） Android应用程序进程启动过程（后篇） 好了，下面我们来继续说说ActivityThread的main方法，也即Android应用程序的入口。 三、Android应用程序入口源码分析通过Android应用程序的启动，我们知道android应用程序的入口，即ActivityThread的main方法。但在我们开发的时候，很少接触ActivityThread类,主要还是Application和Activity，他俩与ActivityThread的关系怎样呢？让我们从源码中来看看，ActivityThread的main方法：1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper();//1.Looper的创建 if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread();//2.ActivityThread初始化 thread.attach(false);//3.调用ActivityThread附属方法attach AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop();//4.Looper消息开始循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 在main方法中，主线程的Looper实现了初始化和消息循环，这与Android的消息机制息息相关。关于消息机制，我已写过一个篇文章为Android消息机制源码解析(Handler)，想了解的可以看一下。这里我们主要来看一下ActivityThread的初始化和attach方法，其中ActivityThread初始化构造方法什么也没做，没啥好看的，我们主要来看看attach方法1234567891011121314151617181920212223242526272829303132private void attach(boolean system) &#123; sThreadLocal.set(this); mSystemThread = system; if (!system) &#123;//false，不是system,普通app .......省略 android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\"); RuntimeInit.setApplicationObject(mAppThread.asBinder()); IActivityManager mgr = ActivityManagerNative.getDefault();//1.核心代码 try &#123; mgr.attachApplication(mAppThread);//2.核心代码 &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; else &#123;//true，是system // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(\"system_process\"); try &#123; mInstrumentation = new Instrumentation(); ContextImpl context = new ContextImpl(); context.init(getSystemContext().mPackageInfo, null, this); Application app = Instrumentation.newApplication(Application.class, context); mAllApplications.add(app); mInitialApplication = app; app.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate Application():\" + e.toString(), e); &#125; &#125; ......省略&#125; ActivityThread调用attach()传入的参数是false，不是system。注释1通过静态方法ActivityManagerNative.getDefault()获取IActivityManager,实际上是获取到ActivityManagerProxy类，让我们来看ActivityManagerNative.getDefault()方法,进入ActivityManagerNative类1234567891011121314151617181920212223242526272829303132333435363738/** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);//核心方法&#125;/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b);//核心方法 if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 通过查看ActivityManagerProxy类，了解到它实现IActivityManager接口,mgr就是ActivityManagerProxy。知道返回的类后，我们再来看一下注释2，mgr.attachApplication(mAppThread)，其中mAppThread为ApplicationThread，让我们再进入ActivityManagerProxy，看看attachApplication方法12345678910111213141516171819202122232425class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; ....... public void attachApplication(IApplicationThread app) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);//核心代码 reply.readException(); data.recycle(); reply.recycle(); &#125; .......&#125; 从源码中，了解到mRemote是一个IBinder，通过Binder实现进程间通信(Android核心进程通信方法)，从而调用到ActivityServiceManager里面对应的方法12345678public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//核心方法 Binder.restoreCallingIdentity(origId); &#125;&#125; 我们来继续看方法attachApplicationLocked()123456789101112131415private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ....... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, true); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); ..... return true; &#125; 在attachApplicationLocked()方法中,细节比较多，我们省略掉了，主要来看一下核心方法bindApplication(),其中thread就是ActivityThread中ApplicationThread类，让我们再来看ApplicationThread中的bindApplication()方法12345678910111213141516171819202122232425262728293031323334public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfileFile = profileFile; data.initProfileFd = profileFd; data.initAutoStopProfiler = false; queueOrSendMessage(H.BIND_APPLICATION, data);//核心方法&#125; 其中queueOrSendMessage方法主要就是向Handler发送了一个Message，让我们来看看具体的方法1234567891011121314151617181920212223// if the thread hasn't started yet, we don't have the handler, so just // save the messages until we're ready. private void queueOrSendMessage(int what, Object obj) &#123; queueOrSendMessage(what, obj, 0, 0); &#125; private void queueOrSendMessage(int what, Object obj, int arg1) &#123; queueOrSendMessage(what, obj, arg1, 0); &#125; private void queueOrSendMessage(int what, Object obj, int arg1, int arg2) &#123; synchronized (this) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; mH.sendMessage(msg); &#125; &#125; 容易知道，主要就是向Handler mH中发送一条消息，根据Handler消息循环机制，可以在handMessage查看处理方法，根据H.BIND_APPLICATION12345678910111213141516 private class H extends Handler &#123; ..... public static final int BIND_APPLICATION = 110; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; ....... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data);//核心方法 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ....... &#125;&#125; 继续看handleBindApplication()方法12345678910111213141516171819202122private void handleBindApplication(AppBindData data) &#123; try &#123; ......... Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ...... try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; &#125; try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; 通过分析知data为AppBindData，data.info是一个LoadeApk对象。data.info.makeApplication()，让我们继续看LoadeApk中的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); ContextImpl appContext = new ContextImpl(); appContext.init(this, null, mActivityThread); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext);//1.核心方法 appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to instantiate application \" + appClass + \": \" + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; instrumentation.callApplicationOnCreate(app);//2.核心方法 &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; return app; &#125; 主要还是调ActivityThread中mInstrumentation.newApplication()方法，并传入了继承Application的类的类名appClass，当Applicaiton建立后，马上就调用了方法2即Application的onCreate(),让我们先来看Instrumentation中的newApplication()方法1234567891011121314 public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return newApplication(cl.loadClass(className), context);&#125;static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context);//方法 return app;&#125; 到这里，就建立了应用程序的Application，然而在Application中那个方法是最先调用的呢？让我们继续看一下1234567/** * @hide *//* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 由此我们知道Application初始化后，首先调用的是attachBaseContext()方法，其次才是Application的onCreate方法，让我们看一下调用onCreate()方法,在前面的makeApplication()方法中，有此代码instrumentation.callApplicationOnCreate(app)，我们继续来看看源码123public void callApplicationOnCreate(Application app) &#123; app.onCreate();&#125; 到这里Android应用程序的入口源码就分析完了。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 四、总结Android应用程序的入口是ActivityThread的main方法，而Android应用程序的开发入口是Application的attachBaseContext()和onCreate()。如果有类继承Application，并在Androidmanifest中配置了，它就会优先启动。在继承Application类初始化后，首先调用的是attachBaseContext()方法，其次才是onCreate方法。 五、相关及参考文档Activity启动过程全解析 深入理解ActivityManagerService Android系统启动流程（一）解析init进程启动过程 Android系统启动流程（二）解析Zygote进程启动过程 Android系统启动流程（三）解析SyetemServer进程启动过程 Android系统启动流程（四）Launcher启动过程与系统启动流程 Android应用程序进程启动过程（前篇） Android应用程序进程启动过程（后篇）","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"Android应用程序入口源码解析","slug":"Android应用程序入口源码解析","permalink":"http://awenzeng.me/tags/Android应用程序入口源码解析/"}]},{"title":"Android消息机制源码解析(Handler)","date":"2017-11-21T07:44:59.000Z","path":"2017/11/21/tech_android_framework_handler/","text":"Android消息机制，其实也就是Handler机制，主要用于UI线程和子线程之间交互。众所周知，一般情况下，出于安全的考虑，所有与UI控件的操作都要放在主线程即UI线程中，而一些耗时操作应当放在子线程中。当在子线程中完成耗时操作并要对UI控件进行操作时，就要用Handler来控制。另外，Android系统框架内，Activity生命周期的通知等功能也是通过消息机制来实现的。本篇博文主要是想通过Handler源码解析，来加深我自己对Android消息机制的理解。 一、Handler使用使用例子：12345678910111213141516171819202122private Handler handler = new Handler()&#123;//1.Handler初始化,一个匿名内部类 @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(\"对UI进行操作\"); &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.mytv); new Thread(new Runnable() &#123; @Override public void run() &#123; //模拟耗时操作 SystemClock.sleep(3000); handler.sendMessage(new Message());//2.在子线程中sendMessage(); &#125; &#125;).start(); &#125; 1.我们先来看看，Handler初始化。Handler初始化的同时，实现了消息处理方法handleMessage()。查看Handler源码123456789101112131415161718192021222324252627final MessageQueue mQueue;final Looper mLooper;final Callback mCallback;/** * Default constructor associates this handler with the queue for the * current thread. * * If there isn't one, this handler won't be able to receive messages. */public Handler() &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//3.核心代码。获取一个Looper if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue;//4.核心代码。从Looper获取一个消息队列 mCallback = null;&#125; 在源码中，Handler定义了一个MessageQueue消息队列mQueue和一个Looper对象mLooper，并都进行了初始化，分别对mQueue和mLooper进行了赋值，其中mLooper是通过Looper.myLooper()赋值，mQueues是Looper中的mQueue。通过了解，知Looper.myLooper()是一个静态方法。让我们进入Looper类看看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * &#123;@link #prepare&#125; in the thread that is to run the loop, and then * &#123;@link #loop&#125; to have it process messages until the loop is stopped. * * &lt;p&gt;Most interaction with a message loop is through the * &#123;@link Handler&#125; class. * * &lt;p&gt;This is a typical example of the implementation of a Looper thread, * using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an * initial Handler to communicate with the Looper. * * &lt;pre&gt; * class LooperThread extends Thread &#123; * public Handler mHandler; * * public void run() &#123; * Looper.prepare(); * * mHandler = new Handler() &#123; * public void handleMessage(Message msg) &#123; * // process incoming messages here * &#125; * &#125;; * * Looper.loop(); * &#125; * &#125;&lt;/pre&gt; */public class Looper &#123; private static final String TAG = \"Looper\"; // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); private static Looper sMainLooper; // guarded by Looper.class final MessageQueue mQueue; final Thread mThread; volatile boolean mRun; private Printer mLogging; /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; ...... &#125; /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static Looper myLooper() &#123; return sThreadLocal.get(); &#125; ......&#125; 从Looper源码的注释中，我们知道Looper是一个专门为线程提供消息循环的类，通过调用prepare()和loop()就可以为线程提供一个消息循环机制。线程本来是没有消息循环机制的，想要消息循环机制就必须自己建立。如：12345678910111213class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; 在Looper源码中，有两个方法prepare()和prepareMainLooper()对Looper进行了初始化,Looper.myLooper()核心代码为sThreadLocal.get()，主要也是从sThreadLocal中取值。两个初始化方法的源码为1234567891011121314151617181920212223242526272829303132 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; 从源码中知道prepare()创建的Looper为允许退出循环的，而prepareMainLooper()方法创建的是不应许退出循环的，通过分析，很明显知道prepare()方法创建的是一般线程的Looper,而通过而prepareMainLooper()创建的，就是主线程消息循环的Looper。 现在，虽然我们知道了Handler中对MessageQueue队列和Looper进行了赋值，但是Looper啥时候通过prepareMainLooper()初始化的呢？什么是开始调loop()开始循环的呢？这里我们先停一下，后面我们会说道。 2.我们再看例子中的注释方法，在子线程中handler.sendMessage(message) 我们继续看Handler源码123456789101112131415161718192021222324252627282930 ...... public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; boolean sent = false; MessageQueue queue = mQueue; if (queue != null) &#123; msg.target = this;//1.对Message中的target赋值Handler sent = queue.enqueueMessage(msg, uptimeMillis);//2.向循环队列中，加入消息 &#125; else &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); &#125; return sent; &#125;.... 阅读Handler源码知，发送消息的方法还有许多种，sendMessage()是其中一种，如果还想具体了解还有哪些，可以下载Handler源码看一下，这里就不一一介绍了。从上面三个方法中我们了解到方法sendMessageAtTime()是最后调用的，这个方法主要是，对Message的target赋值为发送主体Handler，并把Message加入消息队列MessageQueue中，等待消息队列循环处理。 Handler发送主体为Message，Message是啥呢？Message主要就是对一些数据做封装处理，其中有int变量what,arg1,arg2,Object变量obj等，具体可以查看Message源码，这里就不详细说了。 二、Looper的创建及循环机制上面说到，Looper的建立有两种方式prepare()和prepareMainLooper()，其中prepare建立的为一般子线程Looper，可以取消循环；而prepareMainLooper()建立的为主线程的Looper，不可以取消循环。到底而prepareMainLooper建立的是不是主线程循环呢？让我们继续分析 1.主线程Looper建立 主线程即UI线程，说到UI线程，我们知道应用程序一启动，主(UI)线程就开始启动，而线程的建立必须要在进程的基础上。通过对Android应用程序启动的分析，我们知道，应用程序启动，首先会通过Zygote复制自身fork出一个进程，然后再由进程创建一个主线程，主线程的建立和ActivityThread息息相关，通过分析，知ActivityThread的main方法就是应用程序启动的入口。具体可以参考：Android应用程序进程启动过程（前篇） 让我们来看一下ActivityThread类的main方法：1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper();//1.主线程Looper创建 if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false); AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop();//2.主线程Looper循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 从源码知道，正如我们想的那样prepareMainLooper()建立的Looper就是主线程的Looper。 2.Looper的消息循环 从上面ActivityThread的main方法中，我们发现Looper.loop()消息循环方法。Looper是怎么循环的，这里让我们来看一下Looper.loop()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123;//for循环 Message msg = queue.next(); //从消息队列中取值 if (msg == null) &#123;//消息为空就返回 // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg);//分发消息 if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycle(); &#125; &#125; 从loop()源码中我们知道，建立了一个for循环从消息队列中取数据，然后通过msg.target.dispatchMessage(msg)分发消息，从前面我们知道target就是handler,这里我们再看一下Handler的消息分发方法dispatchMessage()123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 在这里我们就看到，Handler最后会调用handleMessage()方法，只要message中callback为空，就是调用handleMessage(),从而实现消息的处理。 到这里，我们Android Handler消息分发机制解析就分解完了。但这里需要注意一下的是，在loop循环中，如果消息为空就会跳出循环，而我们的主线程Looper循环应该是死循环才对。针对这个问题，我们继续深入源码看一下，前面说prepare()和prepareMainLooper()是两种建立Looper的方式，两者的区别是一个是可取消循环的，一个是不可以取消循环的，这里让我们再来看看一下Looper的源码12345678910111213private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread();&#125; 通过查看源码发现，是否可以取消消息循环，主要控制是MessageQueue里面，这里我们可以知道，主线程的消息循环控制应该就在 queue.next()方法里,好了，让我们来看MessageQueue的next方法12345678910111213141516171819202122232425final Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(mPtr, nextPollTimeoutMillis);//1.核心代码 synchronized (this) &#123; if (mQuiting) &#123; return null; &#125; .......省略代码，获取消息队列中的Message // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 在next()方法中，有一个原生方法nativePollOnce(),它的作用是干啥的呢？是不是就是控制主线程循环的呢？通过进一步阅读C++源码，我们知道这里是利用Linux系统中epoll_wait方法来进行阻塞，形成一个等待状态，也就是说，当消息队列中消息为空时，nativePollOnce()方法不会返回，会进行阻塞，形成一个等待状态，等有新消息进入消息队列，才会返回，从而获取消息。这里我们也来看一下消息队列的插入方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final boolean enqueueMessage(Message msg, long when) &#123; if (msg.isInUse()) &#123; throw new AndroidRuntimeException(msg + \" This message is already in use.\"); &#125; if (msg.target == null) &#123; throw new AndroidRuntimeException(\"Message must have a target.\"); &#125; boolean needWake; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(\"MessageQueue\", e.getMessage(), e); return false; &#125; msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; &#125; if (needWake) &#123; nativeWake(mPtr);//核心代码 &#125; return true; &#125; 在消息队列中加入消息之后，会调用一个原生方法 nativeWake()，这个原生的C++的方法，也就是通知nativePollOnce()返回的方法，通过方法nativeWake和nativePollOnce的一唱一和，从而实现主线程的消息队列的无限循环。 具体C++代码是怎么实现的，这里推荐一篇博文从源码角度分析native层消息机制与java层消息机制的关联。 好了，分析就到这里了。 三、总结Android消息分发机制，也就是Handler处理消息机制。流程如下： 1.应用程序在启动的时候，通过Zygote复制自身fork出应用程序的进程，然后该进程又以ActivityThread创建主线程。 2.主线程启动时，在ActivityThread的main方法中初始化了Looper和执行消息队列的循环。 3.使用过程中，Handler初始化，获取了主线程的Looper和消息队列MessageQueue，并实现消息处理方法handlerMessage 4.Handler通过sendMessage方法将消息插入消息队列 5.通过Looper消息队列的循环，从而执行处理方法，实现了UI线程和子线程之间的交互。 注：源码采用android-4.1.1_r1版本，建议下载源码然后自己走一遍流程，这样更能加深理解。 四、相关及参考文档Android应用程序进程启动过程（前篇） Android消息机制学习笔记 从源码角度分析native层消息机制与java层消息机制的关联。 ActivityThread Java单链表、双端链表、有序链表实现","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android框架源码解析","slug":"Android框架源码解析","permalink":"http://awenzeng.me/tags/Android框架源码解析/"},{"name":"Android消息机制源码解析","slug":"Android消息机制源码解析","permalink":"http://awenzeng.me/tags/Android消息机制源码解析/"}]},{"title":"Butter Knife框架源码解析","date":"2017-11-17T03:22:25.000Z","path":"2017/11/17/tech_butterknife/","text":"最初的开始，findViewById()获取View控件，setOnClickListener设置View的监听事件，然后UI界面开始有响应。当初完成这个操作，有点兴奋，而这也成为我Android开发的起点。随着时间的推移，android也越来越熟悉，findViewById和setOnClickListener不知写了多少遍，偶发现有好大一部分时间，就是在写findViewById获取变量。针对这问题，在网络上发现了Jake Wharton大神的Butterknife开源框架，后用之，节约了很多时间。本篇博文将会对Butterknife源码进行解析。 一、什么是Butterknife？Butterknife，是专门为Android View设计的绑定注解框架，专业解放各种findViewById和setOnClickListener。 Butterknife地址：https://github.com/JakeWharton/butterknife 二、Butterknife源码解析1.Butterknife绑定分析12345678910111213141516171819202122public class FeedbackActivity extends Activity&#123; @BindView(R.id.mContentEdit) EditText mContentEdit; @BindView(R.id.mSubmitBtn)//1.View注解 TextView mSubmitBtn; @BindView(R.id.mContentCountTv) TextView mContentCountTv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_feedback); ButterKnife.bind(this);//3.与Activity绑定 &#125; @OnClick(R.id.mSubmitBtn)//2.View监听事件注解 public void onClick() &#123; &#125;&#125; 由1知，@BindView注解FeedbackActivity的3个View变量，由2知，@OnClick注解View的监听事件。然而这三个变量和监听事件，是怎么和FeedbackActivity关联起来的呢？这里就需要我们注意3与Activity的绑定，即ButterKnife.bind(this)方法。进入ButterKnife源码看看。1234567891011/** * BindView annotated fields and methods in the specified &#123;@link Activity&#125;. The current content * view is used as the view root. * * @param target Target activity for view binding. */@NonNull @UiThreadpublic static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; ButterKnife中bind有多个重载，针对View，Dialog，Activtiy等，具体可以自行查看ButterKnife源码，这里主要针对Activity。我们继续看createBinding方法,12345678910111213141516171819202122232425262728private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, \"Looking up binding for \" + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);//查找辅助绑定类的构造方法 if (constructor == null) &#123; return Unbinder.EMPTY; &#125; //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. try &#123; return constructor.newInstance(target, source);//初始化了构造方法 &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Unable to invoke \" + constructor, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Unable to invoke \" + constructor, e); &#125; catch (InvocationTargetException e) &#123; Throwable cause = e.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(\"Unable to create binding instance.\", cause); &#125; &#125; findBindingConstructorForClass()通过传入目标类即Activity，查找辅助绑定类的构造方法。继续看findBindingConstructorForClass()方法1234567891011121314151617181920212223242526@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); if (bindingCtor != null) &#123; if (debug) Log.d(TAG, \"HIT: Cached in binding map.\"); return bindingCtor; &#125; String clsName = cls.getName();//获取绑定类的name if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) &#123; if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\"); return null; &#125; try &#123; Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\");//核心方法，通过反射加载类\"FeedbackActivity_ViewBinding\" //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);//获取\"FeedbackActivity_ViewBinding\"构造函数， if (debug) Log.d(TAG, \"HIT: Loaded binding class and constructor.\"); &#125; catch (ClassNotFoundException e) &#123; if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName()); bindingCtor = findBindingConstructorForClass(cls.getSuperclass()); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e); &#125; BINDINGS.put(cls, bindingCtor); return bindingCtor;//返回绑定类的构造函数，初始化&#125; 通过反射加载FeedbackActivity_ViewBinding类，而FeedbackActivity_ViewBinding类到底像啥样呢？这里我们可以先看一下此类,后面将会分析此类怎么生成。1234567891011121314151617181920212223public class FeedbackActivity_ViewBinding&lt;T extends FeedbackActivity&gt; implements Unbinder &#123; protected T target; private View view2131624065; @UiThread public FeedbackActivity_ViewBinding(final T target, View source) &#123; this.target = target; View view; target.mContentEdit = Utils.findRequiredViewAsType(source, R.id.mContentEdit, \"field 'mContentEdit'\", EditText.class); view = Utils.findRequiredView(source, R.id.mSubmitBtn, \"field 'mSubmitBtn' and method 'onClick'\"); target.mSubmitBtn = Utils.castView(view, R.id.mSubmitBtn, \"field 'mSubmitBtn'\", TextView.class); view2131624065 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onClick(); &#125; &#125;); target.mContentCountTv = Utils.findRequiredViewAsType(source, R.id.mContentCountTv, \"field 'mContentCountTv'\", TextView.class); &#125;...省略...&#125; 其中findRequiredViewAsType和findRequiredView方法皆是Utils的方法，我们查看Utils方法可以知道，两个方法最后都调了findViewById方法,从而就绑定了注解的View变量，绑定View监听事件。12345678910111213141516171819202122public static &lt;T&gt; T findRequiredViewAsType(View source, @IdRes int id, String who, Class&lt;T&gt; cls) &#123; View view = findRequiredView(source, id, who); return castView(view, id, who, cls);&#125;public static View findRequiredView(View source, @IdRes int id, String who) &#123; View view = source.findViewById(id); if (view != null) &#123; return view; &#125; String name = getResourceEntryName(source, id); throw new IllegalStateException(\"Required view '\" + name + \"' with ID \" + id + \" for \" + who + \" was not found. If this view is optional add '@Nullable' (fields) or '@Optional'\" + \" (methods) annotation.\");&#125; 到这里，ButterKnife的绑定流程就介绍完了。ButterKnife主要就是通过注解，然后生成一个辅助类动态绑定View,解放开发者。下面我们将会分析辅助类FeedbackActivity_ViewBinding的生成。 2.Butterknife辅助类的生成 由上，我们知Butterknife框架是用注解的方式实现的，注解的实现方式，很容易让我们想到通过Java反射机制实现，但是我们知道如果通过反射，是在运行时（Runtime）来处理View的绑定等一些列事件，这样比较耗费资源，会影响应用的性能。Butterknife框架没有用java反射机制，而是使用APT(Annotation Processing Tool)编译时解析技术。提到APT，我们就必须要了解AbstractProcessor类，通过继承此类，编译器在编译的时候，会扫描所有带有你注解的类，然后再调用AbstractProcessor的process方法，对注解进行处理，然后生成相关的辅助类，如上FeedbackActivity_ViewBinding。 在Butterknife框架中ButterKnifeProcessor继承了AbstractProcessor，所以我们重点来关注一下ButterKnifeProcessor的process方法1234567891011121314151617@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);//1.核心方法 for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk, debuggable);//2.核心方法 try &#123; javaFile.writeTo(filer);//3.核心方法 &#125; catch (IOException e) &#123; error(typeElement, \"Unable to write binding for type %s: %s\", typeElement, e.getMessage()); &#125; &#125; return false;&#125; 通过遍历bindingMap，再利用JavaFile，就可以生成辅助类了。bindingMap的类型为Map，其中TypeElement为key,BindingSet为值，TypeElement和BindingSet两个类在Butterknife框架中都是辅助生成辅助类的方法。BindingSet对辅助类的生成起到非常重要的作用，类名，变量，方法名各种信息都是储存在BindingSet类中。这里不重讲了。让我们继续分析findAndParseTargets方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env);//1.扫描所有注解类 .........//省略的内容雷同BindView注解 // Process each @BindView element. for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;//2.遍历有@BindView注解的类 // we don't SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindView(element, builderMap, erasedTargetNames);//3.解析@BindView注解类 &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; .........//省略的内容雷同BindView注解 // Process each annotation that corresponds to a listener. for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;//4.遍历监听事件注解类 findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; bindingMap.put(type, builder.build()); &#125; else &#123; BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven't built it yet. Re-enqueue for later. entries.addLast(entry); &#125; &#125; &#125; return bindingMap; &#125; 方法scanForRClasses，主要是扫描所有类，区分注解类。这里不重点讲了。拿到@BindView的注解类后，遍历，然后通过parseBindView方法解析，我们继续看parseBindView方法123456789101112131415161718192021222324252627282930313233343536private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); .......//省略代码，主要检测注解的合法性，这里不介绍 if (hasError) &#123; return; &#125; // Assemble information on the field. int id = element.getAnnotation(BindView.class).value();//1.获取注解值，相当于获取view ID（R.id.mSubmitBtn） BindingSet.Builder builder = builderMap.get(enclosingElement);//2.builderMap中获取BindingSet.Builder QualifiedId qualifiedId = elementToQualifiedId(element, id); if (builder != null) &#123;//3.builder是否为空 String existingBindingName = builder.findExistingBindingName(getId(qualifiedId)); if (existingBindingName != null) &#123;//4.检测是否重复绑定 error(element, \"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)\", BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; builder = getOrCreateBindingBuilder(builderMap, enclosingElement);//5.为空，需要重新get或生成一个新的BindingSet.Builder &#125; String name = simpleName.toString(); TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));//6.往Builder中添加新值 // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement); &#125; 第一次，一般都为空值，所以会执行getOrCreateBindingBuilder(builderMap, enclosingElement)方法，其中传入了BuilderMap和enclosingElement,我们继续来看方法getOrCreateBindingBuilder123456789private BindingSet.Builder getOrCreateBindingBuilder( Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) &#123; BindingSet.Builder builder = builderMap.get(enclosingElement); if (builder == null) &#123; builder = BindingSet.newBuilder(enclosingElement); builderMap.put(enclosingElement, builder); &#125; return builder;&#125; 其中，再次判断了builderMap中是否已存在BindingSet.Builder，不存在就新建，通过BindingSet.newBuilder(enclosingElement)方法，让我继续看BindingSet中newBuilder方法1234567891011121314151617181920static Builder newBuilder(TypeElement enclosingElement) &#123; TypeMirror typeMirror = enclosingElement.asType(); boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE); boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE); boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE); TypeName targetType = TypeName.get(typeMirror); if (targetType instanceof ParameterizedTypeName) &#123; targetType = ((ParameterizedTypeName) targetType).rawType; &#125; String packageName = getPackage(enclosingElement).getQualifiedName().toString(); String className = enclosingElement.getQualifiedName().toString().substring( packageName.length() + 1).replace('.', '$'); ClassName bindingClassName = ClassName.get(packageName, className + \"_ViewBinding\");//辅助类的类名 boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL); return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);&#125; 上面说到BindingSet对辅助类的生成起到非常重要的作用，这里生成了辅助类的类名，并保存在bindingSet.builder中，最后put入了builderMap中。在解析的过程中，BindingSet的都伴随左右，可以看出她在ButterKnifeProcessor类中的重要性。到这里我们在回溯一下。 1.BindingSet.newBuilder(enclosingElement) 生成类名及相关类型定义 -&gt; 2.BuilderMap.put(enclosingElement, builder) put入Map中 -&gt;3.builderMap.get(enclosingElement)获取BindingSet.builder -&gt; 4.builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required))往Builder中添加注解值 -&gt;Map转换成Map -&gt; 遍历BindingMap -&gt; bindingSet.brewJava(sdk, debuggable).write(filter)生成辅助类。 到这里，Butterknife框架生成辅助类，就讲解的差不多了。其中核心原理就是利用BindingSet类强大的类构建能力，生成相关类名，方法和核心代码。对于BindingSet具体是怎么生成辅助类的，想深入了解的朋友也可以下载ButterKnife源码对BindingSet进行深度了解，这里主要介绍ButterKnife框架原理。 三、总结通过了解Butterknife框架，知其思想真是值得称赞。注解绑定一下，就告别重复的findViewById等方法，节约了开发时间，提高了效率。 四、相关及参考文档Butterknife官方指引 ButterKnife源码剖析 Annontation注解的应用及介绍 Android编译时注解APT实战（AbstractProcessor）","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"开源框架源码解析","slug":"开源框架源码解析","permalink":"http://awenzeng.me/tags/开源框架源码解析/"},{"name":"Butterknife框架源码解析","slug":"Butterknife框架源码解析","permalink":"http://awenzeng.me/tags/Butterknife框架源码解析/"}]},{"title":"LeakCanary框架源码解析","date":"2017-11-16T09:43:41.000Z","path":"2017/11/16/tech_leakcanary/","text":"如果我们开发的程序，出现内存泄漏，导致程序奔溃，造成用户卸载APP。这样的结果,是我们不想见到的。作为一名向上的程序员，如何避免内存泄漏，这就成为必须要解决的问题。良心企业Square,开源了LeakCanary框架，可以轻松集成，让检测内存泄漏变得十分容易。 什么是内存泄漏？内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 一、什么是LeakCanary?LeakCanary 是一个检测内存泄露的开源类库。你可以在 debug 包种轻松检测内存泄露。 LeakCanary源码地址：https://github.com/square/leakcanary 二、LeakCanary源码解析1.LeakCanary入口 12345678public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this);//1.核心方法 &#125;&#125; 进入LeakCanary类1234567891011121314/** * Creates a &#123;@link RefWatcher&#125; that works out of the box, and starts watching activity * references (on ICS+). */public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125;/** Builder to create a customized &#123;@link RefWatcher&#125; with appropriate Android defaults. */public static AndroidRefWatcherBuilder refWatcher(Context context) &#123; return new AndroidRefWatcherBuilder(context);&#125; refWatcher()返回AndroidRefWatcherBuilder对象，listenerServiceClass、excludedRefs和buildAndInstall皆为AndroidRefWatcherBuilder的方法。这里我们先看AndroidRefWatcherBuilder中的buildAndInstall的方法 1234567891011/** * Creates a &#123;@link RefWatcher&#125; instance and starts watching activity references (on ICS+). */public RefWatcher buildAndInstall() &#123; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; LeakCanary.enableDisplayLeakActivity(context); ActivityRefWatcher.install((Application) context, refWatcher);//2.核心方法 &#125; return refWatcher;&#125; 这里创建了RefWatcher，并把其传给了ActivityRefWatcher。进入ActivityRefWatcher类123456789101112public static void install(Application application, RefWatcher refWatcher) &#123; new ActivityRefWatcher(application, refWatcher).watchActivities();&#125;/** * Constructs an &#123;@link ActivityRefWatcher&#125; that will make sure the activities are not leaking * after they have been destroyed. */public ActivityRefWatcher(Application application, RefWatcher refWatcher) &#123; this.application = checkNotNull(application, \"application\"); this.refWatcher = checkNotNull(refWatcher, \"refWatcher\");&#125; 创建ActivityRefWatcher类的对象，并且调用了watchActivities()方法，我们继续看12345678910111213141516171819202122232425262728293031private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new Application.ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity);//3.核心方法 &#125; &#125;; public void watchActivities() &#123; // Make sure you don't get installed twice. stopWatchingActivities(); application.registerActivityLifecycleCallbacks(lifecycleCallbacks);//4.核心方法，设置监听所有Activity的生命周期 &#125; application.registerActivityLifecycleCallbacks(lifecycleCallbacks)，设置监听了应用Activity的生命周期，可以监听所有Activity。当Activity调onDestory方法时，都会调 ActivityRefWatcher.this.onActivityDestroyed(activity)，我们继续看123void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity);//5.核心方法&#125; 2.核心类RefWatcher123456789101112131415161718192021222324252627282930/** * Identical to &#123;@link #watch(Object, String)&#125; with an empty string reference name. * * @see #watch(Object, String) */public void watch(Object watchedReference) &#123; watch(watchedReference, \"\");&#125;/** * Watches the provided references and checks if it can be GCed. This method is non blocking, * the check is done on the &#123;@link WatchExecutor&#125; this &#123;@link RefWatcher&#125; has been constructed * with. * * @param referenceName An logical identifier for the watched object. */public void watch(Object watchedReference, String referenceName) &#123; if (this == DISABLED) &#123; return; &#125; checkNotNull(watchedReference, \"watchedReference\"); checkNotNull(referenceName, \"referenceName\"); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue);//6.核心方法 ensureGoneAsync(watchStartNanoTime, reference);//7.核心方法&#125; 这里对watchedReference即Activity对象建立了一个弱应用KeyedWeakReference，并且对KeyedWeakReference加了一个引用队列queue（ReferenceQueue）。当KeyedWeakReference对象可以回收时，会添加到ReferenceQueue中，我们继续1234567private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime);//8.核心方法 &#125; &#125;);&#125; 通过watchExecutor开启了一个线程，执行ensureGone。ensureGone方法可以说是LeakCanary框架最最核心的方法，核心原理都在这里。123456789101112131415161718192021222324252627282930313233343536373839404142434445@SuppressWarnings(\"ReferenceEquality\") // Explicitly checking for named null. Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); removeWeaklyReachableReferences();//i.回收弱引用和删除key if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; if (gone(reference)) &#123;//ii.判断弱引用是否回收，若回收true,不存在泄漏 return DONE; &#125; gcTrigger.runGc();//iii.手动GC removeWeaklyReachableReferences();//iv.再次回收弱引用和删除key if (!gone(reference)) &#123;//v.再判断弱引用是否回收，若回收true,不存在泄漏，false则存在泄漏 long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); heapdumpListener.analyze(//vi.分析Hprof文件,找出泄漏的最短 new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return DONE; &#125; private boolean gone(KeyedWeakReference reference) &#123; return !retainedKeys.contains(reference.key); &#125; private void removeWeaklyReachableReferences() &#123; // WeakReferences are enqueued as soon as the object to which they point to becomes weakly // reachable. This is before finalization or garbage collection has actually happened. KeyedWeakReference ref; while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123; retainedKeys.remove(ref.key); &#125; &#125; 其中，方法removeWeaklyReachableReferences()是回收弱引用及删除key，方法gone(reference)判断弱引用对象是否被回收。 如代码中的注释，通过多次判断Activity的弱应用是否被回收，判断Activity是否内存泄漏。如泄漏，生成Hprof文件，通过Square的haha开源库分析泄漏引用链，从而将其应用链传给界面展示出来，让开发者知道。 到此，LeakCanary原理分析就告一段落了。如果你还想知道LeakCanary是怎么找到泄漏引用链，并传给界面展示的，你还可以继续分析 heapdumpListener.analyze();入口地方AndroidRefWatcherBuilder中的listenerServiceClass的方法与DisplayLeakService类。 三、总结通过阅读LeakCanary框架的源码，知LeakCanary框架原理还是比较简单的，主要就是通过Activity弱引用(KeyedWeakReference)是否被回收，来判断是否内存是否泄漏。 四、相关及参考文档LeakCanary 中文使用说明 LeakCanary核心原理源码浅析 LeakCanary 原理浅析 leakcanary原理分析与AppsFly内存泄漏 十分钟理解Java中的弱引用","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"开源框架源码解析","slug":"开源框架源码解析","permalink":"http://awenzeng.me/tags/开源框架源码解析/"},{"name":"LeakCanary框架源码分析","slug":"LeakCanary框架源码分析","permalink":"http://awenzeng.me/tags/LeakCanary框架源码分析/"}]},{"title":"Android Fragment使用小结及介绍","date":"2017-11-10T07:36:58.000Z","path":"2017/11/10/tech_fragment/","text":"偶记得第一次接触Fragment，觉得好牛叉的组件，可以做许多Activity可以做的事，辅助Activity让功能可以做得更加强大;一次编写，可以多个地方可以使用，解放了Activity。在这里，本篇文章主要是总结fragment的两种添加方式，add和replace。 一、什么是Fragment简单来说，Fragment其实可以理解为一个具有自己生命周期的控件，只不过这个控件又有点特殊，它有自己的处理输入事件的能力，有自己的生命周期，又必须依赖于Activity，能互相通信和托管。 使用Fragment还有这么几个方面优势： 代码复用。特别适用于模块化的开发，因为一个Fragment可以被多个Activity嵌套，有个共同的业务模块就可以复用了，是模块化UI的良好组件。 Activity用来管理Fragment。Fragment的生命周期是寄托到Activity中，Fragment可以被Attach添加和Detach释放。 可控性。Fragment可以像普通对象那样自由的创建和控制，传递参数更加容易和方便，也不用处理系统相关的事情，显示方式、替换、不管是整体还是部分，都可以做到相应的更改。 Fragments是view controllers，它们包含可测试的，解耦的业务逻辑块，由于Fragments是构建在views之上的，而views很容易实现动画效果，因此Fragments在屏幕切换时具有更好的控制。 二、Fragment的生命周期Fragment的生命周期类似Activity,如下图，Activity生命周期与Fragment生命周期对比图： 三、Fragment的两种添加方式(add&amp;replace)Fragment添加与FragmentManager与FragmentTransaction息息相关。add和replace都是FragmentTransaction的方法。除这两个方法，其中还有remove,hide和show方法。 FragmentManager与FragmentTransaction的获取：12FragmentManager frgmentManager = getFragmentManager() // v4中，getSupportFragmentManagerFragmentTransaction transaction = frgmentManager.benginTransatcion(); 1.项目中多个Fragment，add方式添加 i.添加代码123456789101112131415161718192021222324252627282930313233343536public void add(BaseLibFragment fragment, int id,String tag)&#123; FragmentManager fragmentManager = ((BaseLibActivity)mContext).getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //优先检查，fragment是否存在，避免重叠 BaseLibFragment tempFragment = (BaseLibFragment)fragmentManager.findFragmentByTag(tag); if(EmptyUtils.isNotEmpty(tempFragment))&#123; fragment = tempFragment; &#125; if(fragment.isAdded())&#123; addOrShowFragment(fragmentTransaction,fragment,id,tag); &#125;else&#123; if(currentFragment!=null&amp;&amp;currentFragment.isAdded())&#123; fragmentTransaction.hide(currentFragment).add(id, fragment,tag).commit(); &#125;else&#123; fragmentTransaction.add(id, fragment,tag).commit(); &#125; currentFragment = fragment; &#125;&#125;/** * 添加或者显示 fragment * * @param fragment */private void addOrShowFragment(FragmentTransaction transaction, BaseLibFragment fragment, int id,String tag) &#123; if(currentFragment == fragment) return; if (!fragment.isAdded()) &#123; // 如果当前fragment未被添加，则添加到Fragment管理器中 transaction.hide(currentFragment).add(id, fragment,tag).commit(); &#125; else &#123; transaction.hide(currentFragment).show(fragment).commit(); &#125; currentFragment.setUserVisibleHint(false); currentFragment = fragment; currentFragment.setUserVisibleHint(true);&#125; ii.添加顺序 第一次添加，先hide(隐藏)currentFragment，再add(添加)新Fragment。生命周期会按正常流程走，onCreate-&gt;onResume 第二次添加，先hide(隐藏)currentFragment，在show(显示)老Fragment。生命周期不会重新走，会调用onHiddenChanged()，展示fragment的显示状态，我们可以在此做一些刷新数据操作。 iii.add方式Fragment重叠BUG解决方案为fragment设置Tag，通过findFragmentByTag查找是否存在，然后再添加12345//优先检查，fragment是否存在，避免重叠 BaseLibFragment tempFragment = (BaseLibFragment)fragmentManager.findFragmentByTag(tag); if(EmptyUtils.isNotEmpty(tempFragment))&#123; fragment = tempFragment; &#125; 2.项目中多个Fragment，replace方式添加i.添加代码123456public void replace(BaseLibFragment fragment, int id)&#123; FragmentManager fragmentManager = ((BaseLibActivity)mContext).getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(id, fragment); fragmentTransaction.commit();&#125; ii.添加方式添加方式比较直接，直接替换。在这过程中因为是替换，第一和第二次添加没啥区别，生命周期都要重新执行一次 四、两种添加方式性能比较标准的四大金刚模式。底部四个Item，通过Fragment内容切换，此种方式add与replace性能对比，如下两图： add方式 replace方式 由以上两图知：replace方式内存波动比较大，网络请求消耗大；add方式则反之。","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://awenzeng.me/tags/Fragment/"}]},{"title":"Android悬浮窗原理解析","date":"2017-10-17T03:35:14.000Z","path":"2017/10/17/tech_android_framework_window/","text":"悬浮窗，在大多数应用中还是很少见的，目前我们接触到的悬浮窗，差不多都是一些系统级的应用软件，例如：360安全卫士，腾讯手机管家等；在某些服务行业如金融，餐饮等，也会在应用中添加悬浮窗，例如：美团的偷红包，博闻金融快捷联系等。但两种悬浮窗还是有区别的： 系统悬浮窗：所有界面都会展示，包括主屏、锁屏 应用悬浮窗：只在应用Activity中展示。 一、窗口Window在了解悬浮窗之前，首先我们需要认识一下Android窗口Window。Android Framework将窗口分为三个类型： 应用窗口：所谓应用窗口指的就是该窗口对应一个Activity，因此，要创建应用窗口就必须在Activity中完成了。 子窗口：所谓子窗口指的是必须依附在某个父窗口之上，比如PopWindow，Dialog。 系统窗口：所谓系统窗口指的是由系统进程创建，不依赖于任何应用或者不依附在任何父窗口之上，如：Toast,来电窗口等。 Framework定义了三种窗口类型，这三种类型定义在WindowManager的内部类LayoutParams中，WindowManager将这三种类型 进行了细化，把每一种类型都用一个int常量来表示，这些常量代表窗口所在的层，WindowManagerService在进行窗口叠加的时候，会按照常量的大小分配不同的层，常量值越大，代表位置越靠上面，所以我们可以猜想一下，应用程序Window的层值常量要小于子Window的层值常量，子Window的层值常量要小于系统Window的层值常量。Window的层级关系如下所示。 应用窗口：层级范围是1~99 子窗口：层级范围是1000~1999 系统窗口：层级范围是2000~2999 1.各级别type值在WindowManager中的定义分别为： i.应用窗口（1~99） 12345678910//第一个应用窗口public static final int FIRST_APPLICATION_WINDOW = 1;//所有程序窗口的base窗口，其他应用程序窗口都显示在它上面public static final int TYPE_BASE_APPLICATION = 1;//所有Activity的窗口，只能配合Activity在当前APP使用public static final int TYPE_APPLICATION = 2;//目标应用窗口未启动之前的那个窗口public static final int TYPE_APPLICATION_STARTING = 3;//最后一个应用窗口public static final int LAST_APPLICATION_WINDOW = 99; ii.子窗口（1000~1999） 1234567891011121314 //第一个子窗口 public static final int FIRST_SUB_WINDOW = 1000; // 面板窗口，显示于宿主窗口的上层,只能配合Activity在当前APP使用 public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; // 媒体窗口（例如视频），显示于宿主窗口下层 public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW+1; // 应用程序窗口的子面板，只能配合Activity在当前APP使用(PopupWindow默认就是这个Type) public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW+2; //对话框窗口,只能配合Activity在当前APP使用 public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW+3; // public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW+4; //最后一个子窗口public static final int LAST_SUB_WINDOW = 1999; iii.系统窗口（2000~2999） 1234567891011121314151617181920212223242526272829303132333435363738394041//系统窗口，非应用程序创建public static final int FIRST_SYSTEM_WINDOW = 2000;//状态栏，只能有一个状态栏，位于屏幕顶端，其他窗口都位于它下方public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;//搜索栏，只能有一个搜索栏，位于屏幕上方public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1; ////电话窗口，它用于电话交互（特别是呼入），置于所有应用程序之上，状态栏之下,属于悬浮窗(并且给一个Activity的话按下HOME键会出现看不到桌面上的图标异常情况)public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;////系统警告提示窗口，出现在应用程序窗口之上,属于悬浮窗, 但是会被禁止public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3;////信息窗口，用于显示Toast, 不属于悬浮窗, 但有悬浮窗的功能, 缺点是在Android2.3上无法接收点击事件public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW+5;//public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4;//锁屏窗口public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4;//系统顶层窗口，显示在其他一切内容之上，此窗口不能获得输入焦点，否则影响锁屏public static final int TYPE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+6;//电话优先，当锁屏时显示，此窗口不能获得输入焦点，否则影响锁屏public static final int TYPE_PRIORITY_PHONE = FIRST_SYSTEM_WINDOW+7;//系统对话框窗口public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;//锁屏时显示的对话框public static final int TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW+9;//系统内部错误提示，显示在任何窗口之上public static final int TYPE_SYSTEM_ERROR = FIRST_SYSTEM_WINDOW+10;//内部输入法窗口，显示于普通UI之上，应用程序可重新布局以免被此窗口覆盖public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;//内部输入法对话框，显示于当前输入法窗口之上public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;//墙纸窗口public static final int TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW+13;//状态栏的滑动面板public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;//安全系统覆盖窗口，这些窗户必须不带输入焦点，否则会干扰键盘public static final int TYPE_SECURE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+15;//最后一个系统窗口public static final int LAST_SYSTEM_WINDOW = 2999; 2.窗口flags显示属性在WindowManager中也有定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//窗口特征标记public int flags;//当该window对用户可见的时候，允许锁屏public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;//窗口后面的所有内容都变暗public static final int FLAG_DIM_BEHIND = 0x00000002;//Flag：窗口后面的所有内容都变模糊public static final int FLAG_BLUR_BEHIND = 0x00000004;//窗口不能获得焦点public static final int FLAG_NOT_FOCUSABLE = 0x00000008;//窗口不接受触摸屏事件public static final int FLAG_NOT_TOUCHABLE = 0x00000010;//即使在该window在可获得焦点情况下，允许该窗口之外的点击事件传递到当前窗口后面的的窗口去public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020;//当手机处于睡眠状态时，如果屏幕被按下，那么该window将第一个收到触摸事件public static final int FLAG_TOUCHABLE_WHEN_WAKING = 0x00000040;//当该window对用户可见时，屏幕出于常亮状态public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;//：让window占满整个手机屏幕，不留任何边界public static final int FLAG_LAYOUT_IN_SCREEN = 0x00000100;//允许窗口超出整个手机屏幕public static final int FLAG_LAYOUT_NO_LIMITS = 0x00000200;//window全屏显示public static final int FLAG_FULLSCREEN = 0x00000400;//恢复window非全屏显示public static final int FLAG_FORCE_NOT_FULLSCREEN = 0x00000800;//开启窗口抖动public static final int FLAG_DITHER = 0x00001000;//安全内容窗口，该窗口显示时不允许截屏public static final int FLAG_SECURE = 0x00002000;//锁屏时显示该窗口public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;//系统的墙纸显示在该窗口之后public static final int FLAG_SHOW_WALLPAPER = 0x00100000;//当window被显示的时候，系统将把它当做一个用户活动事件，以点亮手机屏幕public static final int FLAG_TURN_SCREEN_ON = 0x00200000;//该窗口显示，消失键盘public static final int FLAG_DISMISS_KEYGUARD = 0x00400000;//当该window在可以接受触摸屏情况下，让因在该window之外，而发送到后面的window的触摸屏可以支持split touchpublic static final int FLAG_SPLIT_TOUCH = 0x00800000;//对该window进行硬件加速，该flag必须在Activity或Dialog的Content View之前进行设置public static final int FLAG_HARDWARE_ACCELERATED = 0x01000000;//让window占满整个手机屏幕，不留任何边界public static final int FLAG_LAYOUT_IN_OVERSCAN = 0x02000000;//透明状态栏public static final int FLAG_TRANSLUCENT_STATUS = 0x04000000;//透明导航栏public static final int FLAG_TRANSLUCENT_NAVIGATION = 0x08000000; 3.添加View到Window的流程代码： 123456789101112131415161718contactView = new ContactView(mContext); if (layoutParams == null) &#123; layoutParams = new WindowManager.LayoutParams(); layoutParams.width = contactView.width; layoutParams.height = contactView.height; layoutParams.x += ScreenSizeUtil.getScreenWidth(); layoutParams.y += ScreenSizeUtil.getScreenHeight() - ScreenSizeUtil.dp2px(150); layoutParams.gravity = Gravity.TOP | Gravity.LEFT; if (Build.VERSION.SDK_INT &gt; 18 &amp;&amp; Build.VERSION.SDK_INT &lt; 23) &#123; layoutParams.type = WindowManager.LayoutParams.TYPE_TOAST;//Type设置 &#125; else &#123; layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION; &#125; layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;//Flags设置,窗口属性 layoutParams.format = PixelFormat.RGBA_8888; &#125; windowManager.addView(contactView, layoutParams);//向窗口中添加View 悬浮窗添加原理：View添加到Window源码解析 Window在Android系统中十分重要，其Activity，Dialog的创建都离不开Window.具体Activity，Dialog是怎么添加到Window上的，详情如：Activity的加载流程;Dialog加载绘制流程 二、两种悬浮窗在前言中已说到，悬浮窗在app中，分为两种：系统级别和应用级别。其中系统级别可以在任何界面展示，包括主屏、锁屏（看需要），应用级别只在应用中展示。通过上面对Window的认识，我们可以知道实现方式： 系统级别可以通过type设置为：TYPE_TOAST、TYPE_PHONE、TYPE_SYSTEM_ALERT； 应用级别可以通过type设置为：TYPE_APPLICATION、TYPE_APPLICATION_ATTACHED_DIALOG； 悬浮窗添加流程： WindowManager.addView -&gt; ViewRootImpl.setView -&gt; WindowSession.addToDisplay(AIDL进行IPC) -&gt; WindowManagerService.addWindow() -&gt; ViewRootImpl.setView 1.系统悬浮窗 对于系统级别的悬浮窗来说，不同的设置，不同的Android版本，需要权限和交互都不同。通过阅读源码android4.4知： android 7.1.1的addWindow方法为： 1234567891011121314151617181920212223242526272829303132public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; int[] appOp = new int[1]; int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; ...... final int type = attrs.type; ...... &#125; else if (type == TYPE_TOAST) &#123;//android 7.1.1 添加代码（其他版本无） // Apps targeting SDK above N MR1 cannot arbitrary add toast windows. addToastWindowRequiresToken = doesAddToastWindowRequireToken(attrs.packageName, callingUid, attachedWindow); if (addToastWindowRequiresToken &amp;&amp; token.windowType != TYPE_TOAST) &#123; Slog.w(TAG_WM, \"Attempted to add a toast window with bad token \" + attrs.token + \". Aborting.\"); return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; &#125;.... synchronized(mWindowMap) &#123; ...... mPolicy.adjustWindowParamsLw(win.mAttrs); ...... &#125; ...... return res; &#125; 权限检查checkAddPermission()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//权限检查@Overridepublic int checkAddPermission(WindowManager.LayoutParams attrs, int[] outAppOp) &#123; int type = attrs.type; outAppOp[0] = AppOpsManager.OP_NONE; if (type &lt; WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW || type &gt; WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123; return WindowManagerGlobal.ADD_OKAY; &#125; String permission = null; switch (type) &#123; case TYPE_TOAST: // XXX right now the app process has complete control over // this... should introduce a token to let the system // monitor/control what they are doing. break; case TYPE_DREAM: case TYPE_INPUT_METHOD: case TYPE_WALLPAPER: case TYPE_PRIVATE_PRESENTATION: // The window manager will check these. break; case TYPE_PHONE: case TYPE_PRIORITY_PHONE: case TYPE_SYSTEM_ALERT: case TYPE_SYSTEM_ERROR: case TYPE_SYSTEM_OVERLAY: permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW; outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW; break; default: permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW; &#125; if (permission != null) &#123; if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) &#123; return WindowManagerGlobal.ADD_PERMISSION_DENIED; &#125; &#125; return WindowManagerGlobal.ADD_OKAY;&#125; window的flags属性添加adjustWindowParamsLw()方法 123456789101112131415161718192021222324252627282930313233343536373839404142//window的flags属性添加//Android 2.0 - 2.3.7 PhoneWindowManager public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) &#123; switch (attrs.type) &#123; case TYPE_SYSTEM_OVERLAY: case TYPE_SECURE_SYSTEM_OVERLAY: case TYPE_TOAST: // These types of windows can't receive input events. attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; break; &#125; &#125; //Android 4.0.1 - 4.3.1 PhoneWindowManager public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) &#123; switch (attrs.type) &#123; case TYPE_SYSTEM_OVERLAY: case TYPE_SECURE_SYSTEM_OVERLAY: case TYPE_TOAST: // These types of windows can't receive input events. attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; attrs.flags &amp;= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH; break; &#125; &#125; //Android 4.4 PhoneWindowManager @Override public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) &#123; switch (attrs.type) &#123; case TYPE_SYSTEM_OVERLAY: case TYPE_SECURE_SYSTEM_OVERLAY: // These types of windows can't receive input events. attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; attrs.flags &amp;= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH; break; &#125; &#125; 由上可知： Type为TYPE_TOAST：版本低于android4.4的，不能接受触摸事件，无法操作；版本高于Android 7.1.1的无法添加悬浮窗 Type为TYPE_PHONE：所有android版本都需要权限，版本低于android6.0的manifest中添加权限android.Manifest.permission.SYSTEM_ALERT_WINDOW即可，高于andorid6.0的需要判断权限且手动添加。 Type为TYPE_SYSTEM_ALERT：同TYPE_PHONE 所以系统级别的悬浮窗，android不同版本需要特别处理。 2.应用悬浮窗 对于应用悬浮窗来说，android版本对其影响不大。 Type为TYPE_APPLICATION：只要Activity建立了，就可以添加。 Type为TYPE_APPLICATION_ATTACHED_DIALOG：需要在Activity获取焦点，并且用户可操作时才可添加。 三、悬浮窗的实现悬浮窗添加比较简单,主要是由WindowManager接口的实现类WindowManagerImpl进行操作，WindowManager接口又继承至ViewManager,其中主要方法为： 123public void addView(View view, ViewGroup.LayoutParams params);//添加View到Windowpublic void updateViewLayout(View view, ViewGroup.LayoutParams params);//更新View在Window中的位置public void removeView(View view);//删除View 主要实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209public class ContactWindowUtil &#123; private ContactView contactView; private View dialogView; private WindowManager windowManager; private WindowManager.LayoutParams layoutParams; private WindowManager.LayoutParams dialogParams; private Context mContext; private ContactWindowListener mListener; private ValueAnimator valueAnimator; private int direction; private final int LEFT = 0; private final int RIGHT = 1; public interface ContactWindowListener &#123; void onDataCallBack(String str); &#125; public void setDialogListener(ContactWindowListener listener) &#123; mListener = listener; &#125; //私有化构造函数 public ContactWindowUtil(Context context) &#123; mContext = context; windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);// windowManager = (WindowManager) FloatWindowApp.getAppContext().getSystemService(Context.WINDOW_SERVICE); &#125; public void showContactView() &#123; hideContactView(); contactView = new ContactView(mContext); if (layoutParams == null) &#123; layoutParams = new WindowManager.LayoutParams(); layoutParams.width = contactView.width; layoutParams.height = contactView.height; layoutParams.x += ScreenSizeUtil.getScreenWidth(); layoutParams.y += ScreenSizeUtil.getScreenHeight() - ScreenSizeUtil.dp2px(150); layoutParams.gravity = Gravity.TOP | Gravity.LEFT; if (Build.VERSION.SDK_INT &gt; 18 &amp;&amp; Build.VERSION.SDK_INT &lt; 23) &#123; layoutParams.type = WindowManager.LayoutParams.TYPE_TOAST; &#125; else &#123; layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION; &#125; layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; layoutParams.format = PixelFormat.RGBA_8888; &#125; contactView.setOnTouchListener(touchListener); contactView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showContactDialog(); &#125; &#125;); windowManager.addView(contactView, layoutParams); &#125; /** * 显示联系弹框 */ private void showContactDialog() &#123; hideDialogView(); if (dialogParams == null) &#123; dialogParams = new WindowManager.LayoutParams(); dialogParams.width = WindowManager.LayoutParams.MATCH_PARENT; dialogParams.height = WindowManager.LayoutParams.MATCH_PARENT; dialogParams.gravity = Gravity.CENTER; if (Build.VERSION.SDK_INT &gt; 18 &amp;&amp; Build.VERSION.SDK_INT &lt; 25)&#123; dialogParams.type = WindowManager.LayoutParams.TYPE_TOAST; &#125; else &#123; dialogParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG; &#125; dialogParams.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_FULLSCREEN; dialogParams.format = PixelFormat.RGBA_8888; &#125; LayoutInflater layoutInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); dialogView = layoutInflater.inflate(R.layout.window_contact, null); TextView okTv = dialogView.findViewById(R.id.mOkTv); TextView cancleTv = dialogView.findViewById(R.id.mCancleTv); final TextView contentTv = dialogView.findViewById(R.id.mContentTv); contentTv.setText(String.format(\"您确认拨打%s客服电话吗\", \"4008-111-222\")); cancleTv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; hideDialogView(); &#125; &#125;); okTv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; hideDialogView(); mListener.onDataCallBack(\"\"); &#125; &#125;); dialogView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; hideDialogView(); &#125; &#125;); windowManager.addView(dialogView, dialogParams); &#125; public void hideAllView() &#123; hideContactView(); hideDialogView(); &#125; public void hideContactView() &#123; if (contactView != null) &#123; windowManager.removeView(contactView); contactView = null; stopAnim(); &#125; &#125; public void hideDialogView() &#123; if (dialogView != null) &#123; windowManager.removeView(dialogView); dialogView = null; &#125; &#125; View.OnTouchListener touchListener = new View.OnTouchListener() &#123; float startX; float startY; float moveX; float moveY; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: startX = event.getRawX(); startY = event.getRawY(); moveX = event.getRawX(); moveY = event.getRawY(); break; case MotionEvent.ACTION_MOVE: float x = event.getRawX() - moveX; float y = event.getRawY() - moveY; //计算偏移量，刷新视图 layoutParams.x += x; layoutParams.y += y; windowManager.updateViewLayout(contactView, layoutParams); moveX = event.getRawX(); moveY = event.getRawY(); break; case MotionEvent.ACTION_UP: //判断松手时View的横坐标是靠近屏幕哪一侧，将View移动到依靠屏幕 float endX = event.getRawX(); float endY = event.getRawY(); if (endX &lt; ScreenSizeUtil.getScreenWidth() / 2) &#123; direction = LEFT; endX = 0; &#125; else &#123; direction = RIGHT; endX = ScreenSizeUtil.getScreenWidth() - contactView.width; &#125; if(moveX != startX)&#123; starAnim((int) moveX, (int) endX,direction); &#125; //如果初始落点与松手落点的坐标差值超过5个像素，则拦截该点击事件 //否则继续传递，将事件交给OnClickListener函数处理 if (Math.abs(startX - moveX) &gt; 5) &#123; return true; &#125; break; &#125; return false; &#125; &#125;; private void starAnim(int startX, int endX,final int direction) &#123; if (valueAnimator != null) &#123; valueAnimator.cancel(); valueAnimator = null; &#125; valueAnimator = ValueAnimator.ofInt(startX, endX); valueAnimator.setDuration(500); valueAnimator.setRepeatCount(0); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; if(direction == LEFT)&#123; layoutParams.x = (int) animation.getAnimatedValue()-contactView.width/2; &#125;else&#123; layoutParams.x = (int) animation.getAnimatedValue(); &#125; if (contactView != null) &#123; windowManager.updateViewLayout(contactView, layoutParams); &#125; &#125; &#125;); valueAnimator.setInterpolator(new LinearInterpolator()); valueAnimator.start(); &#125; private void stopAnim() &#123; if (valueAnimator != null) &#123; valueAnimator.cancel(); valueAnimator = null; &#125; &#125;&#125; 悬浮窗源码:https://github.com/awenzeng/FloatWindowDemo 四、注意1.应用悬浮窗WindowManager的获取环境必须是Activity环境，系统悬浮窗可以Activity环境，也可以是全局的环境。如： 12 windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);// windowManager = (WindowManager) FloatWindowApp.getAppContext().getSystemService(Context.WINDOW_SERVICE); 2.应用级别悬浮窗也可以通过系统级别的方式实现，主要控制一下显示与隐藏就好。但如果只在应用中展示悬浮窗，建议使用应用级别，那样会省去许多不必要的麻烦。 3.系统级别Type为TYPE_PHONE、TYPE_SYSTEM_ALERT是权限判断及设置代码： 12345678910111213/** * 请求用户给予悬浮窗的权限 */ public void askForPermission() &#123; if (!Settings.canDrawOverlays(this)) &#123; Toast.makeText(TestFloatWinActivity.this, \"当前无权限，请授权！\", Toast.LENGTH_SHORT).show(); Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:\" + getPackageName())); startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE); &#125; else &#123; startService(floatWinIntent); &#125; &#125; 五、参考文献Android源码解析Window系列第（一）篇—Window的基本认识和Activity的加载流程 Android 悬浮窗的小结 Android悬浮窗TYPE_TOAST小结: 源码分析 Android无需权限显示悬浮窗, 兼谈逆向分析app Android 悬浮窗权限各机型各系统适配大全","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"悬浮窗","slug":"悬浮窗","permalink":"http://awenzeng.me/tags/悬浮窗/"},{"name":"WindowManager","slug":"WindowManager","permalink":"http://awenzeng.me/tags/WindowManager/"}]},{"title":"你本是一个肉体，是什么驱使你前行[4]","date":"2017-10-16T08:09:50.000Z","path":"2017/10/16/think_body_and_soul_4/","text":"文/丹尼尔 生活最大的危险，就是空虚的心灵。 罗曼 • 罗兰说：「生活最沉重的负担不是工作，而是无聊。」每个人要对自己的生活负责。一个人至少拥有一个梦想，才能让自己有动力和激情去坚持。生活的理想，就是为了理想的生活。追求不同的生活方式，是对人生做加法。追求更好的生活品质，则是对人生做减法。 不知道你是在做人生加法，还是人生减法？年轻的时候，绝大部分人会有很多想法，什么都想要，什么都想尝试。人到中年时，才会发现人的精力极其有限，一生中只要做好一两件事情，并且做漂亮了，就足以。当一个人抵达生活的极限后，就会删繁就简，让生命变得更加纯粹，更有效率地追求人生中最让自己感到愉悦的事。 好的生活，不是贵价格，而是贵品质；不是贵物质，而是贵精神。生活不是越复杂越好，而是越简约越好。化繁为简，便是一种高品质的生活方式。最完美的生活品质，往往讲究一个人长期健康稳定的发展，至少是以下三位一体的生活方式：拥有思想的读书生活，开阔见识的旅行生活，健康身体的运动生活。 读书的生活方式俗话说：一日不读书，无人看得出；一周不读书，开始会爆粗；一月不读书，智商输给猪。读书能使人心明眼亮。这就意味着不读书的人如同瞎子。正如《圣经》所言，「眼睛就是身上的灯。眼睛若明亮，全身就光明；眼睛若昏花，全身就黑暗。」你的思想，就是你这个人的眼睛。没有知识的获取和积累，思想和精神就是空洞的。不读书的人，思想会停止。 读书的目的不是为了反驳别人，而是为了丰富自己。读书能获得工作技能，提高个人素质，培养思想深度，和满足精神需求等。读书是在别人思想的引导下，建立自己的思想。读书不要贪多，而在于精读，并且在读的时候学会思考。独立性，才是一个人读书所带来最重要的品质。一个人一旦缺乏思考力，就不会有判断力，也就更不会有鉴别力。 在纸醉金迷的好莱坞，失去鉴别力的人，很容易迷失在烟酒和药物等等的花花世界里。性感女神梦露，却有着另一份与她外表完全不符的生活：读书。梦露这一生读了很多书，她的书单足以秒杀某些现代文学博士。阅读，成了她学习的最好方式。在闪光灯前，她媚得不可一世，但在真正的独处时，是读书让她的美丽安静地绽放。 当你通过读书，思想有了深度和高度，看问题的角度也就不同，所追求的境界自然也会不同。本杰明·富兰克林说，「向知识投资付出的利息最少。」而我则说，向知识投资是回报率最高的无形资产。越读书越有气质，越读书越有内涵，越读书越有智慧，越读书越有品位。这些看不见的修养和品位，都会悄无声息地融在你的生活中。 你的思想有多高度，你的生活品位相应地就有多好。 旅行的生活方式如果人生是一场旅行的话，那么旅行便是另一种方式的读书。奥古斯狄尼斯说，「世界是一本书，而不旅行的人们只读了其中的一页。」旅行的意义是什么？有人说，它能增加你人生的视野。有人说，它能增加你人生的维度。这些都没错。旅行的真正意义，不是看见新的风景，而是用新的眼光看待自己。旅行是唯一花了钱，却让你内心变得更富有的事物。 很多人说，身边的世界很小，都早已厌倦。外面的世界很大，应该出去看看。如果逃离旧的环境却没有改变旧的心境，那么所谓的新自由也只不过是一种假自由。装装样子，自欺欺人。旅行并不是为了让你逃避现实，而是让你更好的认识自己和这个世界。旅行总让人谦卑，因为你会看到人的渺小，世界的伟大。旅行最大的魅力，在于不断地探索未知的世界。 在伟大的摄影师布列松的作品中，总会发现他在不同国家，不同城市的街头走走停停，来记录所看到的一切。这种不疾不徐，波澜不惊的生活状态，就像人生一样。自出生那一刻起，我们每个人便开始了慢慢的人生旅程。人生是一段旅程，在旅行中遇到的每一个人，每一个景色，都有可能成为一生中难忘的风景。人生的丰富多彩，也体现在不同的旅行中。 旅行也是热爱生活的一种特别表现。从不出门的人，内心必定是满腹偏见。旅行的真谛，不是运动，而是带着你的灵魂，去寻找生命的真光。当你看过的世界越少，你的眼界也会越狭小。当你看过的世界越多，你的眼界就会越宽广。一个经常旅行的人，一定有博学多才的知识，坚持不懈的性格，善解人意的心态，和独具慧眼的审美。 你的见识有多宽广，你的审美品位相应地就有多美。 运动的生活方式现今的社会，物质生活日益丰富，工作压力日益增大，交际应酬日益频繁，然而身体却日渐虚弱。正如很多人都曾听说的：三十五岁以前拿身体换钱，三十五岁以后拿钱换身体。理想生活离不开健康，而保持健康的最好方式就是运动。一个健康的身体，才能享受生命带来的种种美好，才能把这种美好延续得更长。这才是最重要的生活品质。 如今，越来越多的中国人开始追求健康的生活方式，一些人选择在户外跑步、骑车、在草地上晒太阳，还有一些人会去健身房锻炼，游泳馆游泳等等。你可能会觉得他们很会享受生活，很悠闲。也许运动占据了他们相当一部分工资和时间，但健康的身体是持续赚钱的条件和能力。「运动」不再是高中时期应付要做的广播体操，而是每日清晨带上耳机对身体的放空。 对于跑者而言，跑步旅行或许是一个很不错的选择。这就是为什么丹先生选择马拉松，而且只对海外赛事感兴趣，尤其世界马拉松六大满贯：芝加哥、纽约、柏林、东京、伦敦、波士顿。每次参赛，可以一边跑步，一边欣赏美景。赛后，还可以计划自己的个人旅行。既可以锻炼身体，同时又可以旅行，路上还可以看看书，这便是一举三得的生活方式。 当你爱上运动之后，你可能会不再腰酸背痛，还省了很多去医院的钱；你可能会慢慢戒掉了手机癌，认识了各行各业的新朋友；你可能会无法和同龄人一起变老，因为运动可以延缓衰老；你可能会对生活越来越有追求了，也提高了对生活品质的要求。 你的身体有多健康，你的生活品质相应地就有多高。 在所有的生活方式中，运动健身是最时尚健康的生活方式。而你会发现，一个有生活品质的人绝对会科学运动，智能手表、专业的运动服饰缺一不可，而对服装搭配有极强要求的人，也会对智能手表的外观有着更高要求，这也是 Nokia Steel 智能腕表被大家喜爱的原因。它除了带有运动及睡眠监测功能，还是一款适合各种场合佩戴的时尚手表，运动时尚两不误，是追求品质生活人士的绝佳首选。 生活得有品位的人，并不是那些年岁活得最长的人，而是真正热爱生活的人。如果你爱生活，那么生活就会爱你。一个集才华与美貌于一身，有高度的思想，有眼界的见识，并且热爱健康生活的人，才是最高品位的生活方式。 你的思维模式，决定了你的生活方式。而你的生活方式，决定了你的生活品质。","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"你本是一个肉体，是什么驱使你前行","slug":"你本是一个肉体，是什么驱使你前行","permalink":"http://awenzeng.me/tags/你本是一个肉体，是什么驱使你前行/"}]},{"title":"Java集合类详解","date":"2017-09-22T09:05:45.000Z","path":"2017/09/22/tech_java_collections/","text":"一、集合与数组数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。 集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。 二、层次关系图1：实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口 图2： Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。 三、几种重要的接口和类简介1、List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 2、Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 3、Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 对比如下： 四、遍历 在类集中提供了以下四种的常见输出方式： 1）Iterator：迭代输出，是使用最多的输出方式。2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。4）for循环 代码示例如下： for的形式： 1for（int i=0;i&lt;arr.size();i++)&#123;&#125; foreach的形式： 1for(int i：arr)&#123;&#125; iterator的形式： 12345Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); &#125; 五、Collection集合Collection是集合接口 |————Set子接口:无序，不允许重复。 |————List子接口:有序，可以有重复元素。 区别：Collections是集合类 Set和List对比： Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 Set和List具体子类： Set |————HashSet：以哈希表的形式存放元素，插入删除速度很快。 List |————ArrayList：动态数组 |————LinkedList：链表、队列、堆栈。 Array和java.util.Vector Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。 六、Map集合1.实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMap HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的 Hashtable Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap 线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMap LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMap TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的； 2.map的遍历 第一种：KeySet() 将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下： 123456789101112Map map = new HashMap();map.put(\"key1\",\"lisi1\");map.put(\"key2\",\"lisi2\");map.put(\"key3\",\"lisi3\");map.put(\"key4\",\"lisi4\"); //先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext())&#123;Object key = it.next();System.out.println(map.get(key));&#125; 第二种：entrySet（）12345678910111213Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下：Map map = new HashMap();map.put(\"key1\",\"lisi1\");map.put(\"key2\",\"lisi2\");map.put(\"key3\",\"lisi3\");map.put(\"key4\",\"lisi4\");//将map集合中的映射关系取出，存入到set集合Iterator it = map.entrySet().iterator();while(it.hasNext())&#123;Entry e =(Entry) it.next();System.out.println(\"键\"+e.getKey () + \"的值为\" + e.getValue());&#125; 推荐使用第二种方式，即entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。 七、主要实现类区别小结Vector和ArrayList 1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。 ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 arraylist和linkedlist 1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap 1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 HashTable与HashMap 1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。 2、HashMap允许存在一个为null的key，多个为null的value 。 3、hashtable的key和value都不允许为null。 八、参考文献JAVA集合类汇总 Java集合类详解 哈希表（散列表）原理详解","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Java集合类","slug":"Java集合类","permalink":"http://awenzeng.me/tags/Java集合类/"},{"name":"转载","slug":"转载","permalink":"http://awenzeng.me/tags/转载/"}]},{"title":"HTTP文件断点续传原理解析","date":"2017-09-08T11:59:12.000Z","path":"2017/09/08/tech_http_breakpoint/","text":"生活中，有许多事物，在没有被揭开面纱之前，我们往往会觉得很神秘很高深，认为它一定很难，进而望而却步，失去了解它的机会。然而，很多事，只要我们自己能沉下心来，细细研究，那些神秘高深的，也会变得简单明了。”HTTP文件断点续传”就是这样一个好例子，深入了解背后之理，“HTTP文件断点续传原理”其实很简单。 一、什么是断点续传1.定义： 可以从下载或上传断开点继续开始传输，就叫断点续传。 2.核心实现原理： i.RandomAccessFile(文件任意位置保存)方法seek():可以移动到保存文件任意位置，在该位置发生下一个读取或写入操作 ii.HttpURLConnection.setRequestProperty()(任意位置请求返回剩余文件)HttpURLConnection.setRequestProperty(“Range”, “bytes=” + start + “-“ + end) 二、实例分析 流程图 实现步骤 1.建立数据库：保存文件下载信息 2.下载服务类(DownloadService) 3.两个线程：文件信息线程(FileInfoThread)和文件下载线程(DownloadThread) 4.广播(BroadcastReceiver)：UI进度更新 1.建立数据库按常规数据库建立方法，具体(略)。数据保存信息为：12345678910/** * 下载信息类 */public class DownloadInfo &#123; private int id; private String url;//下载链接 private long start;//开始大小 private long end;//最终大小 private long progress;//下载进度&#125; 2.下载服务类利用service多次启动只调用onStartCommand()方法，处理开始或暂停下载逻辑。 12345678910111213public int onStartCommand(Intent intent, int flags, int startId) &#123; if (intent.getAction().equals(ACTION_START)) &#123; FileInfo fileInfo = (FileInfo) intent.getSerializableExtra(TAG_FILEINFO); mFileInfoThread = new FileInfoThread(fileInfo,mHandler); mFileInfoThread.start(); &#125; else if (intent.getAction().equals(ACTION_PAUSE)) &#123; if (mDownloadThread != null) &#123; mDownloadThread.setPause(true); &#125; &#125; return super.onStartCommand(intent, flags, startId);&#125; 3.两个线程i.文件信息线程(FileInfoThread) 通过网络获取下载文件大小，并建立对应大小的保存文件路径。1234567891011121314151617181920212223242526272829303132333435363738394041HttpURLConnection conn = null; RandomAccessFile raf = null; try &#123; URL url = new URL(mFileInfo.getUrl()); conn = (HttpURLConnection) url.openConnection();//连接网络文件 conn.setConnectTimeout(3000); conn.setRequestMethod(\"GET\"); int length = -1; Log.e(TAG,\"HttpResponseCode==\"+ conn.getResponseCode() + \"\"); if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; //获取文件长度 length = conn.getContentLength(); &#125; if (length &lt; 0) &#123; return; &#125; File dir = new File(DownloadService.DOWNLOAD_PATH); if (!dir.exists()) &#123; dir.mkdir(); &#125; //在本地创建文件 File file = new File(dir, mFileInfo.getFileName()); raf = new RandomAccessFile(file, \"rwd\"); //设置本地文件长度 raf.setLength(length); mFileInfo.setLength(length); Log.e(TAG,\"下载文件大小(size)\"+ mFileInfo.getLength() + \"\"); mHandler.obtainMessage(DownloadService.MSG_FILEINFO, mFileInfo).sendToTarget(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (conn != null &amp;&amp; raf != null) &#123; raf.close(); conn.disconnect(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ii.文件下载线程(DownloadThread)断点续传原理核心类。1.判断下载进度是否有保存，若无，数据插入一条数据。123if (!mDatabaseOperation.isExists(downloadInfo.getUrl(), downloadInfo.getId())) &#123; mDatabaseOperation.insert(downloadInfo);&#125; 2.设置网络请求Range参数，从请求位置返回数据123//设置下载位置long start = downloadInfo.getStart() + downloadInfo.getProgress();connection.setRequestProperty(\"Range\", \"bytes=\" + start + \"-\" + downloadInfo.getEnd()); 3.通过RandomAccessFile从进度保存位置保存文件1234567RandomAccessFile raf;File file = new File(DownloadService.DOWNLOAD_PATH, mFileInfo.getFileName());raf = new RandomAccessFile(file, \"rwd\");raf.seek(start);...//写入文件raf.write(buffer, 0, len); 4.用户暂停时，保存下载进度123456//下载暂停时，保存进度 if (isPause) &#123; Log.e(TAG,\"保存进度文件(size):\"+progress + \"\"); mDatabaseOperation.update(mFileInfo.getUrl(), mFileInfo.getId(), progress); return; &#125; 4.广播(BroadcastReceiver)：每秒广播一次，刷新UI1234567long time = System.currentTimeMillis();......if (System.currentTimeMillis() - time &gt; 1000) &#123;//超过一秒，就刷新UI time = System.currentTimeMillis(); sendBroadcast(intent,(int)(progress * 100 / mFileInfo.getLength())); Log.e(TAG,\"进度：\" + progress * 100 / mFileInfo.getLength() + \"%\");&#125; DownloadThread类源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 文件下载线程 * Created by AwenZeng on 2017/9/6. */public class DownloadThread extends Thread &#123; private DownloadInfo downloadInfo; private FileInfo mFileInfo; private long progress = 0; private boolean isPause; private DatabaseOperation mDatabaseOperation; private Context mContext; private static final String TAG = \"DownloadThread\"; public DownloadThread(Context context, DatabaseOperation databaseOperation, DownloadInfo threadInfo, FileInfo fileInfo) &#123; this.downloadInfo = threadInfo; mContext = context; mDatabaseOperation = databaseOperation; mFileInfo = fileInfo; &#125; public void setPause(boolean pause) &#123; isPause = pause; &#125; @Override public void run() &#123; if (!mDatabaseOperation.isExists(downloadInfo.getUrl(), downloadInfo.getId())) &#123; mDatabaseOperation.insert(downloadInfo); &#125; HttpURLConnection connection; RandomAccessFile raf; InputStream is; try &#123; URL url = new URL(downloadInfo.getUrl()); connection = (HttpURLConnection) url.openConnection(); connection.setConnectTimeout(3000); connection.setRequestMethod(\"GET\"); //设置下载位置 long start = downloadInfo.getStart() + downloadInfo.getProgress(); connection.setRequestProperty(\"Range\", \"bytes=\" + start + \"-\" + downloadInfo.getEnd()); //设置文件写入位置 File file = new File(DownloadService.DOWNLOAD_PATH, mFileInfo.getFileName()); raf = new RandomAccessFile(file, \"rwd\"); raf.seek(start); progress += downloadInfo.getProgress(); Log.e(TAG,\"下载文件进度(size)：\"+ downloadInfo.getProgress() + \"\"); Log.e(TAG,\"HttpResponseCode ===\"+connection.getResponseCode() + \"\"); //开始下载 if (connection.getResponseCode() == HttpURLConnection.HTTP_PARTIAL) &#123; Log.e(TAG,\"剩余文件(size):\"+connection.getContentLength() + \"\"); Intent intent = new Intent(DownloadService.ACTION_UPDATE);//广播intent is = connection.getInputStream(); byte[] buffer = new byte[1024 * 4]; int len = -1; long time = System.currentTimeMillis(); while ((len = is.read(buffer)) != -1) &#123; //下载暂停时，保存进度 if (isPause) &#123; Log.e(TAG,\"保存进度文件(size):\"+progress + \"\"); mDatabaseOperation.update(mFileInfo.getUrl(), mFileInfo.getId(), progress); return; &#125; //写入文件 raf.write(buffer, 0, len); //把下载进度发送广播给Activity progress += len; if (System.currentTimeMillis() - time &gt; 1000) &#123;//超过一秒，就刷新UI time = System.currentTimeMillis(); sendBroadcast(intent,(int)(progress * 100 / mFileInfo.getLength())); Log.e(TAG,\"进度：\" + progress * 100 / mFileInfo.getLength() + \"%\"); &#125; &#125; sendBroadcast(intent,100); /** * 删除下载信息（重新下载） */ mDatabaseOperation.delete(mFileInfo.getUrl(), mFileInfo.getId()); is.close(); &#125; raf.close(); connection.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void sendBroadcast(Intent intent,int progress)&#123; intent.putExtra(\"progress\",progress); mContext.sendBroadcast(intent); &#125;&#125; 三、源码地址如果你觉得还不错，欢迎star或fork。https://github.com/awenzeng/BreakPointDemo 四、参考文献RandomAccessFiley详解 http断点续传原理：http头 Range、Content-Range InputStream中read()与read(byte[] b)","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Http文件断点续传","slug":"Http文件断点续传","permalink":"http://awenzeng.me/tags/Http文件断点续传/"}]},{"title":"你本是一个肉体，是什么驱使你前行[3]","date":"2017-09-04T11:02:57.000Z","path":"2017/09/04/think_body_and_soul_3/","text":"《大学》 大学之道，在明明德，在亲民，在止於至善。知止而后有定；定而后能静；静而后能安；安而后能虑；虑而后能得。物有本末；事有终始。知所先后，则近道矣。 古之欲明明德於天下者，先治其国；欲治其国者先齐其家；欲齐其家者先修其身；欲修其身者,先正其心；欲正其心者,先诚其意；欲诚其意者；先致其知；致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。 自天子以至於庶人，一是皆以修身为本。其本乱而末治者，否矣； 其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。 王阳明心学视频(浙江大学公开课-董平教授)1.导论：王阳明与阳明心学 2.心即理：阳明心学的逻辑起点 3.知行合一：阳明心学的实践品格 4.格物致知：知识论域的实践转向 5.本体与主体性的自我建立 6.本心的自我开显与自我表达 7.心外无物：生命境界的无限圆融 8.天泉证道“四句教”阳明学派的分化 9.心体的自我澄明与价值实现","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"你本是一个肉体，是什么驱使你前行","slug":"你本是一个肉体，是什么驱使你前行","permalink":"http://awenzeng.me/tags/你本是一个肉体，是什么驱使你前行/"},{"name":"原创","slug":"原创","permalink":"http://awenzeng.me/tags/原创/"},{"name":"王阳明心学","slug":"王阳明心学","permalink":"http://awenzeng.me/tags/王阳明心学/"}]},{"title":"Android Camera相机开发详解","date":"2017-08-21T11:34:21.000Z","path":"2017/08/21/tech_android_camera/","text":"在应用软件开发中，图片数据，对于一个公司来说是十分重要的，例如：上传图片资料，修改用户头像等，而这其中就离不开相机和相册的使用。对于ios平台来说，直接调用系统相机或相册，就可搞定一切。然而对于Android平台来说，直接调用系统相机或相册，在适配和体验上问题比较多，具体原因，相比大家也知道，安卓品牌太多太杂，性能不一。鉴于此，在开发的过程中，遇到类似问题，建议自己实现相机或相册功能，以保证体验完整。本篇博文将会重点介绍Camera相机的实现。 首先，推荐两个github项目，可以直接使用的相机和相册；另外，也推荐一个联系人选择器： 相机：CameraDemo(自定义相机) 相册：ImageSelector(仿微信图片选择相册) 联系人：ContactSelector(联系人选择器) 一、打开Camera12345678try &#123; mCamera = Camera.open();//开启相机 &#125; catch (RuntimeException e) &#123; e.printStackTrace(); LogUtil.d(TAG, \"摄像头异常，请检查摄像头权限是否应许\"); ToastUtil.getInstance().toast(\"摄像头异常，请检查摄像头权限是否应许\"); return; &#125; 二、设置Camera参数默认尺寸可以自由设置，这里取手机的分辨率为默认尺寸。 1.根据指定分辨率查找相机最佳适配分辨率并设置 12345678910111213141516171819private void setCameraParams(int width, int height) &#123; LogUtil.i(TAG, \"setCameraParams width=\" + width + \" height=\" + height); Camera.Parameters parameters = mCamera.getParameters(); List&lt;Camera.Size&gt; pictureSizeList = parameters.getSupportedPictureSizes(); sort(pictureSizeList);//排序 for (Camera.Size size : pictureSizeList) &#123; LogUtil.i(TAG, \"摄像头支持的分辨率：\" + \" size.width=\" + size.width + \" size.height=\" + size.height); &#125; Camera.Size picSize = getBestSupportedSize(pictureSizeList, ((float) height / width));//从列表中选取合适的分辨率 if (null == picSize) &#123; picSize = parameters.getPictureSize(); &#125; LogUtil.e(TAG, \"我们选择的摄像头分辨率：\" + \"picSize.width=\" + picSize.width + \" picSize.height=\" + picSize.height); // 根据选出的PictureSize重新设置SurfaceView大小 parameters.setPictureSize(picSize.width, picSize.height); .... 2.根据指定分辨率查找相机最佳预览分辨率并设置 1234567891011121314151617private void setCameraParams(int width, int height) &#123; LogUtil.i(TAG, \"setCameraParams width=\" + width + \" height=\" + height); Camera.Parameters parameters = mCamera.getParameters(); /*************************** 获取摄像头支持的PreviewSize列表********************/ List&lt;Camera.Size&gt; previewSizeList = parameters.getSupportedPreviewSizes(); sort(previewSizeList); for (Camera.Size size : previewSizeList) &#123; LogUtil.i(TAG, \"摄像支持可预览的分辨率：\" + \" size.width=\" + size.width + \" size.height=\" + size.height); &#125; Camera.Size preSize = getBestSupportedSize(previewSizeList, ((float) height) / width); if (null != preSize) &#123; LogUtil.e(TAG, \"我们选择的预览分辨率：\" + \"preSize.width=\" + preSize.width + \" preSize.height=\" + preSize.height); parameters.setPreviewSize(preSize.width, preSize.height); &#125; ...... 3.最佳分辨率适配算法(先排序) 1234567891011121314151617181920212223242526272829303132333435/** * 如包含默认尺寸，则选默认尺寸，如没有，则选最大的尺寸 * 规则：在相同比例下，1.优先寻找长宽分辨率相同的-&gt;2.找长宽有一个相同的分辨率-&gt;3.找最大的分辨率 * * @param sizes 尺寸集合 * @return 返回合适的尺寸 */private Camera.Size getBestSupportedSize(List&lt;Camera.Size&gt; sizes, float screenRatio) &#123; Camera.Size largestSize = null; int largestArea = 0; for (Camera.Size size : sizes) &#123; if ((float) size.height / (float) size.width == screenRatio) &#123; if (size.width == DEFAULT_PHOTO_WIDTH &amp;&amp; size.height == DEFAULT_PHOTO_HEIGHT) &#123; // 包含特定的尺寸，直接取该尺寸 largestSize = size; break; &#125; else if (size.height == DEFAULT_PHOTO_HEIGHT || size.width == DEFAULT_PHOTO_WIDTH) &#123; largestSize = size; break; &#125; int area = size.height + size.width; if (area &gt; largestArea) &#123;//找出最大的合适尺寸 largestArea = area; largestSize = size; &#125; &#125; else if (size.height == DEFAULT_PHOTO_HEIGHT || size.width == DEFAULT_PHOTO_WIDTH) &#123; largestSize = size; break; &#125; &#125; if (largestSize == null) &#123; largestSize = sizes.get(sizes.size() - 1); &#125; return largestSize;&#125; 4.对焦模式选择由于部分智能手机，前置摄像头无对焦模式，对焦参数设置应区分前置摄像头 1234//对焦模式的选择 if(cameraId == Camera.CameraInfo.CAMERA_FACING_BACK)&#123; parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//手动区域自动对焦 &#125; 5.图片质量PixelFormat中有多种模式，源码有解。 1234//图片质量parameters.setJpegQuality(100); // 设置照片质量parameters.setPreviewFormat(PixelFormat.YCbCr_420_SP); // 预览格式parameters.setPictureFormat(PixelFormat.JPEG); // 相片格式为JPEG，默认为NV21 6.闪关灯及横竖屏镜头调整 123456789// 关闪光灯parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);// 横竖屏镜头自动调整if (mContext.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE) &#123; mCamera.setDisplayOrientation(90);&#125; else &#123; mCamera.setDisplayOrientation(0);&#125; 7.相机异常监听 1234567891011121314151617181920212223//相机异常监听mCamera.setErrorCallback(new Camera.ErrorCallback() &#123; @Override public void onError(int error, Camera camera) &#123; String error_str; switch (error) &#123; case Camera.CAMERA_ERROR_SERVER_DIED: // 摄像头已损坏 error_str = \"摄像头已损坏\"; break; case Camera.CAMERA_ERROR_UNKNOWN: error_str = \"摄像头异常，请检查摄像头权限是否应许\"; break; default: error_str = \"摄像头异常，请检查摄像头权限是否应许\"; break; &#125; ToastUtil.getInstance().toast(error_str); Log.i(TAG, error_str); &#125;&#125;); 完整参数设置代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 设置分辨率等参数 * * @param width 宽 * @param height 高 */ private void setCameraParams(int width, int height) &#123; LogUtil.i(TAG, \"setCameraParams width=\" + width + \" height=\" + height); Camera.Parameters parameters = mCamera.getParameters(); /*************************** 获取摄像头支持的PictureSize列表********************/ List&lt;Camera.Size&gt; pictureSizeList = parameters.getSupportedPictureSizes(); sort(pictureSizeList);//排序 for (Camera.Size size : pictureSizeList) &#123; LogUtil.i(TAG, \"摄像头支持的分辨率：\" + \" size.width=\" + size.width + \" size.height=\" + size.height); &#125; Camera.Size picSize = getBestSupportedSize(pictureSizeList, ((float) height / width));//从列表中选取合适的分辨率 if (null == picSize) &#123; picSize = parameters.getPictureSize(); &#125; LogUtil.e(TAG, \"我们选择的摄像头分辨率：\" + \"picSize.width=\" + picSize.width + \" picSize.height=\" + picSize.height); // 根据选出的PictureSize重新设置SurfaceView大小 parameters.setPictureSize(picSize.width, picSize.height); /*************************** 获取摄像头支持的PreviewSize列表********************/ List&lt;Camera.Size&gt; previewSizeList = parameters.getSupportedPreviewSizes(); sort(previewSizeList); for (Camera.Size size : previewSizeList) &#123; LogUtil.i(TAG, \"摄像支持可预览的分辨率：\" + \" size.width=\" + size.width + \" size.height=\" + size.height); &#125; Camera.Size preSize = getBestSupportedSize(previewSizeList, ((float) height) / width); if (null != preSize) &#123; LogUtil.e(TAG, \"我们选择的预览分辨率：\" + \"preSize.width=\" + preSize.width + \" preSize.height=\" + preSize.height); parameters.setPreviewSize(preSize.width, preSize.height); &#125; /*************************** 对焦模式的选择 ********************/ if(cameraId == Camera.CameraInfo.CAMERA_FACING_BACK)&#123; parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//手动区域自动对焦 &#125; //图片质量 parameters.setJpegQuality(100); // 设置照片质量 parameters.setPreviewFormat(PixelFormat.YCbCr_420_SP); // 预览格式 parameters.setPictureFormat(PixelFormat.JPEG); // 相片格式为JPEG，默认为NV21 // 关闪光灯 parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF); // 横竖屏镜头自动调整 if (mContext.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE) &#123; mCamera.setDisplayOrientation(90); &#125; else &#123; mCamera.setDisplayOrientation(0); &#125; //相机异常监听 mCamera.setErrorCallback(new Camera.ErrorCallback() &#123; @Override public void onError(int error, Camera camera) &#123; String error_str; switch (error) &#123; case Camera.CAMERA_ERROR_SERVER_DIED: // 摄像头已损坏 error_str = \"摄像头已损坏\"; break; case Camera.CAMERA_ERROR_UNKNOWN: error_str = \"摄像头异常，请检查摄像头权限是否应许\"; break; default: error_str = \"摄像头异常，请检查摄像头权限是否应许\"; break; &#125; ToastUtil.getInstance().toast(error_str); Log.i(TAG, error_str); &#125; &#125;); mCamera.cancelAutoFocus(); mCamera.setParameters(parameters); &#125; 三、对焦要实现点击对焦，并有对焦环，需要自定义实现对焦环View. 1.自定义对焦环View-CameraFocusView 核心功能，就是对焦环缩小，并变绿。利用动画改变对焦环半径即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 @Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(isShow)&#123; if(radius == GREEN_RADIUS)&#123; mPaint.setColor(Color.GREEN); &#125; if(centerPoint!=null)&#123; canvas.drawCircle(centerPoint.x, centerPoint.y, radius, mPaint); &#125; &#125;&#125;private void showAnimView() &#123; isShow = true; if (lineAnimator == null) &#123; lineAnimator = ValueAnimator.ofInt(0, 20); lineAnimator.setDuration(DURATION_TIME); lineAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int animationValue = (Integer) animation .getAnimatedValue(); if(lastValue!=animationValue&amp;&amp;radius&gt;=(int) ((mScreenWidth * 0.1)-20))&#123; radius = radius - animationValue; lastValue = animationValue; &#125; isShow = true; invalidate(); &#125; &#125;); lineAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); isShow = false; lastValue = 0; mPaint.setColor(Color.WHITE); radius = (int) (mScreenWidth * 0.1); invalidate(); &#125; &#125;); &#125;else&#123; lineAnimator.end(); lineAnimator.cancel(); lineAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); lineAnimator.start(); &#125;&#125; 2.布局界面 让对焦环自定义View获取整个界面的触摸事件 1234567891011121314&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;com.awen.camera.widget.CameraSurfaceView android:id=\"@+id/cameraSurfaceView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;com.awen.camera.widget.CameraFocusView android:id=\"@+id/cameraFocusView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; ...... 3.定义对焦接口 i.定义接口 123456/** * 聚焦的回调接口 */public interface IAutoFocus &#123; void autoFocus(float x,float y);&#125; ii.对焦环View触摸事件中触发接口： 1234567891011121314151617181920212223@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: int x = (int) event.getX(); int y = (int) event.getY(); lastValue = 0; mPaint.setColor(Color.WHITE); radius = (int) (mScreenWidth * 0.1); centerPoint = null; if(y&gt;TOP_CONTROL_HEIGHT&amp;&amp;y&lt;ScreenSizeUtil.getScreenHeight()-BETTOM_CONTROL_HEIGHT)&#123;//状态栏和底部禁止点击获取焦点（显示体验不好） centerPoint = new Point(x, y); showAnimView(); //开始对焦 if (mIAutoFocus != null) &#123; mIAutoFocus.autoFocus(event.getX(),event.getY()); &#125; &#125; break; &#125; return true;&#125; 4.在CameraSurfaceView实现对焦 i.计算对焦区域 12345678910111213private Rect caculateFocusPoint(int x, int y) &#123; Rect rect = new Rect(x - 100, y - 100, x + 100, y + 100); int left = rect.left * 2000 / getWidth() - 1000; int top = rect.top * 2000 / getHeight() - 1000; int right = rect.right * 2000 / getWidth() - 1000; int bottom = rect.bottom * 2000 / getHeight() - 1000; // 如果超出了(-1000,1000)到(1000, 1000)的范围，则会导致相机崩溃 left = left &lt; -1000 ? -1000 : left; top = top &lt; -1000 ? -1000 : top; right = right &gt; 1000 ? 1000 : right; bottom = bottom &gt; 1000 ? 1000 : bottom; return new Rect(left, top, right, bottom); &#125; ii.设置参数进行对焦 123456789101112131415private void camerFocus(Rect rect) &#123; if (mCamera != null) &#123; Camera.Parameters parameters = mCamera.getParameters(); if(cameraId == Camera.CameraInfo.CAMERA_FACING_BACK)&#123; parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//手动区域自动对焦 &#125; if (parameters.getMaxNumFocusAreas() &gt; 0) &#123; List&lt;Camera.Area&gt; focusAreas = new ArrayList&lt;Camera.Area&gt;(); focusAreas.add(new Camera.Area(rect, 1000)); parameters.setFocusAreas(focusAreas); &#125; mCamera.cancelAutoFocus(); // 先要取消掉进程中所有的聚焦功能 mCamera.setParameters(parameters); mCamera.autoFocus(this); &#125; 四、拍照为了图片方便预览，需要对图片进行处理，所以需要知道相机的拍照时的方向，故在拍照应先设置照片的方向参数 1.CameraOrientationDetector(Camera方向监听器) 1234567891011121314151617181920212223242526272829/** * 方向变化监听器，监听传感器方向的改变 * Created by AwenZeng on 2017/2/21. */public class CameraOrientationDetector extends OrientationEventListener &#123; int mOrientation; public CameraOrientationDetector(Context context, int rate) &#123; super(context, rate); &#125; @Override public void onOrientationChanged(int orientation) &#123; this.mOrientation = orientation; if (orientation == OrientationEventListener.ORIENTATION_UNKNOWN) &#123; return; &#125; //保证只返回四个方向,分别为0°、90°、180°和270°中的一个 int newOrientation = ((orientation + 45) / 90 * 90) % 360; if (newOrientation != mOrientation) &#123; mOrientation = newOrientation; &#125; &#125; public int getOrientation() &#123; return mOrientation; &#125;&#125; 2.设置照片方向参数 1234567891011121314151617181920212223242526/** * 拍照 * * @param callback */public void takePicture(Camera.PictureCallback callback) &#123; if (mCamera != null) &#123; int orientation = mCameraOrientation.getOrientation(); Camera.Parameters cameraParameter = mCamera.getParameters(); if (orientation == 90) &#123; cameraParameter.setRotation(90); cameraParameter.set(\"rotation\", 90); &#125; else if (orientation == 180) &#123; cameraParameter.setRotation(180); cameraParameter.set(\"rotation\", 180); &#125; else if (orientation == 270) &#123; cameraParameter.setRotation(270); cameraParameter.set(\"rotation\", 270); &#125; else &#123; cameraParameter.setRotation(0); cameraParameter.set(\"rotation\", 0); &#125; mCamera.setParameters(cameraParameter); &#125; mCamera.takePicture(null, null, callback);&#125; 3.保存图片 为了方便预览，对不同方向的图片，需要做正向处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public String handlePhoto(byte[] data, int cameraId) &#123; String filePath = FileUtil.saveFile(data, \"/DCIM\"); if (!TextUtils.isEmpty(filePath)) &#123; int degree = BitmapUtil.getPhotoDegree(filePath); Log.i(TAG, degree + \"\"); Bitmap bitmap = BitmapFactory.decodeFile(filePath); Bitmap tBitmap = null; try &#123; Log.i(TAG, \"保存图片大小：\"+\"width = \" + bitmap.getWidth() + \" ------ height = \" + bitmap.getHeight()); if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; switch (degree) &#123; case 0: tBitmap = BitmapUtil.rotateBitmap(bitmap, 90); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 90: tBitmap = BitmapUtil.rotateBitmap(bitmap, 180); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 180: tBitmap = BitmapUtil.rotateBitmap(bitmap, 270); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 270: tBitmap = BitmapUtil.rotateBitmap(bitmap, 360); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; &#125; &#125; else if (cameraId == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; switch (degree) &#123; case 0: tBitmap = BitmapUtil.rotateBitmap(bitmap, 270); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 90: tBitmap = BitmapUtil.rotateBitmap(bitmap, 180); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 180: tBitmap = BitmapUtil.rotateBitmap(bitmap, 90); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; case 270: tBitmap = BitmapUtil.rotateBitmap(bitmap, 360); filePath = BitmapUtil.saveBitmap(tBitmap == null ? bitmap : tBitmap, filePath); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // 重新拍照 return \"\"; &#125; finally &#123; if (bitmap != null) &#123; bitmap.recycle(); bitmap = null; &#125; if (tBitmap != null) &#123; tBitmap.recycle(); tBitmap = null; &#125; ScannerByReceiver(mContext, filePath);//图库扫描 &#125; return filePath; &#125; return null; &#125; 五、切换摄像头1234567891011121314151617181920212223242526272829303132/** * 切换摄像头 */ public void changeCamera(int camera_id) &#123; mCamera.stopPreview(); mCamera.release(); try &#123; openCamera(camera_id); mCamera.setPreviewDisplay(holder); setCameraParams(DEFAULT_PHOTO_WIDTH, DEFAULT_PHOTO_HEIGHT); mCamera.startPreview(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public boolean openCamera(int camera_id) &#123; LogUtil.i(TAG, \"openCamera id = \" + camera_id); try &#123; mCamera = Camera.open(camera_id); // 打开摄像头 cameraId = camera_id; &#125; catch (Exception e) &#123; e.printStackTrace(); ToastUtil.getInstance().toast(\"请先开启摄像头权限\"); LogUtil.i(TAG, \"请先开启摄像头权限\"); return false; &#125; return true; &#125; 六、打开或关闭闪光灯12345678910111213141516171819202122232425/** * 设置闪光灯 * * @param isOpen */public void changeFlashMode(boolean isOpen, Camera mCamera, int cameraId) &#123; if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; // 后摄像头才有闪光灯 Camera.Parameters parameters = mCamera.getParameters(); PackageManager pm = mContext.getPackageManager(); FeatureInfo[] features = pm.getSystemAvailableFeatures(); for (FeatureInfo f : features) &#123; if (PackageManager.FEATURE_CAMERA_FLASH.equals(f.name)) &#123; // 判断设备是否支持闪光灯 if (isOpen) &#123; parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH); // 开闪光灯 &#125; else &#123; parameters .setFlashMode(Camera.Parameters.FLASH_MODE_OFF); // 关闪光灯 &#125; &#125; &#125; mCamera.setParameters(parameters); &#125;&#125; 注意事项 Android6.0以上权限收紧，所以在使用相机前，请用PermissionsModel做好权限判断。具体Android6.0权限 部分智能手机，前置摄像头无对焦模式，对焦参数设置应区分前置摄像头 Android5.0以后，官方推荐使用Camera2,本例子未使用新版本。","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android相机","slug":"Android相机","permalink":"http://awenzeng.me/tags/Android相机/"},{"name":"Camera","slug":"Camera","permalink":"http://awenzeng.me/tags/Camera/"}]},{"title":"你本是一个肉体，是什么驱使你前行[2]","date":"2017-08-21T08:58:49.000Z","path":"2017/08/21/think_body_and_soul_2/","text":"文/笔沫拾光 从出生到五岁，你童年无忌，尽情玩耍，想哭就哭，想笑就笑。 五岁到十二岁，你在小学，开始谨记：好好学习，天天向上。 十二岁到十五岁，你在初中，尽情游戏，忘乎天地，但也没忘，好好学习，上高中。 十五岁到十九岁，你在高中，远离游戏，废寝忘食，决战高考，梦想大学。 十九岁到二十三岁，你在大学，努力学习，奋战自习室，为了未来，为了工作。 二十三岁到现在，你毕业，工作。我却想问：你本是一个肉体，是什么驱使你前行？","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"你本是一个肉体，是什么驱使你前行","slug":"你本是一个肉体，是什么驱使你前行","permalink":"http://awenzeng.me/tags/你本是一个肉体，是什么驱使你前行/"},{"name":"原创","slug":"原创","permalink":"http://awenzeng.me/tags/原创/"},{"name":"笔沫拾光","slug":"笔沫拾光","permalink":"http://awenzeng.me/tags/笔沫拾光/"}]},{"title":"执着的人是幸福的","date":"2017-08-11T02:04:50.000Z","path":"2017/08/11/think_guochuan_article/","text":"文/郭川 今天是我完成单人不间断环球航行上岸两周年的日子。 在我上岸后，我接受了很多媒体的采访。他们都会问我同一个问题，就是你为什么要做这样一个挑战。虽然大部分人对我做的事情表示钦佩，但是也会有人对我的冒险表示不理解，认为我太自我。 如果我是一个法国人或者英国人，我不会遇到这样的问题，更多的人可能会对我如何完成这样的挑战的细节感兴趣。 事实上，从你为什么要做这件事，到你如何做到这样事，问问题的角度不同，而观念之间的距离却是一个几十年的差距。 在过去的20年，我们在物质上的进步可谓神速，然而精神上的追求却似乎陷入了迷茫和困惑。 2013年5月10日，正在美国旧金山参加美洲杯帆船赛训练的瑞典船队阿特米斯号意外倾覆，船上北京奥运会帆船星级赛冠军英国人安德鲁-辛普森不幸身亡。36岁的辛普森是两枚奥运奖牌得主，除北京奥运金牌外，他还在2012年的伦敦奥运会上获得一枚银牌。国际奥委会主席罗格当年曾代表比利时参加过奥运会帆船比赛，他在一份声明中说：“辛普森是一位非常有成就的帆船运动员和奥运选手，他是在对帆船运动的激情的追求中离世的。” 独立的思想，自由的精神，始终是我追求的一个境界。 从我的履历看，我与常人的想法并没有什么不同：获得北京航空航天大学飞行器控制专业硕士学位，我有自己的学术追求；考取北大光华管理学院，我也有向职业经理人跃升的职业规划。如果不是因为帆船，或许在我接下来的个人简历上，会写上某某公司总经理，首席执行官之类的头衔。 然而，突然有一天，这种单调的生活让我厌倦，我开始拼命拓展生命的外延，因此我去学开滑翔机、学习潜水、学习滑雪……用一切可能的方式挑战自我的极限，用常人难以想象的意志力和“与年龄不符”的热情疯狂填充自己生命中的空白。 应该说，是帆船改变了我的后半生。感谢帆船，让我自由的灵魂得以释放，而我放荡不羁的内心也找到了皈依的地方。十五年来的帆船生活，让我对人生有了全新的思考，但这一切都要基于一个科学的态度和方法！ 有人说中国人传统，习惯沿着父母或者社会铺就或者认可的人生轨迹前行，在与内心深处那个真实的自我纠结多年之后,我没有选择背叛梦想，背叛个性。在这个传统的循规蹈矩的社会，我的所做所为更像是个另类：放弃富足的生活和成功的事业，投身于自己热衷的充满风险和挑战的高危竞技活动，而这一切，除了帆船的魅力，就是因为忠实于自我的勇气。 我在法国训练的这几年，生活非常简单。每天吃的东西都是千篇一律，我的团队到法国来看我的训练，非常吃惊。而我却感觉不到是在吃苦。因为我非常享受这个过程，这种做自己喜欢的事情，全情投入的感觉。 有人说中国人保守，什么年龄做什么事情，我已过不惑之年，似乎应该循规蹈矩。但是在我看来，人生不应是一条由窄变宽、由急变缓的河流，更应该像一条在崇山峻岭间奔腾的小溪，时而近乎枯竭，时而一泻千里，总之你不会知道在下一个弯口会出现怎样的景致和故事，人生本该立体而多彩。 我也想对所有心怀梦想的人说：我今年50岁，十年前开始改变自己的人生，只要想改变，什么时候都不算晚。只要内心保留住真实的自我，保留住那份对生活的执着。 茫茫大海，漫无边际，在长达数月的航行中，我需要忍受着孤独、抑郁和恐惧的煎熬，我的冒险行为，在常人看来无异于“疯子”。而我和别人的不同就是多了一些执着。所谓执着，就是不怕吃苦，不怕前面是未知还要把它当做追求的目标。我认为我是一个幸福的人，因为执着，我成就了我的梦想。 好奇与冒险本来就是人类与生俱来的品性，是人类进步的优良基因，我不过遵从了这种本性的召唤，回归真实的自我。 希望不久的将来，中国人在精神上的进步会像物质上的增长速度一样快，也希望我的所作所能激励更多的中国人，走向海洋，勇于冒险，不要轻易被安逸的生活所困，让我们共同努力，重塑中国人的民族精神！","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"演讲","slug":"演讲","permalink":"http://awenzeng.me/tags/演讲/"},{"name":"执着的人是幸福的","slug":"执着的人是幸福的","permalink":"http://awenzeng.me/tags/执着的人是幸福的/"},{"name":"郭川","slug":"郭川","permalink":"http://awenzeng.me/tags/郭川/"}]},{"title":"【转载】Android Studio Gradle编译优化方法","date":"2017-08-08T06:30:24.000Z","path":"2017/08/08/tech_android_studio_config_optimize/","text":"前言：最近发现Gradle项目编译越来越慢，有时甚至需要好几十分钟，实在是让人难以忍受。于是，便搜寻于网络，经过验证，发现此方案尤其有效，故留此博客，以备以后之需。 第1步：打开AS安装所在的位置，用记事本打开studio64.exe.vmoptions文件。具体如图： 第2步：打开“studio64.exe.vmoptions”文件后修改里面的值，修改后如下： 1234567891011121314151617181920212223## *DO NOT* modify this file directly. If there is a value that you would like to override,# please add it to your user specific configuration file.## See http://tools.android.com/tech-docs/configuration#-Xms2048m-Xmx2048m-XX:MaxPermSize=2048m-XX:ReservedCodeCacheSize=1024m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-da-Djna.nosys=true-Djna.boot.library.path= -Djna.debug_load=true-Djna.debug_load.jna=true-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError-Didea.paths.selector=AndroidStudio2.0-Didea.platform.prefix=AndroidStudio 第3步：打开你的项目中的“gradle.properties”文件复制如下内容： 12345678910111213141516171819202122# Project-wide Gradle settings.# IDE (e.g. Android Studio) users:# Settings specified in this file will override any Gradle settings# configured through the IDE.# For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html# The Gradle daemon aims to improve the startup and execution time of Gradle.# When set to true the Gradle daemon is to run the build.# TODO: disable daemon on CI, since builds should be clean and reliable on serversorg.gradle.daemon=true# Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx10248m -XX:MaxPermSize=256morg.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8# When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projectsorg.gradle.parallel=true# Enables new incubating mode that makes Gradle selective when configuring projects.# Only relevant projects are configured which results in faster builds for large multi-projects.# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:configuration_on_demandorg.gradle.configureondemand=true 第4步：修改gradle-wrapper.properties文件,如图： 第5步：Gradle官网下载地址：http://services.gradle.org/distributions如图： 第6步：具体如图： 第7步：重新编译一下项目，结果如图： 参考资料：Android Studio Gradle优化方法(一般人我不告诉他)","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"AS Gradle优化","slug":"AS-Gradle优化","permalink":"http://awenzeng.me/tags/AS-Gradle优化/"}]},{"title":"Annontation注解的应用及介绍","date":"2017-08-01T11:38:14.000Z","path":"2017/08/01/tech_android_annontation/","text":"一、什么是注解？Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 二、注解的用处 生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等 跟踪代码依赖性，实现替代配置文件功能。 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 三、注解介绍元注解 java.lang.annotation提供了四种元注解，专门注解其他的注解： @Documented –注解是否将包含在JavaDoc中 @Retention –什么时候使用该注解 @Target –注解用于什么地方 @Inherited – 是否允许子类继承该注解 1）@Retention– 定义该注解的生命周期 RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 2）@Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括 ElementType.CONSTRUCTOR:用于描述构造器 ElementType.FIELD:成员变量、对象、属性（包括enum实例） ElementType.LOCAL_VARIABLE:用于描述局部变量 ElementType.METHOD:用于描述方法 ElementType.PACKAGE:用于描述包 ElementType.PARAMETER:用于描述参数 ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明 3)@Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。 4)@Inherited – 定义该注释和子类的关系 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 四、注解使用1）方法注解： 12345@Target(METHOD)@Retention(RUNTIME)public @interface UserMethod &#123; String title() default \"\";&#125; 2）参数注解： 123456@Target(PARAMETER)@Retention(RUNTIME)public @interface UserParam &#123; String name() default \"\"; String phone() default \"\";&#125; 3）注解使用：1234public interface UserInterface &#123; @UserMethod(title = \"AwenZeng\") String getUser(@UserParam(name = \"刘峰\",phone = \"110\") String a);&#125; 4）获取注解： 通过反射机制获取函数注解信息： 12345Method[] declaredMethods = UserInterface.class.getDeclaredMethods(); for (Method method : declaredMethods) &#123; Annotation[] methodAnnotations = method.getAnnotations(); Annotation[][] parameterAnnotationsArray = method.getParameterAnnotations(); &#125; 也可以获取指定的注解: 1UserMethod userMethod = method.getAnnotation(UserMethod.class); 5) 具体实现注解接口调用 采用Java动态代理机制来实现: 1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]&#123;service&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // Annotation[] methodAnnotations = method.getAnnotations();//拿到函数注解数组 UserMethod userMethod = method.getAnnotation(UserMethod.class); Log.e(\"good\", \"UserParam---getValue-&gt;\" + userMethod.title()); Type[] parameterTypes = method.getGenericParameterTypes(); Annotation[][] parameterAnnotationsArray = method.getParameterAnnotations();//拿到参数注解 for (int i = 0; i &lt; parameterAnnotationsArray.length; i++) &#123; Annotation[] annotations = parameterAnnotationsArray[i]; if (annotations != null) &#123; UserParam reqParam = (UserParam) annotations[0]; Log.e(\"good\", \"reqParam---reqParam-&gt;\" + reqParam.name()+ \",\"+reqParam.phone()+ \",\" + args[i]); &#125; &#125; //下面就可以执行相应的网络请求获取结果 返回结果 String result = \"\";//这里模拟一个结果 return result; &#125; &#125;);&#125; 6) 具体代码调用 12UserInterface userInterface = AnnotionProxy.create(UserInterface.class);userInterface.getUser(\"我之存在，因为有你。\"); 7) 结果 1208-01 12:11:14.688 11729-11729/com.awen.annotationdemo E/good: UserMethod---title-&gt;AwenZeng08-01 12:11:14.688 11729-11729/com.awen.annotationdemo E/good: UserParam---userParam-&gt;刘峰,110,我之存在，因为有你。 五、参考资料、Java学习之注解Annotation实现原理 JAVA中的反射机制 彻底理解JAVA动态代理","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android注解","slug":"Android注解","permalink":"http://awenzeng.me/tags/Android注解/"},{"name":"Java反射机制","slug":"Java反射机制","permalink":"http://awenzeng.me/tags/Java反射机制/"},{"name":"Java动态代理","slug":"Java动态代理","permalink":"http://awenzeng.me/tags/Java动态代理/"}]},{"title":"我之存在，因为有你","date":"2017-07-19T02:49:37.000Z","path":"2017/07/19/think_iam_because_of_you/","text":"文/霍华德*舒尔茨 非常感谢对我热情洋溢的介绍。我很荣幸、非常荣幸能够来到这里（清华大学）。我知道，过去这个讲堂也曾邀请过其他非常著名的演讲者。但是今天，我和大家分享的也许和之前的有点不太一样，并且会给你们提出一些出乎意料的挑战。 三年前，在星巴克的全球股东大会上，我向我们的员工、我们的股东问了一个很重要的问题。这个问题当时已经在我脑海中存在了很久，这个问题就是：在我们所生活的这个世界，每一天都在变化，不仅仅是商业上的变化，而是到处都在发生变化，一家商业上市公司的使命和责任是什么？仅仅只是盈利赚钱么？只是为股东带来回报么？如何在商业利润和社会责任之间实现平衡？这个问题就是今天晚上我想和各位分享的主题。 1987年，星巴克只有11家门店，员工区区百人。我们的梦想就是：把星巴克打造成一家与众不同的企业，不仅是一个本土品牌，更可以在公司不断发展的同时，与员工共同成长，分享成功，一路向前。正如刚刚院长所提到的，我们是美国第一家向员工提供综合医疗保险和股票期权的公司。当时，我们还只是一家私人公司。很多人认为这项举措会稀释公司股票的价值，是无法长期维持的。然而，当我们回顾星巴克的发展和成就，我们发现，原来最好的成功是与彼此分享。 现在，你必须要用一个与过去截然不同的方式来经营业务。1987年，星巴克只有11家门店，100名员工，我们梦想一直是把星巴克打造成一家与众不同的企业。而如今，正如刚刚院长介绍的，我们的门店已经超过了25,000家，业务遍及75个国家，拥有超过33万员工，上周接待的顾客人次达到9100万。那么问题来了：这是一家用纸杯销售咖啡的公司，很多人连那些意大利语的发音也不会，一杯定价3美元或4美元的咖啡，这些在过去都是从来没有发生过的。 然而，就是这样一家企业，从1987年的11家门店发展到如今的26,000家门店，市值将近900亿美元。这些成就是怎么得来的？你们可能还会问一个相似的问题——一家公司是如何从1999年开始的一家门店，发展成今天的26，000多家门店，每周服务500万位顾客，拥有近40,000名员工？ 今天我们在中国宣布了一项重要举措，这是星巴克的价值观、文化和指导原则的体现。这项全新的举措印证了“我们是谁？”每家公司，无论提供什么产品、什么服务、属于什么行业或来自哪个国家，都要对你存在的意义、目的和价值做一个定义。 所以今天，我们在北京宣布的这个消息：今天我们宣布，从今年6月1日起，为所有符合条件的全职中国员工，全资提供父母重大疾病保险。我们为什么要这么做呢？为什么公司要做如此巨大的投入，这也许要投入数百万美元，为这么多员工的父母购买这份保险？用这个问题带领我们再次回到1987年。答案就是：不是每一个商业决定都是出于经济利益的考量。一路走来，我们所做的许多决定都并不完全出于经济利益的考虑。事实上，我想说，我们做出的许多决策，都不是从经济利益出发的，甚至经常反其道而行之，然而，这就是我们获得商业成就的主要原因。在今日我们所处的环境中，欲打造一家可以持续发展的伟大公司，其成功的秘诀就是信任。作为管理者和领导者，我们的义务和责任就是不断满足员工的期望，并与他们建立一种相互信任的关系，这样他们才能不断满足并超越顾客的期待。 那么，这些理念、这些价值观、这一文化和这些指导原则从何而来呢？首先，我要说的是，我们在全世界采购和烘焙高品质的咖啡，我们可能拥有零售行业中最强的地产资源，我们的门店设计也是行业领先的。不论是咖啡品质、门店分布，还是门店设计和卓越运营，我们都引领业界。然而，所有这些在我们公司里，都只能排在第二位。我们最为看重的企业基石，是我们的文化和我们的行为举止。不论相信与否，这些文化和价值观形成于我的孩童时代。 我从小在纽约布鲁克林的政府公房里长大。你们可能听说过“美国梦”，美国式承诺，一个人的出身并不能决定他的未来。 我的父亲做过许多蓝领工作，在我7岁的时候，爸爸当时是一名运送尿布的货车司机，这也许是他所从事的工作中最糟糕的一份。 1960年3月，我记得那是一个寒冷的一天我的父亲因路面结冰而滑倒，摔伤了大腿。在60年代的美国，如果你是一个没有受过教育的蓝领工人，如果你在工作中受伤，你就会被解雇。没有收入，也没有意外保险。在7岁的时候，我亲历了美国梦的破灭，我目睹了父母所经历的无助和绝望，我们当时因此陷入了巨大的困境。 不论今日的我如何成功，我7岁时所经历的伤痛，直到今天仍历历在目。事实上，失败的恐惧、不安全感、脆弱无助让当时还是小男孩的我深感羞耻，然而，也由此而让我学会热诚、敏感、自重并尊重他人。 因此，我意识到，如果要打造一家可持续发展的伟大公司，我们必须要采取不同的方式。我们必须要将为股东提供价值和为员工提供价值联系起来，事实上，我们反其道而行之。 1992年6月，星巴克咖啡公司上市，当时我们有大约125家门店，实现了一个季度的盈利，总市值约2.5亿美元。当时，我认为我中了头彩。我打电话给我妈妈，对她说：“妈妈，我们做到了，我们的美国梦实现了。” 2.5亿美元。 25年过去了，星巴克如今的市值从2.5亿美元变成了将近900亿美元。回顾曾经取得的成就，分析成功的原因，我可以肯定地告诉你们，这不是因为我有MBA的学位，因为我并没有；这也不是因为我有商学院学位，因为我也没有，而且我已经不可能再获得。但我确认有的，那就是我的生活阅历。 我去过的每一个地方，我做的每一件事情，我试图永葆好奇，并且我要跟你们说，要保持绝对的好奇心。你们要具有真正的好奇心：对这个世界、对你所处的周围环境，对你能从不同的经历和不同的人身上学习所得的收获。你会因为所学到的很多东西而感到惊喜。 举个例子，6个月前，星巴克准备在南非开出第一家门店。此前，我从未去过南非，因此我感到十分兴奋。我们去了，并且准备在那儿开出两家新店。顾客在我们的门外排起了长队，并且要排2小时才能进店。我参加过许多星巴克新店的开业活动，却从未目睹过这样的景象。没有广告，没有促销，只因为是星巴克。 在新店开业前2天，我一如往常地和一群即将第一次穿上绿围裙的年轻人围坐在一起交流。为什么会有这样的传统？很多人认为星巴克是一家独特的，市场营销做得非常好的公司，认为星巴克是一家非常典型的善于市场营销的公司，然而，我们并不是一个致力于市场营销的公司，我们也不在乎市场营销。 我知道这么说我会惹来麻烦，我这样说的原因，是因为我们是基于门店体验而打造的品牌，是因为我们的伙伴和顾客之间的情感连接所带来的体验。 身穿绿围裙的伙伴就是星巴克的核心。所以，在南非，在约翰内斯堡，我想要和那些即将穿上代表我们品牌的绿围裙的年轻人坐在一起。围坐着的有50个年轻人，我请他们每一个人轮流分享自己的故事。我们沿着圆桌开始分享。他们告诉我的第一件事情是这个小城市的生活景象。 你们中有多少人去过南非？请举手示意。有谁，有多少人曾经去过小城市？我说过，我出身贫穷，曾经住在政府公屋里。当我到访这些小城市时，我感到很难受，为他们贫困的生活条件和艰难的居住环境而心碎。然而，这些年轻人却表现出如此的幸福、满足和快乐，因为他们的家人。当他们逐一讲述自己的故事时，我反复听到一个之前从未听过的非洲词语，他们很多人都讲到了这个词。 后来，我鼓起勇气问：这个词什么意思？Ubuntu，你们一直在说的这个词是什么意思？他们迫不及待地告诉我，“Ubuntu”是曼德拉曾经多次提及的一个词，意思是“我之存在，因为有你”。我之存在，因为有你。如果今天晚上你们要记住我演讲中的一个关键词，我希望你们记住“Ubuntu”，我之存在，因为有你。 这是一种无私，这是一种分享，这是对他人的责任感——近朱者赤，个人的价值因其身边的个人和团队而体现，最好的成功是与彼此分享。那是我第一次听到他们讲述“Ubuntu”的意思以及对于年轻人意味着什么，以及是如何地适用于星巴克。 今天上午，我与一部分星巴克中国的伙伴进行了面对面的交流。在星巴克，我们把员工称为伙伴，因为每个人都是公司的股东。他们有人也带来了父母。过去五年，我们每年都会举办这样的伙伴及家属交流会，会上不谈我们的销售额、利润率，也不谈盈利和股价，而是庆贺家人的团聚，表达我们对于伙伴家人的尊敬和感激之情。我们希望通过此举向伙伴的父母表达，我们将尽责尽力照顾他们的孩子。 在上午的交流会上，通过与这些伙伴和他们父母的分享，我们了解到其中一些伙伴们亲历了父母患病，甚至经历过父母的逝去。几个月前，我们对中国的伙伴做了一次调查，发现父母的身体健康是伙伴们最为关心的，他们也很担心自己的经济承担能力。今天上午的交流会上，我们都流泪了，因为我们听到了伙伴生活故事的分享，我们从他们的分享中感受到他们的勇气。看到自己的父母逐渐老去，他们十分担心自己的经济承担能力。 我们了解到在中国，你们会有一种可能是我们在美国没有的人生体验——你们每个人出于对自己的父母、对祖辈的尊敬而承担的巨大的责任。所以对于星巴克这样一个公司而言，当我们听到了伙伴们发出的请求，希望星巴克帮助他们，我们无法拒绝这种请求，这也是为什么今天有这样一个重要的发布，这是我们迈出的里程碑式的一步。 在过去47年的历史里，我们星巴克一直这样做。在中国，星巴克公司就不是一家美国公司，而是一家中国公司，这也是为什么我们提供住房津贴，我们也提供咖啡豆股，也是为什么与宋庆龄基金会有11年的合作伙伴关系，我们做所有这些，不是营销、不是新闻发布，而是因为这是星巴克公司价值文化的精髓所在。 我刚才谈到了，并不是所有商业决策都是出于经济利益的决策。我知道你们从学校毕业会加入一些企业工作，会有压力。这个压力就是赚钱的压力。如果是上市公司，你就会有季度的财务报告的压力。但是，如何打造一个可以持续的、长久的公司？我们要真正地眼光长远，要可持续地发展业务。这就好比，如果要在未来获得回报，你必须现在开始不断在你的账户上储蓄。而且每次你因为短期的压力而“提款”后，你就得存入更多。在过去的5年、10年、15年里，我们做了很多打破传统的决策，都是出于我们存在的目的。 大家有没有听过星巴克在美国做的一些反种族歧视的努力？在座各位有多少人读过新闻，知道我们在全球为1万名难民提供就业机会？我们为什么这样做？我们为星巴克每一位美国伙伴都提供亚利桑那州大学的4年免费教育奖学金。为什么？这是因为虽然我们是一家盈利性的上市公司，但是我们非常坚信，我们最核心的责任不仅是赚钱。应该这样说，我们是一家以人文精神为基础的绩效驱动型的公司。 每周我参加管理层会议时，都会想像有两把空着的椅子，一个坐着星巴克的顾客、一个坐着星巴克的伙伴。所以我们每天问自己，我们的战略、我们的决策是否能够让我们的顾客、让我们的伙伴真正地骄傲。如果不能让他们感到骄傲，也许我们不应该这样决策。如果这是一个短期的决策，它能够给我们带来更多的金钱，却不会让人们感到自豪，毫无疑问这是一个错误的事情，不能去做。 大家可能读了很多的教科书。仁慈、爱、怜悯心，人文精神，这些词汇也许不常在商学院的教科书里出现。但是这恰恰是我们打造一个长期、持久、繁荣的企业的基石——怜悯心、仁慈心、同理心和爱。 我想说，在绝大多数情况下，如果一家企业的文化和价值观不能够和这些传统美德融合，那他们将很难吸引并保留优秀的人才，人们不会认同并感觉自己属于一种比自己更伟大的存在，不会朝着一个方向一起努力。反过来想，你有很好的战略，你把价值作为你的指导原则，在企业打造信任和爱的文化，所有的员工都对自己的使命和工作有认同感，每一天他们的工作都能够实现一种价值，而领导层是一种服务型的领导层，那你几乎是不可战胜的。 看看1987年的星巴克，看看今天的星巴克，回首我们走过的历程，想想中国人以前是没有喝咖啡的传统的，不错，我们星巴克的咖啡是非常棒的，但是更棒的是我们和顾客之间的关系，这是我们把文化、价值观融合起来的结果。 在我们今天所处的环境中，一方面我们获取资本的过程要比以前容易很多，另一方面又存在着如此多的竞争，这么多杂音，要想真正成功绝非易事。赢和输之间的差别在哪里？那就是一个伟大的战略，和一个可持续发展的公司。 我自己就是一个很好的例子，我绝对不是这个屋子里最聪明的人。星巴克成功的一个驱动力量就是我们创造的、获得广泛认可和接受的文化和价值观。不管是在中国、日本、美国、欧洲还是墨西哥，在所有我们开展业务的市场，他们都接受我们的想法，我们也从他们身上学到很多，这才是成功的精髓所在。 我们都想过更好的生活，也想让我们的孩子过上更好的生活，我们想尽力让父母为我们感到自豪和骄傲，我们希望晚上回到家后能和父母、爱人、孩子分享我们今天所取得的成功。我们也希望第二天去工作时，抱着“Ubunto”的理念而全力以赴——我之存在，因为有你。 我一直在想，我们所遇到过的诸多挑战和我们克服它们获得成功的方法。很多次，人们都说星巴克不会成功。就以我们在中国的发展为例。 我们1999年开第一家店后，曾经好几年的时间是亏损的。当时很多美国人就说星巴克在中国肯定要失败，他们撑不住了。我们所到之处并不是都能一夜之间获得成功，而是通过对我们所坚信的核心目标和我们的热情坚持，以人为本，并认可你只能通过超越员工的期待，才能最终实现超越顾客的期待。 在很多情况下，对文化、价值观、指导原则的理解和认同会比商业战略本身更重要。或者这样说，即使是世界上最伟大的战略，如果缺乏对公司的信心，员工不信任领导、公司的使命和目标，那这个战略也是无法长久的。 从零开始经营一家公司就像培养一个孩子，最开始都有一个“印记期”。每个公司都有记忆，那些公司的早期行为都在设定一种企业的氛围。我想问问你们，有多少人听过“服务型领导力”这个词？这里聚集了全中国最聪明的学子，请你们给我一个答案。 （学生：为人民服务。学生：帮助其他人获得成功。） 你们有多少人愿意为一个服务型的企业领导工作？请举手。 有多少人认为领导者是天生的？有多少人认为领导者是后天造就的？请举手。 你们确实是最聪明的人。领导者是后天造就的，时势造英雄。生活的经验打造了领导者。而我们每个人的经历、故事，都是不一样的。领导力没有统一的风格，史蒂夫·乔布斯只有一个。所以你需要决定自己是一个什么样的人，并忠于自我。 说到领导力，在很多不同的教科书里对它都有不同的定义。其中一个特质我认为被低估了，就是脆弱，尤其是对于男性。人们一般很难想象一个男人在一群人面前展示自己的脆弱，承认错误、道歉。在过去这么多年里，我学到的是，你越脆弱，越多人会帮助你。 所以，脆弱也是领导力的一个特质，我希望你们能够去拥抱它、接受它。反过来说，作为一个企业的领导人，并不意味着你就能够对所有问题都找到答案。事实上，寻求帮助也是一种力量。你想打造一家好公司，你身边围绕着很多人，他们有很多想法，不同的价值观。有些人是专业技能人才，有些人可能比你还聪明，比你还了不起。但是所有人必须要有一个共同的价值观。 我相信在座的各位有你们自己的期许，有你们自己的目标，想让自己成为什么样的人，你们一定想让自己的父母为你们骄傲，因为你们正在一所世界级的名校求学。但是，当你们从这里走出去时，你们想要做什么？我想谈一谈所谓的“梦想”。在过去的三四十年里，我遇见过很多人都和我说，“我也有过关于咖啡的想法”，“我的想法比你还早”，是吗？那你们做了什么呢？ 我想说的是，不要让任何人对你说，你的梦想是不能实现的。我经常对年轻人说，不仅要有梦想，更要有宏大的梦想。把你的失望和失败，当做学习的机会，千万不要轻易的放弃和离开。这个房间里的每个人都有能力和知识成就一番大事。不管你的梦想是什么，坚持！坚韧！走别人没走过的路。当你最终成功时，记得回到你的初心——我之存在，因为有你。 我们这个房间里的每个人，都是因为受助于生命中的某人才能坐在这里，没有人是独自一路走到这里的。所以，让我们懂得回报。回报你的家庭、你的社区，整个社会。将这一价值观传递下去，不断地学习，保持好奇心。 再说一个故事。我是犹太人，一有机会就会去以色列。很多年来我都有一个精神导师，他传授了我很多伟大的智慧。每次我去见他，都尽可能的跟他在一起，聆听他的教诲。有一天他跟我说了一个故事，这不是一个关于犹太人的故事，而是一个关于人文精神的故事。他告诉我在大屠杀时期发生在德国发生的事。 当时，许多男女儿童像沙丁鱼罐头一样被塞进火车车厢，运送到死亡集中营。车厢里没有灯、没有食物、没有厕所，当他们到集中营时，门一打开，外面很冷很冷，但每六个人中只有一个人能拿到一条毯子。拿到毯子的人就要决定我是留着毯子自己用，还是和剩下的五个人共用这条毯子。虽然不是所有人都这么做，但是绝大部分拿到毯子的人都会和另外五个人共用这一个毯子。所以今天，我想对大家说，不管将来你们的人生道路上有何际遇、去向何方，尽量和你身边的人分享你的毯子。Ubuntu，我之存在，因为有你！ 谢谢大家！ （完） 演讲视频","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"演讲","slug":"演讲","permalink":"http://awenzeng.me/tags/演讲/"},{"name":"我之存在，因为有你","slug":"我之存在，因为有你","permalink":"http://awenzeng.me/tags/我之存在，因为有你/"},{"name":"霍华德*舒尔茨","slug":"霍华德-舒尔茨","permalink":"http://awenzeng.me/tags/霍华德-舒尔茨/"}]},{"title":"Android studio NDK编译及so库生成方法讲解","date":"2017-06-30T11:48:17.000Z","path":"2017/06/30/tech_android_ndk/","text":"前言：在Android开发的eclipse时代，想要开发NDK项目或生成so库，是非常蛋疼的，需要踩坑无数，方能生成so库；而如今Android Studio时代，开发jni C/C++项目，通过gradle的集成工具，那是一个爽。下面将会介绍两种利用AS和gradle开发NDK项目及生成so库的方式。 一.环境准备Android开发环境，Android-SDK，java-SDK,android-NDK相关环境（略：网上有许多） 1.安装完成之后如图： 2.在项目的gradle.properties文件中加上 android.useDeprecatedNdk = true 3.注意写好native接口和System.loadLibrary() 如：JNIUtil和MainActivity 12345678910111213141516171819202122232425262728public class JNIUtil &#123; private static JNIUtil instance = new JNIUtil(); public static JNIUtil getInstance() &#123; return instance; &#125; static &#123; System.loadLibrary(\"native-lib\"); &#125; public native String initData(); public native String getStringFromJni();&#125;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(JNIUtil.getInstance().getStringFromJni()); Log.i(\"笔沫拾光\",JNIUtil.getInstance().initData()); Toast.makeText(this,JNIUtil.getInstance().initData(),Toast.LENGTH_LONG); &#125;&#125; 二.两种编译和生成SO库的方式 1.手动编译C/C++文件和so库生成 i.生成C/C++文件 执行Build-&gt;Make Project，生成class文件，class文件的生成路径为： app_path/build/intermediates/classes/debug. javah生成c头文件 操作命令：javah -d jni -classpath SDK_android.jar;APP_classes lab.sodino.jnitest.MainActivity 代码示例： 1javah -d jni -classpath D:\\sdk\\platforms\\android-25\\android.jar;E:\\githup\\JniTest\\app\\build\\intermediates\\classes\\debug com.awen.jnitest.JNIUtil 生成头文件如图： ii.编辑C文件在main.c文件中实现头文件中的方法 代码示例C： 1234567891011#include \"com_awen_jnitest_JNIUtil.h\"JNIEXPORT jstring JNICALL Java_com_awen_jnitest_JNIUtil_initData(JNIEnv *env, jobject jObj)&#123; return (*env)-&gt;NewStringUTF(env, \"有梦为马，随处可栖。\");&#125;JNIEXPORT jstring JNICALL Java_com_awen_jnitest_JNIUtil_getStringFromJni (JNIEnv *env, jobject jObj)&#123; return (*env)-&gt;NewStringUTF(env, \"笔沫拾光\\nhttp://awenzeng.me/\");&#125; 代码示例C++： 1234567891011121314151617#include &lt;jni.h&gt;#ifdef __cplusplusextern \"C\" &#123;#endifjstring Java_com_awen_jnitest_JNIUtil_initData(JNIEnv *env, jobject jObj)&#123; return env-&gt;NewStringUTF(\"Hello NDK C++\");&#125;jstring Java_com_awen_jnitest_JNIUtil_getStringFromJni (JNIEnv *env, jobject jObj)&#123; return env-&gt;NewStringUTF(\"笔沫拾光\\nhttp://awenzeng.me/\");&#125;#ifdef __cplusplus&#125;#endif iii.修改build.gradle配置 代码示例： 1234ndk &#123; moduleName \"native-lib\" abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\"//控制so库生成兼容的平台&#125; 具体如图 iV.执行Build-&gt;Rebuild Project或Make Project，so库就会自动生成，具体如图： 2.Android studio配置工具编译和生成so库 i.Android studio工具配置 为了方便生成头文件和so文件，我们可以在Android Studio → External Tools中设置两个命令，分别来生成头文件和生成.so文件 javah: 具体配置代码： 12345678Program: $JDKPath$/bin/javahParameters:(具体参数参考第一种方法头文件的生成) -d jni -classpath D:\\sdk\\platforms\\android-25\\android.jar;E:\\githup\\JniTest\\app\\build\\intermediates\\classes\\debug $FileClass$Working $SourcepathEntry$\\..\\java ndk-build: 具体配置代码： 12345678Program: D:\\sdk\\ndk-bundle\\build\\ndk-build.cmdParameters: NDK_LIBS_OUT=$ModuleFileDir$/libs APP_ABI=armeabi-v7a,armeabi,x86Working$ModuleFileDir$\\src\\main ii.C/C++文件生成及so库生成 头文件.h的生成，具体操作如图： 具体步骤： 选中JNIUtil点击右键，显示如上图，选中NDK，点击javah，就会自动生成头文件，具体位置如图： .c文件生成和第一种一样（这里略） so库文件生成，点击ndk-build，生成库文件，具体如图： 到此，两种方法生成讲解完毕。 三.注意事项第一种方式 gradle.build中生成so库文件的平台可配置，如（具体如第一种方式build配置）：abiFilters “armeabi”, “armeabi-v7a”, “x86”//控制so库生成兼容的平台 生成的so库是在build文件中，需要手动copy到项目。 第二种方式 在ndk-build的配置中，so库文件生成平台也可以配置，如（具体如ndk-build配置）：APP_ABI=armeabi-v7a,armeabi,x86 so库文件的生成位置是可以配置的，自动生成到你配置的位置（这一点爽爆了，不用copy）,如（具体如ndk-build配置）：NDK_LIBS_OUT=$ModuleFileDir$/libs 可以随时修改C/C++代码，然后点击ndk-build生成so库，直接调试，非常方便。 源码地址，欢迎下载及Starhttps://github.com/awenzeng/JniTest 四.参考文献android studio NDK使用，编译c生成.so实践记录 Android Studio开发JNI工程 Android NDK Jni 开发C和C++的区别","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://awenzeng.me/tags/NDK/"},{"name":"JNI C/C++","slug":"JNI-C-C","permalink":"http://awenzeng.me/tags/JNI-C-C/"}]},{"title":"你本是一个肉体，是什么驱使你前行[1]","date":"2017-05-24T10:15:20.000Z","path":"2017/05/24/think_body_and_soul/","text":"文/笔沫拾光 你本是一个肉体，是什么驱使你前行。 你生来是一个肉体，三四岁时你有了意识，但还没有自己，不知道自己。 十四，十五岁，你开始反叛，开始认识到自己，开始追求自己。 长大了，成年了，你开始寻找自己，问自己：我是谁？我从哪里来？我要去那里？ 在路上，没有谁给过你答案。 书本，电影，旅行见闻。当你们相遇时，你会去思考，会去寻求答案。 有那么一段时间，你认为你找到了。 可当夜深人静，静卧回思，你又会发现，不，那不是的。 迷迷糊糊中，你又会问起，你本是一团肉体，是什么驱使你前行？ 是爱情，是家庭，是亲人，是兴趣，是理想，是金钱…是房子和车子，是权利，是安全感，是稳定,还是美丽的风景……","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"你本是一个肉体，是什么驱使你前行","slug":"你本是一个肉体，是什么驱使你前行","permalink":"http://awenzeng.me/tags/你本是一个肉体，是什么驱使你前行/"},{"name":"原创","slug":"原创","permalink":"http://awenzeng.me/tags/原创/"},{"name":"笔沫拾光","slug":"笔沫拾光","permalink":"http://awenzeng.me/tags/笔沫拾光/"}]},{"title":"SimpleDateFormat与Calendar使用详解","date":"2017-05-17T10:20:05.000Z","path":"2017/05/17/tech_java_date_format/","text":"1.SimpleDateFormat类Format语法 标识 标识代表意 G 年代标志符 y 年 M 月 d 日 h 时 在上午或下午 (1~12) H 时 在一天中 (0~23) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 W 一月中第几个星期 a 上午 / 下午 标记符 k 时 在一天中 (1~24) K 时 在上午或下午 (0~11) z 时区 Java代码示例：123456789101112131415 SimpleDateFormat myFmt = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); SimpleDateFormat myFmt1 = new SimpleDateFormat(\"yy/MM/dd HH:mm\"); SimpleDateFormat myFmt2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); SimpleDateFormat myFmt3 = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒 E \"); SimpleDateFormat myFmt4 = new SimpleDateFormat(\"一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区\"); Date now=new Date(); System.out.println(myFmt.format(now)); System.out.println(myFmt1.format(now)); System.out.println(myFmt2.format(now)); System.out.println(myFmt3.format(now)); System.out.println(myFmt4.format(now)); System.out.println(now.toGMTString()); System.out.println(now.toLocaleString()); System.out.println(now.toString());` 输出结果： 2017年05月23日 10时53分28秒17/05/23 10:532017-05-23 10:53:282017年05月23日 10时53分28秒 星期二一年中的第 143 天 一年中第21个星期 一月中第4个星期 在一天中10时 CST时区23 May 2017 02:53:28 GMT2017-5-23 10:53:28Tue May 23 10:53:28 CST 2017 2.Calendar类 Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 Java代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Calendar 取得当前时间的方法 // 初始化 (重置) Calendar 对象 calendar = Calendar.getInstance(); // 或者用 Date 来初始化 Calendar 对象 calendar.setTime(new Date()); // 显示年份 int year = calendar.get(Calendar.YEAR); System.out.println(\"year is = \" + String.valueOf(year)); // 显示月份 (从0开始, 实际显示要加一) int month = calendar.get(Calendar.MONTH); System.out.println(\"nth is = \" + (month + 1)); // 本周几 int week = calendar.get(Calendar.DAY_OF_WEEK); System.out.println(\"week is = \" + week); // 今年的第 N 天 int DAY_OF_YEAR = calendar.get(Calendar.DAY_OF_YEAR); System.out.println(\"DAY_OF_YEAR is = \" + DAY_OF_YEAR); // 本月第 N 天 int DAY_OF_MONTH = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"DAY_OF_MONTH = \" + String.valueOf(DAY_OF_MONTH)); // 3小时以后 calendar.add(Calendar.HOUR_OF_DAY, 3); int HOUR_OF_DAY = calendar.get(Calendar.HOUR_OF_DAY); System.out.println(\"HOUR_OF_DAY + 3 = \" + HOUR_OF_DAY); // 当前分钟数 int MINUTE = calendar.get(Calendar.MINUTE); System.out.println(\"MINUTE = \" + MINUTE); // 15 分钟以后 calendar.add(Calendar.MINUTE, 15); MINUTE = calendar.get(Calendar.MINUTE); System.out.println(\"MINUTE + 15 = \" + MINUTE); // 30分钟前 calendar.add(Calendar.MINUTE, -30); MINUTE = calendar.get(Calendar.MINUTE); System.out.println(\"MINUTE - 30 = \" + MINUTE); str = (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SS\")).format(calendar.getTime()); System.out.println(str); // 重置 Calendar 显示当前时间 calendar.setTime(new Date()); str = (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SS\")).format(calendar.getTime()); System.out.println(str); // 创建一个 Calendar 用于比较时间 Calendar calendarNew = Calendar.getInstance(); // 设定为 5 小时以前，后者大，显示 -1 calendarNew.add(Calendar.HOUR, -5); System.out.println(\"时间比较：\" + calendarNew.compareTo(calendar)); // 设定7小时以后，前者大，显示 1 calendarNew.add(Calendar.HOUR, +7); System.out.println(\"时间比较：\" + calendarNew.compareTo(calendar)); // 退回 2 小时，时间相同，显示 0 calendarNew.add(Calendar.HOUR, -2); System.out.println(\"时间比较：\" + calendarNew.compareTo(calendar)); 输出结果： year is = 2017nth is = 5week is = 3DAY_OF_YEAR is = 143DAY_OF_MONTH = 23HOUR_OF_DAY + 3 = 14MINUTE = 7MINUTE + 15 = 22MINUTE - 30 = 52时间比较：-1时间比较：-1时间比较：-1","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Java","slug":"Java","permalink":"http://awenzeng.me/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"http://awenzeng.me/tags/Java基础/"}]},{"title":"Android常用加解密算法","date":"2017-05-10T12:54:22.000Z","path":"2017/05/10/tech_android_encrypt_and_decode/","text":"数据安全，不管是对于企业还是个人都是十分重要。而作为一个移动开发者，我们更需要去考虑数据传输的安全性，去保护企业及个人信息安全。在Java,Android语言中，有许多的常用加解密算法，例如：对称加密算法AES,DES,3DES，非对称加密算法RSA,经典哈希算法MD5,SHA. 对称加密算法：加密秘钥和解密秘钥相同 例：AES,DES,3DES 非对称加密算法：有公钥和秘钥，公钥加密私钥解密，私钥加密公钥解密。例：RSA 哈希算法：加解密是不可逆的 例：MD5,SHA 常用加解密算法 1.AES算法(Advanced Encryption Standard 高级数据加密标准) AES：高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击 特点：密钥建立时间短、灵敏性好、内存需求低、安全性高 Java实现 1).生成秘钥1234KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");//密钥生成器keygen.init(128); //默认128，获得无政策权限后可为192或256SecretKey secretKey = keyGen.generateKey();//生成密钥byte[] key = secretKey.getEncoded();//密钥字节数组 2).AES加密1234SecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥Cipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类cipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式byte[] cipherByte = cipher.doFinal(data);//加密data 3).AES解密1234SecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥Cipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类cipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式byte[] cipherByte = cipher.doFinal(data);//解密data 2.DES算法(Data Encryption Standard 数据加密标准) DES：数据加密标准，是对称加密算法领域中的典型算法 特点：密钥偏短（56位）、生命周期短（避免被破解） Java实现 1）生成密钥1234KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");//密钥生成器keyGen.init(56);//初始化密钥生成器SecretKey secretKey = keyGen.generateKey();//生成密钥byte[] key = secretKey.getEncoded();//密钥字节数组 2）加密1234SecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥Cipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类cipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，加密模式byte[] cipherByte = cipher.doFinal(data);//加密data 3）解密1234SecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥Cipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类cipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式byte[] cipherByte = cipher.doFinal(data);//解密data 3.3DES算法(Triple DES、DESede，三重DES加密算法) 3DES：将密钥长度增至112位或168位，通过增加迭代次数提高安全性 缺点：处理速度较慢、密钥计算时间较长、加密效率不高 Java实现 1）生成密钥1234KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\");//密钥生成器keyGen.init(168); //可指定密钥长度为112或168，默认为168 SecretKey secretKey = keyGen.generateKey();//生成密钥byte[] key = secretKey.getEncoded();//密钥字节数组 2）3DES加密1234SecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥Cipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类cipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式byte[] cipherByte = cipher.doFinal(data);//加密data 3）3DES解密1234SecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥Cipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类cipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式byte[] cipherByte = cipher.doFinal(data);//解密data 4.RSA算法RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA算法原理如下：1.随机选择两个大质数p和q，p不等于q，计算N=pq；2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。4.销毁p和q。 1)生成秘钥 通过openssl工具生成RSA的公钥和私钥RSA密钥的生成与配置 2)获取公钥1234567891011121314151617181920212223private PublicKey getPublicKey()&#123; PublicKey publicKey = null; try &#123; InputStream in = RSAApp.instance.getResources().getAssets().open(\"rsa_public_key.pem\"); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String readLine = null; StringBuilder sb = new StringBuilder(); while ((readLine = br.readLine()) != null) &#123; if (readLine.charAt(0) == '-') &#123; continue; &#125; else &#123; sb.append(readLine); &#125; &#125; KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); byte[] buffer=Base64.decode(sb.toString()); EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); publicKey = keyFactory.generatePublic(keySpec); return publicKey; &#125; catch (Exception e) &#123; &#125; return publicKey;&#125; 3)获取私钥12345678910111213141516171819202122232425private PrivateKey getPrivateKey()&#123; PrivateKey privateKey = null; try &#123; InputStream in = RSAApp.instance.getResources().getAssets().open(\"pkcs8_rsa_private_key.pem\"); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String readLine = null; StringBuilder sb = new StringBuilder(); while ((readLine = br.readLine()) != null) &#123; if (readLine.charAt(0) == '-') &#123; continue; &#125; else &#123; sb.append(readLine); &#125; &#125; in.close(); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); byte[] buffer= Base64.decode(sb.toString()); EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(buffer); privateKey = keyFactory.generatePrivate(privateKeySpec); return privateKey; &#125; catch (Exception e) &#123; &#125; return privateKey; &#125; 4)公钥加密12345678910111213public String encode(String str) &#123; if (TextUtils.isEmpty(str)) &#123; return str; &#125; try &#123; Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); cipher.init(Cipher.ENCRYPT_MODE, getPublicKey()); byte[] enBytes = cipher.doFinal(str.getBytes()); return Base64.encode(enBytes); &#125; catch (Exception e) &#123; &#125; return str;&#125; 5)私钥解密1234567891011121314public String decode(String str) &#123; if (TextUtils.isEmpty(str)) &#123; return str; &#125; try &#123; Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); cipher.init(Cipher.DECRYPT_MODE, getPrivateKey()); byte[] base64 = Base64.decode(str); byte[] deBytes = cipher.doFinal(base64); return new String(deBytes, \"UTF-8\"); &#125; catch (Exception e) &#123; &#125; return \"\";&#125; 5.MD5算法MD5加密有哪些特点？ 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 MD5应用场景： 一致性验证 数字签名 安全访问认证 java加密12345678910111213141516171819202122public static String md5(String string) &#123; if (TextUtils.isEmpty(string)) &#123; return \"\"; &#125; MessageDigest md5 = null; try &#123; md5 = MessageDigest.getInstance(\"MD5\"); byte[] bytes = md5.digest(string.getBytes()); String result = \"\"; for (byte b : bytes) &#123; String temp = Integer.toHexString(b &amp; 0xff); if (temp.length() == 1) &#123; temp = \"0\" + temp; &#125; result += temp; &#125; return result; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; 参考文献Java利用DES/3DES/AES 三种算法分别实现对称加密Android数据加密之Rsa加密Android数据加密之Aes加密Android数据加密之Des加密Android数据加密之MD5加密 注意：不管是对称加密还是非对称加密，加密的填充方式也是十分重要的。 android系统的RSA实现填充方式是”RSA/None/NoPadding”，而标准JDK实现是”RSA/None/PKCS1Padding”,当与服务器交互时，需要注意加密的填充方式。 算法 密钥长度 默认密钥长度 工作模式 填充方式 DES 56 56 ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128 NoPadding、PKCS5Padding、ISO10126Padding 3DES 112、168 168 ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128 NoPadding、PKCS5Padding、ISO10126Padding AES 128、192、256 128 ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128 NoPadding、PKCS5Padding、ISO10126Padding","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"加解密算法","slug":"加解密算法","permalink":"http://awenzeng.me/tags/加解密算法/"}]},{"title":"中国历史","date":"2017-05-10T06:21:44.000Z","path":"2017/05/10/think_china_history_map/","text":"三皇五帝始，尧舜禹相传。夏商与西周，东周分两段。春秋和战国，一统秦两汉。三分魏蜀吴，二晋前后延。南北朝并立，隋唐五代传。宋元明清后，皇朝自此完。 1．夏（约前2070-1600年）210万，包括长江以北的湖北，河南，安徽，山东，河北，山西，京津和江苏，陕西的一部分 2．商（约前1600-1046年）320万，除上述土地外，还包括陕西江苏的剩余土地，辽宁，甘肃，湖南，浙江，重庆和四川的一部分 3．周（约前1046-221年）340万，基本与商差不多，在辽宁和重庆四川的范围更大 4．秦（前221-207年）360万，还包括整个宁夏并包括重庆全部和更大的几乎整个四川的土地，东晋各诸侯国的国土总合与西周基本相同 5．汉（前206-公元220年）在两汉最顶盛的时代，由西汉武帝和后人西汉宣帝、东汉光武帝、东汉明帝打下了惊人的国土。现在朝鲜的几乎全部，越南的北方。大半的新疆，包括中亚相当大的土地都在汉的西域都护府范围中，还有全部的四川和云贵的大片土地，辽宁的全部土地也在汉治下，和吉林的一片土地，内蒙也有相当大的土地在汉的治内，估约国土为1040万平方公里。东汉后期出现严重缩水，失去了云贵和内蒙的土地，新疆北部的土地也丧失殆尽，国土应为890万平方公里。 6．三国（220-280年）魏：530万平方公里，所有的长江以北的汉人地区和在新疆甚至中亚的土地，也包括朝鲜的少量土地和内蒙的土地；吴：240万平方公里，浙江，江西，福建，广东，海南，广西和越南北方。蜀：170万平方公里，湖南，四川，重庆，贵州，云南，和青海的一小部分，缅甸的极北方。 7．晋（265-420年）西晋的国土大小为920万平方公里。在云贵两地上略少于蜀的控制，在越南和朝鲜的土地缩小了。但略增加了内蒙的土地。 8．五胡十六国（304-439年） 9．南北朝（420-581年）国土总合约为935万平方公里，增加了几乎所有剩余的内蒙和部分外蒙的土地 10．隋（581-618年）国土为840万平方公里，突厥占领了甘肃和宁夏相当大的土地，云南和贵州也正走向独立，丧失了所有在越南和朝鲜的国土 11．唐（618-907年）强盛时的唐国土大的非常惊人，比现在中国少黑龙江和西藏与云南，多了中亚的大片土地，大半个蒙古国和俄贝加尔湖，共1240万平方公里，在数十年后竟缩为1030万平方公里，安史之乱后更是缩为800万平方公里，可谓史上巨大的缩水。 12．五代十国（907-979）国家太多，地图略 13．宋（960-1179年）国土为460万平方公里，与现在中国比没有新疆，甘肃，宁夏，内蒙，整个东北三省，青海和西藏，云贵和台湾。 12．元（1206-1368年）1680万平方公里，马克思列宁毛泽东都视其是中国的朝代，忽必烈也自称是中国之主。国土包括整个中国和蒙古，和俄罗斯西伯利亚的大片土地，当是中国古代史上的第一 13．明（1368-1644年）国土最大时，比现在少一小半西藏和大半新疆，内蒙古全部和东三省小半土地，俄罗斯极少土地。共710万平方公里。后来大为缩水，丧失西藏新疆和东北台湾，到灭亡时只剩下350万平方公里。 14．清（1616-1911年）国土1310万平方公里，整个中国和外蒙和俄罗斯及中亚的一些土地，论大小算是中国各朝代第二。 参考文献中国历史朝代顺序表中国各朝代历史地图世界历史发展视频","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"中国历史","slug":"中国历史","permalink":"http://awenzeng.me/tags/中国历史/"}]},{"title":"人生的意义","date":"2017-05-10T03:09:26.000Z","path":"2017/05/10/think_life_meaningful/","text":"文/笔沫拾光 如果你问我,人生有啥意义？我会说：人生毫无意义，所谓的人生意义需要自己去下定义，自己去寻找属于自己的人生意义。 人一生很短暂，平均也就八十多个春夏秋冬，也就三万多个小时；这一生，你想要怎样过活，必须由你自己来决定。 父母，亲人，他们也都不是你自己；他们的话，始终也只是建议，重点在于你。 你可以采纳吸收，也可以弃之不用。 我们每一个人，都是独一无二的，也都可以独立活出自己想要的生活。不需要过多的焦虑，跟随自己的内心，你的内心会告诉你答案。","tags":[{"name":"随想","slug":"随想","permalink":"http://awenzeng.me/tags/随想/"},{"name":"原创","slug":"原创","permalink":"http://awenzeng.me/tags/原创/"},{"name":"笔沫拾光","slug":"笔沫拾光","permalink":"http://awenzeng.me/tags/笔沫拾光/"},{"name":"人生的意义","slug":"人生的意义","permalink":"http://awenzeng.me/tags/人生的意义/"}]},{"title":"Android常用开源框架","date":"2017-05-03T12:14:42.000Z","path":"2017/05/03/tech_android_opensource_libs/","text":"从08年，第一部Android智能手机发布，到如今百花开放。从Android1.5(纸杯蛋糕)到现在Android7.0(牛轧糖),可以说，Android系统的变化是巨大的，不管是在开发，还是用户体验上都已变得成熟。经过9年的发展和互联网的开放精神，Github出现许多很不错的开源框架，如：retrofit,okhttp,Rxjava,RxAndroid,Glide,Litepal,EventBus,Butterknife,Loggger等等。 常用开源框架 1.简化网络操作框架(Retrofit) 项目描述：Retrofit是square公司推出的一个针对Android和Java类型安全的http客户端。 项目地址：https://github.com/square/retrofit 项目首页：http://square.github.io/retrofit/ 相关介绍：Retrofit介绍1，Retrofit介绍2 2.网络框架(okHttp) 项目描述：okHttp也是square公司推出一个处理网络请求轻量级框架。用于替代HttpUrlConnection和Apache HttpClient。 项目地址：https://github.com/square/okhttp 项目首页：http://square.github.io/okhttp/ 相关介绍：okHttp介绍1，okHttp介绍2 3.响应式编程框架(RxJava,RxAndroid) 项目描述：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。 项目地址：https://github.com/ReactiveX/RxJava，https://github.com/ReactiveX/RxAndroid 相关介绍：RxJava介绍1，RxJava介绍2 4.图片加载框架(Glide) 项目描述：一个很方便图片加载库(网络图片、本地图片，项目图片，gif图等等) 项目地址：https://github.com/bumptech/glide 相关介绍：Glide介绍1，Glide介绍2 5.发布/订阅事件框架(EventBus) 项目描述：是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。 项目首页：http://greenrobot.org/eventbus/ 项目地址：https://github.com/greenrobot/EventBus 相关介绍：EventBus介绍1，EventBus介绍2 6.事件绑定框架(ButterKnife) 项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。 项目地址：https://github.com/JakeWharton/butterknife 项目首页：http://jakewharton.github.io/butterknife/ 相关介绍：ButterKnife介绍 7.Log日志框架(Logger) 项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。 项目地址：https://github.com/orhanobut/logger 相关介绍：Logger介绍 8.数据库框架(LitelPal) 项目描述：是一款开源的Android数据库框架，采用了对象关系映射(ORM)的模式 项目地址：https://github.com/LitePalFramework/LitePal 相关介绍：LitelPal介绍 9.内存泄漏检测框架(LeakCanary) 项目描述：LeakCanary，它是一个Android和Java的内存泄露检测库，可以大幅度减少了开发中遇到的OOM问题。 项目地址：https://github.com/square/leakcanary 相关介绍：LeakCanary介绍 10.程序崩溃日志框架(ACRA) 项目描述：一个便于我们检测程序崩溃的框架 ACRA。又叫做 Application CrashReport for Android。 项目地址：https://github.com/ACRA/acra 相关介绍：ACRA用法详解","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"开源框架","slug":"开源框架","permalink":"http://awenzeng.me/tags/开源框架/"}]},{"title":"MVP模式学习及使用","date":"2017-04-11T10:41:32.000Z","path":"2017/04/11/tech_android_mvp/","text":"Google官方推出MVP模式有一段时间，MVP模式在android项目中使用也越来越广泛。作为一个Android开发人员，学会使用MVP模式，那也相当的重要。 一、什么是MVPMVP从MVC架构模式演化而来， MVC分别代表模型、视图和控制器，在Android中，定义Class类作为模型，Layout XML表示视图，而Activity用作控制器，这样一来，在Activity中充斥了大量代码，无论是从扩展性和重用性都无法达到理想的效果。所以个人认为，MVC分层在Android App开发中没有解决问题。而MVP解决了这个问题。 MVP即为Model、View和Presenter。Model表示模型，实现数据存储与业务逻辑；View表示视图，提供用户交互的接口；Presenter表示主导器，相当于MVC中的Controller但比Controller更灵活。MVP的关系如图所示。 从上图可以看出：A） View将功能委托给Presenter完成，Presenter调用Model完成业务功能与数据存储，并再次通过View更新UI； B） View和Model没有直接关联，无法相互调用； C） Presenter和View可以相互调用； D） Presenter调用Model完成业务功能。 MVP的优点：A） 各个层次之间的职责更加单一清晰； B） 很大程度上降低了代码的耦合度； C） 复用性大大提高； D） 面向接口编程，定义与实现分离，方便测试与维护； E） 代码更简洁。 MVP的缺点：A） 类变得更多了； B） 组件与组件之间的关系很复杂。 二、MVP的使用Google官方在推出MVP模式时，也给出了一个使用MVP模式的DEMO(TODO-MVP),通过此Demo，细细阅读，细细评味。相信，很快你就会掌握MVP模式的使用方法。 DEMO项目截图: 使用注意：虽然MVP模式非常的给力，但我们也不能乱用。需要结合我们项目实际情况来使用，对于功能比较简单的界面，其实MVC模式相对来说还是比较适合，毕竟功能简单，代码量也不会很多。对于功能比较复杂的界面，建议使用MVP模式来优化流程。 三、相关链接Android Architecture Blueprints 学习之 TODO-MVP（一）; Android Architecture Blueprints 学习之 TODO-MVP（二）; Android Architecture Blueprints 学习之 TODO-MVP（三）;","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Android基础","slug":"Android基础","permalink":"http://awenzeng.me/tags/Android基础/"},{"name":"MVP","slug":"MVP","permalink":"http://awenzeng.me/tags/MVP/"}]},{"title":"Android技术知识要点","date":"2017-04-11T07:38:32.000Z","path":"2017/04/11/tech-android-basic-point/","text":"一、项目中使用库工程问题要点1.库工程与主工程资源冲突问题 当运行有引用library工程的android工程时，android工具将会合并library工程与主工程的所有资源。如果一个资源ID将有可能在library工程之间或library工程、主工程之间都有定义，这时候优先级别高的资源ID将覆盖优先级别低的，使用资源时将使用有线级别最高的工程的资源。工程之间优先级别如何判定，请看下一条。 2.库工程之间以及主工程的资源使用上的优先级问题上图显示一个android工程引用了四个library工程，这四个library工程和主工程之间是有优先级之分的。android主工程的优先级别最高，四个library工程科举上图排序有上到下优先级别依次降低。library工程之间也可以手动排序，选择其中一个，点击up(提高优先级)或者down（降低优先级）。 3.库工程和主工程使用不同的android platform version问题主工程打包时，android sdk版本使用的是主工程。所以library工程使用的android sdk版本要不高于主工程的sdk版本。如果library工程sdk版本高于主工程，将不能通过编译。 二、自定义ViewGroup或Canvas获取绘制内容Bitmap 可以通过setDrawingCacheEnabled，然后再getDrawingCache(),但这个你得保证onDraw被调用。 从Canvas获取Bitmap(自定义View类似),例子： public Bitmap getBitmap() { Bitmap whiteBgBitmap = Bitmap.createBitmap(mBackgroundBitmap.getWidth(), mBackgroundBitmap.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(whiteBgBitmap); canvas.drawColor(Color.WHITE); canvas.drawBitmap(mBackgroundBitmap, 0, 0, null); return whiteBgBitmap; } 三、Https证书ctr(或cer)格式转bks格式 1.要生成bks证书，需要bcprov-ext-jdk15on-151.jar(下载地址） 2.cmd中输入以下命令; 输入例子 keytool -importcert -v -trustcacerts -alias xx -file E:\\bks\\xx.cer -keystore E:\\bks\\xx.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath E:\\bks\\bcprov-jdk15on-146.jar -storepass xxxxxx 注意: 1.注意命令中不能有换行 2.地址必须全地址 3.文件要符合Java命名规范 把证书复制到Android项目的asset(或raw)目录中，加载证书即可https访问。 Android加载证书https请求——Retrofit Https踩坑记录","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"}]},{"title":"Activity的启动模式","date":"2017-03-25T04:02:11.000Z","path":"2017/03/25/tech-android-act-start-mode/","text":"在Android中，当我们多次启动同一个Activity时，系统会创建多个实例，并把它们按照先进后出的原则一一放入任务栈中，当我们按back键时，就会有一个activity从任务栈顶移除，重复下去，直到任务栈为空，系统就会回收这个任务栈。但是这样以来，系统多次启动同一个Activity时就会重复创建多个实例，这种做法显然不合理，为了能够优化这个问题，Android提供四种启动模式来修改系统这一默认行为。 四种启动模式分别为： standard singleTop singleTask singleInstance 启动模式配置1&lt;activity android:name=\".Activity\" android:launchMode=\"启动模式\"&gt; Activity的四种启动模式 1.Standard-默认模式 默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。2.SingleTop-栈顶复用模式 可以有多个实例，但是不允许多个相同Activity叠加。三种情况： 1.如果当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法 2.当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例 3.当前栈中不存在该Activity的实例时，其行为同standard启动模式 应用场景:适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 3.SingleTask-栈内复用模式 只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。 如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。 应用场景:适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 4.SingleInstance-全局唯一模式 只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 应用场景: 适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。 Note：Activity的标签属性（taskAffinity)taskAffinity属性 每个Activity都有taskAffinity属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而任务栈也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。taskAffinity代码配置：1activity android:name=\".Activity\" android:launchMode=\"启动模式\" android:taskAffinity=\"任务栈名（如：包名）\"/&gt;","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://awenzeng.me/tags/Android/"},{"name":"Activity的启动模式","slug":"Activity的启动模式","permalink":"http://awenzeng.me/tags/Activity的启动模式/"}]},{"title":"学习网址","date":"2017-03-17T13:59:30.000Z","path":"2017/03/17/tech_study_website/","text":"技术学习网址 网址1 网址2 网址3 网址4 Markdown学习 Markdown语法学习 RxJava学习 Android组件化 Airbnb的Lottie动画开源框架 Lottie官网 MaterialDesign安卓开源库 常用框架源码解析 Recyclerview学习 视频播放器 节操视频播放器 Java基础 技术明星 昵称 博客 Github地址 GcsSloop http://www.gcssloop.com/ GcsSloop 陈宇明 http://blog.csdn.net/cym492224103 CymChad 郭霖 http://blog.csdn.net/guolin_blog/article/details/26365683 张鸿洋 http://blog.csdn.net/lmj623565791/article/details/45460089 秋百万 https://www.liaohuqiu.net/cn/ liaohuqiu 刘超 http://blog.csdn.net/qq_23547831?viewmode=contents yipianfengye 刘望舒 http://liuwangshu.cn/ henrymorgen","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"}]},{"title":"Rxjava学习总结","date":"2017-03-16T13:06:13.000Z","path":"2017/03/16/tech_rxjava_basic/","text":"1.RxJava基础详解-扔物线2.RxJava常用方法总结RxJava 的观察者模式 Observable.just(T…)方法 Observable.just()动画显示 Observable.from(T[])分发集合方法(图类似just()) Observable.map()直接变换 Observable.flatMap()平铺变换 3.RxJava线程调度1.RxJava线程控制 Observable.subscribeOn(Schedulers.io())指定被观察运行线程(订阅线程) Observable.observeOn(AndroidSchedulers.mainThread)指定观察者运行线程 Observable.doOnSubscribe(Schedulers.io())被观察者开始执行前调用 2.Schedulers介绍 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程（这是默认的）。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()，是RxAndroid 中一个对 RxJava 的轻量级扩展为了Android 的主线程提供 Scheduler，它指定的操作将在 Android 主线程运行。 4.结尾以上图片资源皆来至于 RxJava基础详解-扔物线","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"Rxjava","slug":"Rxjava","permalink":"http://awenzeng.me/tags/Rxjava/"},{"name":"Rxandroid","slug":"Rxandroid","permalink":"http://awenzeng.me/tags/Rxandroid/"},{"name":"响应式编程","slug":"响应式编程","permalink":"http://awenzeng.me/tags/响应式编程/"}]},{"title":" Hexo+Github从零搭建技术博客","date":"2017-03-12T10:41:32.000Z","path":"2017/03/12/tech_create_blog_record/","text":"【作为一名技术开发人员，搭建一个属于自己的博客，记录自己，沉淀自己，还是很重要的。】 年前给自己定一个目标：搭建博客，记录成长。之后，你懂的，就有下面的内容： 一、Hexo介绍、安装及实操Hexo平台搭建官网 通过hexo官网步骤，可以很快的搭建hexo平台。通过命令hexo s,然后，在浏览器中输入http://localhost:4000/ 网站显示如下： 二、Hexo主题选择通过Hexo官网，搭建的博客使用的主题为hexo自带的主题landscape,效果如上图。如果你希望你的博客更炫，更酷，推荐使用第三方的Hexo主题。主题选择：1.Next主题 2.Hexo主题集合(github) 3.Hexo主题集合(知乎) 主题配置： 1在hexo配置文件_config.yml中修改 theme: 主题名字（如：theme: landscape) 非Hexo主题(搭建网站可用) jekyll主题集合(官网) jekyll主题集合(github) WordPress主题集合 三、部署到Github上 Github官网 1.注册Github账号 2.创建Repository（格式为：github账号名.github.io） 1注意Repository的名字必须和账号名相同。比如Github账号是angelen10，那么应该创建的Repository的名字是：angelen10.github.io。 3.在hexo配置文件_config.yml中配置git路径 12345xxxx为github账户名deploy: type: git repository: git@github.com:xxxxx/xxxx.github.io.git branch: master 4.设置SSH keys绑定到你建的repository 设置SSH key官方教程 5.Hexo基本操作命令 12345678hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 四、相关链接搭建Hexo博客并部署到Github详细教程 如何搭建一个独立博客——简明Github Pages与Hexo教程 利用Github Page 搭建个人博客网站","tags":[{"name":"技术","slug":"技术","permalink":"http://awenzeng.me/tags/技术/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://awenzeng.me/tags/博客搭建/"}]}]