{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"source/assets/img/alipay.jpg","path":"assets/img/alipay.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/tech_android_basic_point_img01.png","path":"assets/img/tech_android_basic_point_img01.png","modified":0,"renderable":0},{"_id":"source/assets/img/avatar.ico","path":"assets/img/avatar.ico","modified":0,"renderable":0},{"_id":"source/assets/img/avatar.jpg","path":"assets/img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/think_history_04.png","path":"assets/img/think_history_04.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"source/assets/img/think_history_01.png","path":"assets/img/think_history_01.png","modified":0,"renderable":0},{"_id":"source/assets/img/think_life_meaningful.jpg","path":"assets/img/think_life_meaningful.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/think_history_02.png","path":"assets/img/think_history_02.png","modified":0,"renderable":0},{"_id":"source/assets/img/wechat_pay.jpg","path":"assets/img/wechat_pay.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"source/assets/img/think_history_03.png","path":"assets/img/think_history_03.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"source/assets/img/tech_create_blog_record_img01.png","path":"assets/img/tech_create_blog_record_img01.png","modified":0,"renderable":0},{"_id":"source/assets/img/think_poem_loushiming.jpg","path":"assets/img/think_poem_loushiming.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1493382070000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1493382070000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1493382070000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1493382070000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1493382070000},{"_id":"themes/yilia/_config.yml","hash":"ddd7579dc4c14839ae0ab40848430bdf7c3d9ae1","modified":1494387225540},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1493382070000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1493382070000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1493382070000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1493382070000},{"_id":"source/_posts/tech_android_opensource_libs.md","hash":"13dbac0fc882f37a6532b2e5a871cb610e523dd9","modified":1494058721128},{"_id":"source/_posts/tech_android_encrypt_and_decode.md","hash":"193b832fd32c94c32f1b49afc1bc9f0b796c73db","modified":1494421155824},{"_id":"source/_posts/tech_java_date_format.md","hash":"9971187367016408d732026b7474449a2c3fdfdd","modified":1495017452085},{"_id":"source/_posts/tech-android-basic-point.md","hash":"24f4c20c5de3c5c54f53b6c606f590e6750d530e","modified":1491898147437},{"_id":"source/_posts/tech_rxjava_basic.md","hash":"f16eddb11fb213c3329b94af7e3a70d2dbb9738c","modified":1494585241368},{"_id":"source/_posts/tech_android_mvp.md","hash":"c3d9c9b0400853e0e4476c81a514b746e9b23ecd","modified":1492081771939},{"_id":"source/_posts/tech_create_blog_record.md","hash":"f28dd61578b89ab87bb407cc2898e4a10ad592b9","modified":1492743948577},{"_id":"source/_posts/think_china_history_map.md","hash":"9402db2537c49edefc10d25f41e3e28a9bb8c9e1","modified":1494407332970},{"_id":"source/_posts/think_loushimin_poem.md","hash":"f23d2ad3abb586624ca580b794b1eec70787c1c3","modified":1493814361969},{"_id":"source/_posts/tech_study_website.md","hash":"9c7003bbaf295f8bb690032a6089db9e74e28bf8","modified":1494585472882},{"_id":"source/_posts/think_life_meaningful.md","hash":"1bac72a4a2e48ee2b1fc18ff5944e40bbd7f25fe","modified":1494387268417},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1493382070000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1493382070000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1493382070000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1493382070000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1493382070000},{"_id":"source/_posts/think_ship_poem.md","hash":"58b3ed145d7687b4a5f53a990a05e197f5a192af","modified":1493793719376},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1493382070000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1493382070000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493382070000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1493382070000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493382070000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1493382070000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1493382070000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1493382070000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1493382070000},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1493382070000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1493382070000},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1493382070000},{"_id":"source/_posts/travel_korea_jeju.md","hash":"a6b3d23dc7015dfa3cc44192b4d31e0e73adf5a3","modified":1489758921435},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1493382070000},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1493382070000},{"_id":"source/_posts/tech-android-act-start-mode.md","hash":"429ba53237bf0002a9d966b0c51eb79ee69fc0b1","modified":1494585300448},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1493382070000},{"_id":"source/assets/img/alipay.jpg","hash":"57969619aef137f74f304132efbff53fd76520f9","modified":1488968533033},{"_id":"source/assets/img/tech_android_basic_point_img01.png","hash":"cb517fb7c8e3edcb24a4e1c08843fd1896371447","modified":1491897030596},{"_id":"source/assets/img/avatar.ico","hash":"424b445f3d6099d55ff185558c606fb829c64d17","modified":1488970438397},{"_id":"source/assets/img/avatar.jpg","hash":"758951c8dc8b33fa2153970effaf45d70621c7a1","modified":1488970081761},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1493382070000},{"_id":"source/assets/img/think_history_04.png","hash":"932915e205e6ac9336f28f9ae4f7dc992cc35c7b","modified":1494397569332},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1493382070000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1493382070000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1493382070000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1493382070000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1493382070000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1493382070000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1493382070000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1493382070000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1493382070000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1493382070000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1493382070000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1493382070000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1493382070000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1493382070000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1493382070000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1493382070000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1493382070000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1493382070000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1493382070000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1493382070000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1493382070000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1493382070000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1493382070000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1493382070000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1493382070000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1493382070000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1493382070000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1493382070000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1493382070000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1493382070000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1493382070000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1493382070000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1493382070000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1493382070000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1493382070000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1493382070000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1493382070000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1493382070000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1493382070000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1493382070000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1493382070000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1493382070000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1493382070000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1493382070000},{"_id":"source/assets/img/think_history_01.png","hash":"5a5841ca104ffc5c68964973951a62efcd0e227f","modified":1494397451086},{"_id":"source/assets/img/think_life_meaningful.jpg","hash":"19557b80148e64041a4b04efabb61ce59397f6d7","modified":1494387000110},{"_id":"source/assets/img/think_history_02.png","hash":"a5bb13cb525b14f3900867fc291febe2cee0daa3","modified":1494397501259},{"_id":"source/assets/img/wechat_pay.jpg","hash":"68db0b45cc128145776978d7da942b33c492c0c1","modified":1490082740099},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1493382070000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1493382070000},{"_id":"source/assets/img/think_history_03.png","hash":"4a369fce006f63ddfc7227deb2a75b14902cb15a","modified":1494397548555},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1493382070000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1493382070000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"1ba1d4a4663eae37b1a2b75c47dfdff4fb3cbf52","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"7851d961ae172f521ba71e255fdc60f4ca0b45ed","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1493382070000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1493382070000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1493382070000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1493382070000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1493382070000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1493382070000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1493382070000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1493382070000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1493382070000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1493382070000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1493382070000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1493382070000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1493382070000},{"_id":"source/assets/img/tech_create_blog_record_img01.png","hash":"bf120707b14bc1695ca16b5e692159f673859b6d","modified":1491902430761},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1493382070000},{"_id":"source/assets/img/think_poem_loushiming.jpg","hash":"bd0dc61706e8586a3205b53fdf8d49567d9db069","modified":1493781135169},{"_id":"public/sitemap.xml","hash":"d819d228127568e00f08e9d5f742d0b7a006f579","modified":1495017494285},{"_id":"public/content.json","hash":"603703d8ec44bbbc8c328968dfcda5e8e042e2bc","modified":1495017494604},{"_id":"public/2017/05/10/tech_android_encrypt_and_decode/index.html","hash":"63ac954de2cb8d4dab6d5eb8b2293feb46c8f91a","modified":1495017494656},{"_id":"public/2017/05/10/think_china_history_map/index.html","hash":"863334a5d161b155f70c081fc94f2675c32b5734","modified":1495017494673},{"_id":"public/2017/05/10/think_life_meaningful/index.html","hash":"0640e9210028abab2a6ea15f301298c0ef61f7b6","modified":1495017494676},{"_id":"public/2017/05/03/tech_android_opensource_libs/index.html","hash":"952213d3dd5bedfcd7eedda10c9e81d747457847","modified":1495017494676},{"_id":"public/2017/05/03/think_loushimin_poem/index.html","hash":"6b340545c70f1df7d8af55357abaec0adb69bd69","modified":1495017494677},{"_id":"public/2017/04/11/tech_android_mvp/index.html","hash":"4c4cfabc931be64e1fff66f9511c7a5fc8e9a9ec","modified":1495017494677},{"_id":"public/2017/04/11/tech-android-basic-point/index.html","hash":"a7af12d8e49ed40e4b6a6938019eb2894e6a3cf6","modified":1495017494678},{"_id":"public/2017/03/25/tech-android-act-start-mode/index.html","hash":"3f775ea51f83c133850b0daaa9bfe75f544544e1","modified":1495017494678},{"_id":"public/2017/03/17/tech_study_website/index.html","hash":"a7c6561fa6fa8e44e49ab8984b3732c3a3074591","modified":1495017494678},{"_id":"public/2017/03/16/think_ship_poem/index.html","hash":"0dedfc8350c1b0a852629bef093cf219fbeab80e","modified":1495017494678},{"_id":"public/2017/03/16/travel_korea_jeju/index.html","hash":"e5fff9426417579876e9dbc618a35da1eb2b5f4f","modified":1495017494678},{"_id":"public/2017/03/16/tech_rxjava_basic/index.html","hash":"00270aa7d521e1f0a61f37346c98b85148d411cf","modified":1495017494678},{"_id":"public/2017/03/12/tech_create_blog_record/index.html","hash":"0f69e882cd07480376d167f598201debbf106457","modified":1495017494679},{"_id":"public/archives/index.html","hash":"ecc8719415d41413b2b32eb4708988e67552f9bd","modified":1495017494679},{"_id":"public/archives/2017/index.html","hash":"7eb8b75e6b732c9f09ac832d22905440f80f5a18","modified":1495017494679},{"_id":"public/archives/2017/03/index.html","hash":"602cc6f31267d21fc3106003b016d82950369c8c","modified":1495017494679},{"_id":"public/archives/2017/04/index.html","hash":"b8a19b22189c7c8b730c6046b03ca4625fea8d47","modified":1495017494679},{"_id":"public/archives/2017/05/index.html","hash":"bf2a5c90ad5fe09a206b7d3d7ea8722db56f2e5b","modified":1495017494679},{"_id":"public/index.html","hash":"d20d945f300811ba9d92fede9f43cc49cb88d406","modified":1495017494680},{"_id":"public/page/2/index.html","hash":"a489f61ebe08b19421b423e0181065385666975c","modified":1495017494680},{"_id":"public/tags/技术/index.html","hash":"28fdffc0fe0d93c79b005d81969d1b7608ffaa70","modified":1495017494680},{"_id":"public/tags/Android/index.html","hash":"8a781042fe10ab968f9a8544b820804fd801793b","modified":1495017494680},{"_id":"public/tags/开源框架/index.html","hash":"7d919343077a6b02cd226171757cca98c168aee4","modified":1495017494680},{"_id":"public/tags/加解密算法/index.html","hash":"9456ad2e151b9a4c9e5876b895d5a038c1808547","modified":1495017494680},{"_id":"public/tags/Rxjava/index.html","hash":"536fad0dfda18695dbe514826aeaa2bb09b66bef","modified":1495017494681},{"_id":"public/tags/Rxandroid/index.html","hash":"4e799a3d4ca7755af9d325f4be86ca4528134806","modified":1495017494681},{"_id":"public/tags/响应式编程/index.html","hash":"bf5ae1ca6b2a4a808ce0b5d118c48d7c05c4670f","modified":1495017494681},{"_id":"public/tags/Android基础/index.html","hash":"9618327a6b71d47c4761ae9088c1a2c7066c1cd8","modified":1495017494681},{"_id":"public/tags/MVP/index.html","hash":"0d0c95be2480319768f6bcf2da598dc36093973b","modified":1495017494681},{"_id":"public/tags/博客搭建/index.html","hash":"1e42af0b88edb6d07b9fc3dc086be3d2e9c65627","modified":1495017494681},{"_id":"public/tags/随想/index.html","hash":"1eb73733477f62f0be0254d05438191156776be0","modified":1495017494681},{"_id":"public/tags/中国历史/index.html","hash":"05696409c22e2c96897ddd828b36fc38062de081","modified":1495017494682},{"_id":"public/tags/诗/index.html","hash":"8b24e85d7d998b379f26883c8f3e2a26b4156392","modified":1495017494682},{"_id":"public/tags/陋室铭/index.html","hash":"ad2ff736393b63aac0bd003458270ac9e3e9322c","modified":1495017494682},{"_id":"public/tags/人生的意义/index.html","hash":"8d39f97a6cc0dbb54371afee01d4238c16e08f15","modified":1495017494682},{"_id":"public/tags/摄影/index.html","hash":"79e8d24642d5cb43f883237b284b68d25893086f","modified":1495017494682},{"_id":"public/tags/旅行/index.html","hash":"50856fed040da9d91ba121f69fd60d76ca9cf7b0","modified":1495017494682},{"_id":"public/baidusitemap.xml","hash":"b90dc75e8c164c09266d969ae42a69fcbe8b29d6","modified":1495017494682},{"_id":"public/2017/05/17/tech_java_date_format/index.html","hash":"e9e08c3eef3bffe07413a179c8ac9cb9ea799de9","modified":1495017494692},{"_id":"public/tags/Java/index.html","hash":"9f69b94f2d28f5aea8d2e69017b1cb91b3d92936","modified":1495017494692},{"_id":"public/tags/Java基础/index.html","hash":"7170aca80a6fc69b14c49130b8e3e0813b5745a8","modified":1495017494692},{"_id":"public/assets/img/avatar.ico","hash":"424b445f3d6099d55ff185558c606fb829c64d17","modified":1495017494701},{"_id":"public/assets/img/alipay.jpg","hash":"57969619aef137f74f304132efbff53fd76520f9","modified":1495017494701},{"_id":"public/assets/img/tech_android_basic_point_img01.png","hash":"cb517fb7c8e3edcb24a4e1c08843fd1896371447","modified":1495017494701},{"_id":"public/assets/img/avatar.jpg","hash":"758951c8dc8b33fa2153970effaf45d70621c7a1","modified":1495017494701},{"_id":"public/assets/img/think_history_04.png","hash":"932915e205e6ac9336f28f9ae4f7dc992cc35c7b","modified":1495017494701},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1495017494701},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1495017494701},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1495017494701},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1495017494701},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1495017494701},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1495017494701},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1495017494701},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1495017494702},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1495017494702},{"_id":"public/assets/img/think_history_01.png","hash":"5a5841ca104ffc5c68964973951a62efcd0e227f","modified":1495017494708},{"_id":"public/assets/img/think_history_02.png","hash":"a5bb13cb525b14f3900867fc291febe2cee0daa3","modified":1495017494711},{"_id":"public/assets/img/wechat_pay.jpg","hash":"68db0b45cc128145776978d7da942b33c492c0c1","modified":1495017494711},{"_id":"public/assets/img/think_life_meaningful.jpg","hash":"19557b80148e64041a4b04efabb61ce59397f6d7","modified":1495017494711},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1495017494732},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1495017494732},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1495017494732},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1495017494732},{"_id":"public/assets/img/think_history_03.png","hash":"4a369fce006f63ddfc7227deb2a75b14902cb15a","modified":1495017494732},{"_id":"public/assets/img/tech_create_blog_record_img01.png","hash":"bf120707b14bc1695ca16b5e692159f673859b6d","modified":1495017494732},{"_id":"public/assets/img/think_poem_loushiming.jpg","hash":"bd0dc61706e8586a3205b53fdf8d49567d9db069","modified":1495017494756}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"Android常用开源框架","date":"2017-05-03T12:14:42.000Z","comments":1,"_content":"---\n从08年，第一部Android智能手机发布，到如今百花开放。从Android1.5(纸杯蛋糕)到现在Android7.0(牛轧糖),可以说，Android系统的变化是巨大的，不管是在开发，还是用户体验上都已变得成熟。经过9年的发展和互联网的开放精神，[Github](https://github.com/)出现许多很不错的开源框架，如：retrofit,okhttp,Rxjava,RxAndroid,Glide,Litepal,EventBus,Butterknife,Loggger等等。\n\n\n# 常用开源框架\n-----\n\n**1.简化网络操作框架(Retrofit)**\n\n项目描述：Retrofit是square公司推出的一个针对Android和Java类型安全的http客户端。\n\n* 项目地址：[https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n* 项目首页：[http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n* 相关介绍：[Retrofit介绍1](http://www.jianshu.com/p/1ef0ba0bccc6)，[Retrofit介绍2](http://www.jianshu.com/p/94ca8a284ebb)\n\n**2.网络框架(okHttp)**\n\n项目描述：okHttp也是square公司推出一个处理网络请求轻量级框架。用于替代HttpUrlConnection和Apache HttpClient。\n\n* 项目地址：[https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n* 项目首页：[http://square.github.io/okhttp/](http://square.github.io/okhttp/)\n\n* 相关介绍：[okHttp介绍1](http://blog.csdn.net/lmj623565791/article/details/47911083)，[okHttp介绍2](http://www.jianshu.com/p/ca8a982a116b)\n<!-- more -->\n**3.响应式编程框架(RxJava,RxAndroid)**\n\n项目描述：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。\n\n* 项目地址：[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)，[https://github.com/ReactiveX/RxAndroid ](https://github.com/ReactiveX/RxAndroid)\n\n* 相关介绍：[RxJava介绍1](http://gank.io/post/560e15be2dca930e00da1083)，[RxJava介绍2](http://blog.csdn.net/caihongdao123/article/details/51897793)\n\n**4.图片加载框架(Glide)**\n\n项目描述：一个很方便图片加载库(网络图片、本地图片，项目图片，gif图等等)\n\n* 项目地址：[https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n* 相关介绍：[Glide介绍1](http://www.cnblogs.com/whoislcj/p/5558168.html)，[Glide介绍2](http://www.jianshu.com/p/4a3177b57949)\n\n**5.发布/订阅事件框架(EventBus)**\n\n项目描述：是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。\n\n* 项目首页：[http://greenrobot.org/eventbus/](http://greenrobot.org/eventbus/)\n\n* 项目地址：[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n* 相关介绍：[EventBus介绍1](http://blog.csdn.net/harvic880925/article/details/40660137)，[EventBus介绍2](http://blog.csdn.net/harvic880925/article/details/40787203)\n\n**6.事件绑定框架(ButterKnife)**\n\n项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。\n\n* 项目地址：[https://github.com/JakeWharton/butterknife](https://github.com/JakeWharton/butterknife)\n\n* 项目首页：[http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)\n\n* 相关介绍：[ButterKnife介绍](http://www.jianshu.com/p/9ad21e548b69)\n\n**7.Log日志框架(Logger)**\n\n项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。\n\n* 项目地址：[https://github.com/orhanobut/logger](https://github.com/orhanobut/logger)\n\n* 相关介绍：[Logger介绍](http://blog.csdn.net/lvwenbo0107/article/details/52126076)\n\n**8.数据库框架(LitelPal)**\n\n项目描述：是一款开源的Android数据库框架，采用了对象关系映射(ORM)的模式\n\n* 项目地址：[https://github.com/LitePalFramework/LitePal](https://github.com/LitePalFramework/LitePal)\n\n* 相关介绍：[LitelPal介绍](http://www.jianshu.com/p/557682e0a9f0)\n\n\n\n","source":"_posts/tech_android_opensource_libs.md","raw":"---\nlayout: post\ntitle: \"Android常用开源框架\"\ndate: 5/3/2017 8:14:42 PM \ncomments: true\ntags: \n\t- 技术 \n\t- Android\n\t- 开源框架\n---\n---\n从08年，第一部Android智能手机发布，到如今百花开放。从Android1.5(纸杯蛋糕)到现在Android7.0(牛轧糖),可以说，Android系统的变化是巨大的，不管是在开发，还是用户体验上都已变得成熟。经过9年的发展和互联网的开放精神，[Github](https://github.com/)出现许多很不错的开源框架，如：retrofit,okhttp,Rxjava,RxAndroid,Glide,Litepal,EventBus,Butterknife,Loggger等等。\n\n\n# 常用开源框架\n-----\n\n**1.简化网络操作框架(Retrofit)**\n\n项目描述：Retrofit是square公司推出的一个针对Android和Java类型安全的http客户端。\n\n* 项目地址：[https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n* 项目首页：[http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n* 相关介绍：[Retrofit介绍1](http://www.jianshu.com/p/1ef0ba0bccc6)，[Retrofit介绍2](http://www.jianshu.com/p/94ca8a284ebb)\n\n**2.网络框架(okHttp)**\n\n项目描述：okHttp也是square公司推出一个处理网络请求轻量级框架。用于替代HttpUrlConnection和Apache HttpClient。\n\n* 项目地址：[https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n* 项目首页：[http://square.github.io/okhttp/](http://square.github.io/okhttp/)\n\n* 相关介绍：[okHttp介绍1](http://blog.csdn.net/lmj623565791/article/details/47911083)，[okHttp介绍2](http://www.jianshu.com/p/ca8a982a116b)\n<!-- more -->\n**3.响应式编程框架(RxJava,RxAndroid)**\n\n项目描述：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。\n\n* 项目地址：[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)，[https://github.com/ReactiveX/RxAndroid ](https://github.com/ReactiveX/RxAndroid)\n\n* 相关介绍：[RxJava介绍1](http://gank.io/post/560e15be2dca930e00da1083)，[RxJava介绍2](http://blog.csdn.net/caihongdao123/article/details/51897793)\n\n**4.图片加载框架(Glide)**\n\n项目描述：一个很方便图片加载库(网络图片、本地图片，项目图片，gif图等等)\n\n* 项目地址：[https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n* 相关介绍：[Glide介绍1](http://www.cnblogs.com/whoislcj/p/5558168.html)，[Glide介绍2](http://www.jianshu.com/p/4a3177b57949)\n\n**5.发布/订阅事件框架(EventBus)**\n\n项目描述：是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。\n\n* 项目首页：[http://greenrobot.org/eventbus/](http://greenrobot.org/eventbus/)\n\n* 项目地址：[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n* 相关介绍：[EventBus介绍1](http://blog.csdn.net/harvic880925/article/details/40660137)，[EventBus介绍2](http://blog.csdn.net/harvic880925/article/details/40787203)\n\n**6.事件绑定框架(ButterKnife)**\n\n项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。\n\n* 项目地址：[https://github.com/JakeWharton/butterknife](https://github.com/JakeWharton/butterknife)\n\n* 项目首页：[http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)\n\n* 相关介绍：[ButterKnife介绍](http://www.jianshu.com/p/9ad21e548b69)\n\n**7.Log日志框架(Logger)**\n\n项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。\n\n* 项目地址：[https://github.com/orhanobut/logger](https://github.com/orhanobut/logger)\n\n* 相关介绍：[Logger介绍](http://blog.csdn.net/lvwenbo0107/article/details/52126076)\n\n**8.数据库框架(LitelPal)**\n\n项目描述：是一款开源的Android数据库框架，采用了对象关系映射(ORM)的模式\n\n* 项目地址：[https://github.com/LitePalFramework/LitePal](https://github.com/LitePalFramework/LitePal)\n\n* 相关介绍：[LitelPal介绍](http://www.jianshu.com/p/557682e0a9f0)\n\n\n\n","slug":"tech_android_opensource_libs","published":1,"updated":"2017-05-06T08:18:41.128Z","photos":[],"link":"","_id":"cj2sutc4a0000v0lkxazdsm56","content":"<hr>\n<p>从08年，第一部Android智能手机发布，到如今百花开放。从Android1.5(纸杯蛋糕)到现在Android7.0(牛轧糖),可以说，Android系统的变化是巨大的，不管是在开发，还是用户体验上都已变得成熟。经过9年的发展和互联网的开放精神，<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a>出现许多很不错的开源框架，如：retrofit,okhttp,Rxjava,RxAndroid,Glide,Litepal,EventBus,Butterknife,Loggger等等。</p>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><hr>\n<p><strong>1.简化网络操作框架(Retrofit)</strong></p>\n<p>项目描述：Retrofit是square公司推出的一个针对Android和Java类型安全的http客户端。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"external\">https://github.com/square/retrofit</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">http://square.github.io/retrofit/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/1ef0ba0bccc6\" target=\"_blank\" rel=\"external\">Retrofit介绍1</a>，<a href=\"http://www.jianshu.com/p/94ca8a284ebb\" target=\"_blank\" rel=\"external\">Retrofit介绍2</a></p>\n</li>\n</ul>\n<p><strong>2.网络框架(okHttp)</strong></p>\n<p>项目描述：okHttp也是square公司推出一个处理网络请求轻量级框架。用于替代HttpUrlConnection和Apache HttpClient。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">https://github.com/square/okhttp</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"external\">http://square.github.io/okhttp/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47911083\" target=\"_blank\" rel=\"external\">okHttp介绍1</a>，<a href=\"http://www.jianshu.com/p/ca8a982a116b\" target=\"_blank\" rel=\"external\">okHttp介绍2</a></p>\n<a id=\"more\"></a>\n<p><strong>3.响应式编程框架(RxJava,RxAndroid)</strong></p>\n</li>\n</ul>\n<p>项目描述：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">https://github.com/ReactiveX/RxJava</a>，<a href=\"https://github.com/ReactiveX/RxAndroid\" target=\"_blank\" rel=\"external\">https://github.com/ReactiveX/RxAndroid </a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">RxJava介绍1</a>，<a href=\"http://blog.csdn.net/caihongdao123/article/details/51897793\" target=\"_blank\" rel=\"external\">RxJava介绍2</a></p>\n</li>\n</ul>\n<p><strong>4.图片加载框架(Glide)</strong></p>\n<p>项目描述：一个很方便图片加载库(网络图片、本地图片，项目图片，gif图等等)</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">https://github.com/bumptech/glide</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.cnblogs.com/whoislcj/p/5558168.html\" target=\"_blank\" rel=\"external\">Glide介绍1</a>，<a href=\"http://www.jianshu.com/p/4a3177b57949\" target=\"_blank\" rel=\"external\">Glide介绍2</a></p>\n</li>\n</ul>\n<p><strong>5.发布/订阅事件框架(EventBus)</strong></p>\n<p>项目描述：是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>\n<ul>\n<li><p>项目首页：<a href=\"http://greenrobot.org/eventbus/\" target=\"_blank\" rel=\"external\">http://greenrobot.org/eventbus/</a></p>\n</li>\n<li><p>项目地址：<a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/greenrobot/EventBus</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/harvic880925/article/details/40660137\" target=\"_blank\" rel=\"external\">EventBus介绍1</a>，<a href=\"http://blog.csdn.net/harvic880925/article/details/40787203\" target=\"_blank\" rel=\"external\">EventBus介绍2</a></p>\n</li>\n</ul>\n<p><strong>6.事件绑定框架(ButterKnife)</strong></p>\n<p>项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/JakeWharton/butterknife\" target=\"_blank\" rel=\"external\">https://github.com/JakeWharton/butterknife</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://jakewharton.github.io/butterknife/\" target=\"_blank\" rel=\"external\">http://jakewharton.github.io/butterknife/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/9ad21e548b69\" target=\"_blank\" rel=\"external\">ButterKnife介绍</a></p>\n</li>\n</ul>\n<p><strong>7.Log日志框架(Logger)</strong></p>\n<p>项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/orhanobut/logger\" target=\"_blank\" rel=\"external\">https://github.com/orhanobut/logger</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/lvwenbo0107/article/details/52126076\" target=\"_blank\" rel=\"external\">Logger介绍</a></p>\n</li>\n</ul>\n<p><strong>8.数据库框架(LitelPal)</strong></p>\n<p>项目描述：是一款开源的Android数据库框架，采用了对象关系映射(ORM)的模式</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/LitePalFramework/LitePal\" target=\"_blank\" rel=\"external\">https://github.com/LitePalFramework/LitePal</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/557682e0a9f0\" target=\"_blank\" rel=\"external\">LitelPal介绍</a></p>\n</li>\n</ul>\n","excerpt":"<hr>\n<p>从08年，第一部Android智能手机发布，到如今百花开放。从Android1.5(纸杯蛋糕)到现在Android7.0(牛轧糖),可以说，Android系统的变化是巨大的，不管是在开发，还是用户体验上都已变得成熟。经过9年的发展和互联网的开放精神，<a href=\"https://github.com/\">Github</a>出现许多很不错的开源框架，如：retrofit,okhttp,Rxjava,RxAndroid,Glide,Litepal,EventBus,Butterknife,Loggger等等。</p>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><hr>\n<p><strong>1.简化网络操作框架(Retrofit)</strong></p>\n<p>项目描述：Retrofit是square公司推出的一个针对Android和Java类型安全的http客户端。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/square/retrofit\">https://github.com/square/retrofit</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://square.github.io/retrofit/\">http://square.github.io/retrofit/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/1ef0ba0bccc6\">Retrofit介绍1</a>，<a href=\"http://www.jianshu.com/p/94ca8a284ebb\">Retrofit介绍2</a></p>\n</li>\n</ul>\n<p><strong>2.网络框架(okHttp)</strong></p>\n<p>项目描述：okHttp也是square公司推出一个处理网络请求轻量级框架。用于替代HttpUrlConnection和Apache HttpClient。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/square/okhttp\">https://github.com/square/okhttp</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://square.github.io/okhttp/\">http://square.github.io/okhttp/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47911083\">okHttp介绍1</a>，<a href=\"http://www.jianshu.com/p/ca8a982a116b\">okHttp介绍2</a></p>","more":"<p><strong>3.响应式编程框架(RxJava,RxAndroid)</strong></p>\n</li>\n</ul>\n<p>项目描述：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/ReactiveX/RxJava\">https://github.com/ReactiveX/RxJava</a>，<a href=\"https://github.com/ReactiveX/RxAndroid\">https://github.com/ReactiveX/RxAndroid </a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">RxJava介绍1</a>，<a href=\"http://blog.csdn.net/caihongdao123/article/details/51897793\">RxJava介绍2</a></p>\n</li>\n</ul>\n<p><strong>4.图片加载框架(Glide)</strong></p>\n<p>项目描述：一个很方便图片加载库(网络图片、本地图片，项目图片，gif图等等)</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.cnblogs.com/whoislcj/p/5558168.html\">Glide介绍1</a>，<a href=\"http://www.jianshu.com/p/4a3177b57949\">Glide介绍2</a></p>\n</li>\n</ul>\n<p><strong>5.发布/订阅事件框架(EventBus)</strong></p>\n<p>项目描述：是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>\n<ul>\n<li><p>项目首页：<a href=\"http://greenrobot.org/eventbus/\">http://greenrobot.org/eventbus/</a></p>\n</li>\n<li><p>项目地址：<a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/harvic880925/article/details/40660137\">EventBus介绍1</a>，<a href=\"http://blog.csdn.net/harvic880925/article/details/40787203\">EventBus介绍2</a></p>\n</li>\n</ul>\n<p><strong>6.事件绑定框架(ButterKnife)</strong></p>\n<p>项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/JakeWharton/butterknife\">https://github.com/JakeWharton/butterknife</a></p>\n</li>\n<li><p>项目首页：<a href=\"http://jakewharton.github.io/butterknife/\">http://jakewharton.github.io/butterknife/</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/9ad21e548b69\">ButterKnife介绍</a></p>\n</li>\n</ul>\n<p><strong>7.Log日志框架(Logger)</strong></p>\n<p>项目描述：是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/orhanobut/logger\">https://github.com/orhanobut/logger</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://blog.csdn.net/lvwenbo0107/article/details/52126076\">Logger介绍</a></p>\n</li>\n</ul>\n<p><strong>8.数据库框架(LitelPal)</strong></p>\n<p>项目描述：是一款开源的Android数据库框架，采用了对象关系映射(ORM)的模式</p>\n<ul>\n<li><p>项目地址：<a href=\"https://github.com/LitePalFramework/LitePal\">https://github.com/LitePalFramework/LitePal</a></p>\n</li>\n<li><p>相关介绍：<a href=\"http://www.jianshu.com/p/557682e0a9f0\">LitelPal介绍</a></p>\n</li>\n</ul>"},{"layout":"post","title":"Android常用加解密算法","date":"2017-05-10T12:54:22.000Z","comments":1,"_content":"---\n数据安全，不管是对于企业还是个人都是十分重要。而作为一个移动开发者，我们更需要去考虑数据传输的安全性，去保护企业及个人信息安全。在Java,Android语言中，有许多的常用加解密算法，例如：对称加密算法AES,DES,3DES，非对称加密算法RSA,经典哈希算法MD5,SHA.\n\n>对称加密算法：加密秘钥和解密秘钥相同 例：AES,DES,3DES\n>\n>非对称加密算法：有公钥和秘钥，公钥加密私钥解密，私钥加密公钥解密。例：RSA\n>\n>哈希算法：加解密是不可逆的 例：MD5,SHA\n\n\n\n# 常用加解密算法\n---\n\n# 1.AES算法(Advanced Encryption Standard 高级数据加密标准)\n\n- AES：高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击 \n\n- 特点：密钥建立时间短、灵敏性好、内存需求低、安全性高 \n\n- Java实现\n\n1).生成秘钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");//密钥生成器\nkeygen.init(128);  //默认128，获得无政策权限后可为192或256\nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n<!-- more -->\n2).AES加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3).AES解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n\n# 2.DES算法(Data Encryption Standard 数据加密标准)\n- DES：数据加密标准，是对称加密算法领域中的典型算法 \n- 特点：密钥偏短（56位）、生命周期短（避免被破解） \n- Java实现\n\n1）生成密钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");//密钥生成器\nkeyGen.init(56);//初始化密钥生成器\nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n2）加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，加密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3）解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n\n# 3.3DES算法(Triple DES、DESede，三重DES加密算法)\n- 3DES：将密钥长度增至112位或168位，通过增加迭代次数提高安全性 \n- 缺点：处理速度较慢、密钥计算时间较长、加密效率不高 \n- Java实现\n\n1）生成密钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\");//密钥生成器\nkeyGen.init(168);  //可指定密钥长度为112或168，默认为168   \nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n\n2）3DES加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3）3DES解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n# 4.RSA算法\nRSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。\n> RSA算法原理如下：\n>1.随机选择两个大质数p和q，p不等于q，计算N=pq； \n>2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。 \n>3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。\n>4.销毁p和q。\n\n1)生成秘钥\n\n通过openssl工具生成RSA的公钥和私钥\n[RSA密钥的生成与配置](http://blog.csdn.net/tsuliuchao/article/details/8447690)\n\n2)获取公钥\n```java\n    private PublicKey getPublicKey(){\n        PublicKey publicKey = null;\n        try {\n            InputStream in =  RSAApp.instance.getResources().getAssets().open(\"rsa_public_key.pem\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                if (readLine.charAt(0) == '-') {\n                    continue;\n                } else {\n                    sb.append(readLine);\n                }\n            }\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            byte[] buffer=Base64.decode(sb.toString());\n            EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);\n            publicKey = keyFactory.generatePublic(keySpec);\n            return publicKey;\n        } catch (Exception e) {\n        }\n        return publicKey;\n    }\n```\n\n3)获取私钥\n```java\n private PrivateKey getPrivateKey(){\n        PrivateKey privateKey = null;\n        try {\n            InputStream in = RSAApp.instance.getResources().getAssets().open(\"pkcs8_rsa_private_key.pem\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                if (readLine.charAt(0) == '-') {\n                    continue;\n                } else {\n                    sb.append(readLine);\n                }\n            }\n            in.close();\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            byte[] buffer= Base64.decode(sb.toString());\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(buffer);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n            return privateKey;\n\n        } catch (Exception e) {\n        }\n        return privateKey;\n    }\n```\n\n4)公钥加密\n```java\n    public String encode(String str) {\n        if (TextUtils.isEmpty(str)) {\n            return str;\n        }\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, getPublicKey());\n            byte[] enBytes = cipher.doFinal(str.getBytes());\n            return Base64.encode(enBytes);\n        } catch (Exception e) {\n        }\n        return str;\n    }\n```\n\n5)私钥解密\n```java\n    public String decode(String str) {\n        if (TextUtils.isEmpty(str)) {\n            return str;\n        }\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, getPrivateKey());\n            byte[] base64 = Base64.decode(str);\n            byte[] deBytes = cipher.doFinal(base64);\n            return new String(deBytes, \"UTF-8\");\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n```\n\n# 5.MD5算法\n**MD5加密有哪些特点？**\n\n- 压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n- 容易计算：从原数据计算出MD5值很容易。\n- 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。\n- 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。\n\n**MD5应用场景：**\n\n- 一致性验证\n- 数字签名\n- 安全访问认证\n\n**java加密**\n```java\n public static String md5(String string) {\n        if (TextUtils.isEmpty(string)) {\n            return \"\";\n        }\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = md5.digest(string.getBytes());\n            String result = \"\";\n            for (byte b : bytes) {\n                String temp = Integer.toHexString(b & 0xff);\n                if (temp.length() == 1) {\n                    temp = \"0\" + temp;\n                }\n                result += temp;\n            }\n            return result;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n```\n\n# 参考文献\n[Java利用DES/3DES/AES 三种算法分别实现对称加密](http://blog.csdn.net/smartbetter/article/details/54017759)\n[Android数据加密之Rsa加密](http://www.cnblogs.com/whoislcj/p/5470095.html)\n[Android数据加密之Aes加密](http://www.cnblogs.com/whoislcj/p/5473030.html)\n[Android数据加密之Des加密](http://www.cnblogs.com/whoislcj/p/5580950.html)\n[Android数据加密之MD5加密](http://www.cnblogs.com/whoislcj/p/5885006.html)\n\n>注意：不管是对称加密还是非对称加密，加密的填充方式也是十分重要的。\n>\n>android系统的RSA实现填充方式是\"RSA/None/NoPadding\"，而标准JDK实现是\"RSA/None/PKCS1Padding\",当与服务器交互时，需要注意加密的填充方式。\n\n| 算法 | 密钥长度 | 默认密钥长度 | 工作模式 | 填充方式 |\n| :-----: | :----: | :---------: | :---: | :---: | \n| DES | 56 |  56    |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n| 3DES| 112、168 |  168   |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n| AES | 128、192、256   |  128  |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n\n","source":"_posts/tech_android_encrypt_and_decode.md","raw":"---\nlayout: post\ntitle: \"Android常用加解密算法\"\ndate: 5/10/2017 8:54:22 PM \ncomments: true\ntags: \n\t- 技术 \n\t- Android\n\t- 加解密算法\n---\n---\n数据安全，不管是对于企业还是个人都是十分重要。而作为一个移动开发者，我们更需要去考虑数据传输的安全性，去保护企业及个人信息安全。在Java,Android语言中，有许多的常用加解密算法，例如：对称加密算法AES,DES,3DES，非对称加密算法RSA,经典哈希算法MD5,SHA.\n\n>对称加密算法：加密秘钥和解密秘钥相同 例：AES,DES,3DES\n>\n>非对称加密算法：有公钥和秘钥，公钥加密私钥解密，私钥加密公钥解密。例：RSA\n>\n>哈希算法：加解密是不可逆的 例：MD5,SHA\n\n\n\n# 常用加解密算法\n---\n\n# 1.AES算法(Advanced Encryption Standard 高级数据加密标准)\n\n- AES：高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击 \n\n- 特点：密钥建立时间短、灵敏性好、内存需求低、安全性高 \n\n- Java实现\n\n1).生成秘钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");//密钥生成器\nkeygen.init(128);  //默认128，获得无政策权限后可为192或256\nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n<!-- more -->\n2).AES加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3).AES解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"AES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"AES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n\n# 2.DES算法(Data Encryption Standard 数据加密标准)\n- DES：数据加密标准，是对称加密算法领域中的典型算法 \n- 特点：密钥偏短（56位）、生命周期短（避免被破解） \n- Java实现\n\n1）生成密钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");//密钥生成器\nkeyGen.init(56);//初始化密钥生成器\nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n2）加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，加密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3）解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DES\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DES\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n\n# 3.3DES算法(Triple DES、DESede，三重DES加密算法)\n- 3DES：将密钥长度增至112位或168位，通过增加迭代次数提高安全性 \n- 缺点：处理速度较慢、密钥计算时间较长、加密效率不高 \n- Java实现\n\n1）生成密钥\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\");//密钥生成器\nkeyGen.init(168);  //可指定密钥长度为112或168，默认为168   \nSecretKey secretKey = keyGen.generateKey();//生成密钥\nbyte[] key = secretKey.getEncoded();//密钥字节数组\n```\n\n2）3DES加密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//加密data\n```\n3）3DES解密\n```java\nSecretKey secretKey = new SecretKeySpec(key, \"DESede\");//恢复密钥\nCipher cipher = Cipher.getInstance(\"DESede\");//Cipher完成加密或解密工作类\ncipher.init(Cipher.DECRYPT_MODE, secretKey);//对Cipher初始化，解密模式\nbyte[] cipherByte = cipher.doFinal(data);//解密data\n```\n# 4.RSA算法\nRSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。\n> RSA算法原理如下：\n>1.随机选择两个大质数p和q，p不等于q，计算N=pq； \n>2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。 \n>3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。\n>4.销毁p和q。\n\n1)生成秘钥\n\n通过openssl工具生成RSA的公钥和私钥\n[RSA密钥的生成与配置](http://blog.csdn.net/tsuliuchao/article/details/8447690)\n\n2)获取公钥\n```java\n    private PublicKey getPublicKey(){\n        PublicKey publicKey = null;\n        try {\n            InputStream in =  RSAApp.instance.getResources().getAssets().open(\"rsa_public_key.pem\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                if (readLine.charAt(0) == '-') {\n                    continue;\n                } else {\n                    sb.append(readLine);\n                }\n            }\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            byte[] buffer=Base64.decode(sb.toString());\n            EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);\n            publicKey = keyFactory.generatePublic(keySpec);\n            return publicKey;\n        } catch (Exception e) {\n        }\n        return publicKey;\n    }\n```\n\n3)获取私钥\n```java\n private PrivateKey getPrivateKey(){\n        PrivateKey privateKey = null;\n        try {\n            InputStream in = RSAApp.instance.getResources().getAssets().open(\"pkcs8_rsa_private_key.pem\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                if (readLine.charAt(0) == '-') {\n                    continue;\n                } else {\n                    sb.append(readLine);\n                }\n            }\n            in.close();\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            byte[] buffer= Base64.decode(sb.toString());\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(buffer);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n            return privateKey;\n\n        } catch (Exception e) {\n        }\n        return privateKey;\n    }\n```\n\n4)公钥加密\n```java\n    public String encode(String str) {\n        if (TextUtils.isEmpty(str)) {\n            return str;\n        }\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, getPublicKey());\n            byte[] enBytes = cipher.doFinal(str.getBytes());\n            return Base64.encode(enBytes);\n        } catch (Exception e) {\n        }\n        return str;\n    }\n```\n\n5)私钥解密\n```java\n    public String decode(String str) {\n        if (TextUtils.isEmpty(str)) {\n            return str;\n        }\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, getPrivateKey());\n            byte[] base64 = Base64.decode(str);\n            byte[] deBytes = cipher.doFinal(base64);\n            return new String(deBytes, \"UTF-8\");\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n```\n\n# 5.MD5算法\n**MD5加密有哪些特点？**\n\n- 压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n- 容易计算：从原数据计算出MD5值很容易。\n- 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。\n- 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。\n\n**MD5应用场景：**\n\n- 一致性验证\n- 数字签名\n- 安全访问认证\n\n**java加密**\n```java\n public static String md5(String string) {\n        if (TextUtils.isEmpty(string)) {\n            return \"\";\n        }\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = md5.digest(string.getBytes());\n            String result = \"\";\n            for (byte b : bytes) {\n                String temp = Integer.toHexString(b & 0xff);\n                if (temp.length() == 1) {\n                    temp = \"0\" + temp;\n                }\n                result += temp;\n            }\n            return result;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n```\n\n# 参考文献\n[Java利用DES/3DES/AES 三种算法分别实现对称加密](http://blog.csdn.net/smartbetter/article/details/54017759)\n[Android数据加密之Rsa加密](http://www.cnblogs.com/whoislcj/p/5470095.html)\n[Android数据加密之Aes加密](http://www.cnblogs.com/whoislcj/p/5473030.html)\n[Android数据加密之Des加密](http://www.cnblogs.com/whoislcj/p/5580950.html)\n[Android数据加密之MD5加密](http://www.cnblogs.com/whoislcj/p/5885006.html)\n\n>注意：不管是对称加密还是非对称加密，加密的填充方式也是十分重要的。\n>\n>android系统的RSA实现填充方式是\"RSA/None/NoPadding\"，而标准JDK实现是\"RSA/None/PKCS1Padding\",当与服务器交互时，需要注意加密的填充方式。\n\n| 算法 | 密钥长度 | 默认密钥长度 | 工作模式 | 填充方式 |\n| :-----: | :----: | :---------: | :---: | :---: | \n| DES | 56 |  56    |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n| 3DES| 112、168 |  168   |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n| AES | 128、192、256   |  128  |ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128|NoPadding、PKCS5Padding、ISO10126Padding|\n\n","slug":"tech_android_encrypt_and_decode","published":1,"updated":"2017-05-10T12:59:15.824Z","photos":[],"link":"","_id":"cj2sutc4e0001v0lktuazmc91","content":"<hr>\n<p>数据安全，不管是对于企业还是个人都是十分重要。而作为一个移动开发者，我们更需要去考虑数据传输的安全性，去保护企业及个人信息安全。在Java,Android语言中，有许多的常用加解密算法，例如：对称加密算法AES,DES,3DES，非对称加密算法RSA,经典哈希算法MD5,SHA.</p>\n<blockquote>\n<p>对称加密算法：加密秘钥和解密秘钥相同 例：AES,DES,3DES</p>\n<p>非对称加密算法：有公钥和秘钥，公钥加密私钥解密，私钥加密公钥解密。例：RSA</p>\n<p>哈希算法：加解密是不可逆的 例：MD5,SHA</p>\n</blockquote>\n<h1 id=\"常用加解密算法\"><a href=\"#常用加解密算法\" class=\"headerlink\" title=\"常用加解密算法\"></a>常用加解密算法</h1><hr>\n<h1 id=\"1-AES算法-Advanced-Encryption-Standard-高级数据加密标准\"><a href=\"#1-AES算法-Advanced-Encryption-Standard-高级数据加密标准\" class=\"headerlink\" title=\"1.AES算法(Advanced Encryption Standard 高级数据加密标准)\"></a>1.AES算法(Advanced Encryption Standard 高级数据加密标准)</h1><ul>\n<li><p>AES：高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击 </p>\n</li>\n<li><p>特点：密钥建立时间短、灵敏性好、内存需求低、安全性高 </p>\n</li>\n<li><p>Java实现</p>\n</li>\n</ul>\n<p>1).生成秘钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keygen.init(<span class=\"number\">128</span>);  <span class=\"comment\">//默认128，获得无政策权限后可为192或256</span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>2).AES加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"AES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3).AES解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"AES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"2-DES算法-Data-Encryption-Standard-数据加密标准\"><a href=\"#2-DES算法-Data-Encryption-Standard-数据加密标准\" class=\"headerlink\" title=\"2.DES算法(Data Encryption Standard 数据加密标准)\"></a>2.DES算法(Data Encryption Standard 数据加密标准)</h1><ul>\n<li>DES：数据加密标准，是对称加密算法领域中的典型算法 </li>\n<li>特点：密钥偏短（56位）、生命周期短（避免被破解） </li>\n<li>Java实现</li>\n</ul>\n<p>1）生成密钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keyGen.init(<span class=\"number\">56</span>);<span class=\"comment\">//初始化密钥生成器</span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>\n<p>2）加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，加密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3）解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"3-3DES算法-Triple-DES、DESede，三重DES加密算法\"><a href=\"#3-3DES算法-Triple-DES、DESede，三重DES加密算法\" class=\"headerlink\" title=\"3.3DES算法(Triple DES、DESede，三重DES加密算法)\"></a>3.3DES算法(Triple DES、DESede，三重DES加密算法)</h1><ul>\n<li>3DES：将密钥长度增至112位或168位，通过增加迭代次数提高安全性 </li>\n<li>缺点：处理速度较慢、密钥计算时间较长、加密效率不高 </li>\n<li>Java实现</li>\n</ul>\n<p>1）生成密钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keyGen.init(<span class=\"number\">168</span>);  <span class=\"comment\">//可指定密钥长度为112或168，默认为168   </span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>\n<p>2）3DES加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3）3DES解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"4-RSA算法\"><a href=\"#4-RSA算法\" class=\"headerlink\" title=\"4.RSA算法\"></a>4.RSA算法</h1><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</p>\n<blockquote>\n<p>RSA算法原理如下：<br>1.随机选择两个大质数p和q，p不等于q，计算N=pq；<br>2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。<br>3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。<br>4.销毁p和q。</p>\n</blockquote>\n<p>1)生成秘钥</p>\n<p>通过openssl工具生成RSA的公钥和私钥<br><a href=\"http://blog.csdn.net/tsuliuchao/article/details/8447690\" target=\"_blank\" rel=\"external\">RSA密钥的生成与配置</a></p>\n<p>2)获取公钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> PublicKey <span class=\"title\">getPublicKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    PublicKey publicKey = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        InputStream in =  RSAApp.instance.getResources().getAssets().open(<span class=\"string\">\"rsa_public_key.pem\"</span>);</div><div class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(in));</div><div class=\"line\">        String readLine = <span class=\"keyword\">null</span>;</div><div class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">while</span> ((readLine = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (readLine.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'-'</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                sb.append(readLine);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        KeyFactory keyFactory = KeyFactory.getInstance(<span class=\"string\">\"RSA\"</span>);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] buffer=Base64.decode(sb.toString());</div><div class=\"line\">        EncodedKeySpec keySpec = <span class=\"keyword\">new</span> X509EncodedKeySpec(buffer);</div><div class=\"line\">        publicKey = keyFactory.generatePublic(keySpec);</div><div class=\"line\">        <span class=\"keyword\">return</span> publicKey;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> publicKey;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3)获取私钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> PrivateKey <span class=\"title\">getPrivateKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">       PrivateKey privateKey = <span class=\"keyword\">null</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           InputStream in = RSAApp.instance.getResources().getAssets().open(<span class=\"string\">\"pkcs8_rsa_private_key.pem\"</span>);</div><div class=\"line\">           BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(in));</div><div class=\"line\">           String readLine = <span class=\"keyword\">null</span>;</div><div class=\"line\">           StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">           <span class=\"keyword\">while</span> ((readLine = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (readLine.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'-'</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">continue</span>;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   sb.append(readLine);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           in.close();</div><div class=\"line\">           KeyFactory keyFactory = KeyFactory.getInstance(<span class=\"string\">\"RSA\"</span>);</div><div class=\"line\">           <span class=\"keyword\">byte</span>[] buffer= Base64.decode(sb.toString());</div><div class=\"line\">           EncodedKeySpec privateKeySpec = <span class=\"keyword\">new</span> PKCS8EncodedKeySpec(buffer);</div><div class=\"line\">           privateKey = keyFactory.generatePrivate(privateKeySpec);</div><div class=\"line\">           <span class=\"keyword\">return</span> privateKey;</div><div class=\"line\"></div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> privateKey;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>4)公钥加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(str)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Cipher cipher = Cipher.getInstance(<span class=\"string\">\"RSA/ECB/PKCS1Padding\"</span>);</div><div class=\"line\">        cipher.init(Cipher.ENCRYPT_MODE, getPublicKey());</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] enBytes = cipher.doFinal(str.getBytes());</div><div class=\"line\">        <span class=\"keyword\">return</span> Base64.encode(enBytes);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>5)私钥解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">decode</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(str)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Cipher cipher = Cipher.getInstance(<span class=\"string\">\"RSA/ECB/PKCS1Padding\"</span>);</div><div class=\"line\">        cipher.init(Cipher.DECRYPT_MODE, getPrivateKey());</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] base64 = Base64.decode(str);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] deBytes = cipher.doFinal(base64);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(deBytes, <span class=\"string\">\"UTF-8\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"5-MD5算法\"><a href=\"#5-MD5算法\" class=\"headerlink\" title=\"5.MD5算法\"></a>5.MD5算法</h1><p><strong>MD5加密有哪些特点？</strong></p>\n<ul>\n<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>\n<li>容易计算：从原数据计算出MD5值很容易。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>\n<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>\n</ul>\n<p><strong>MD5应用场景：</strong></p>\n<ul>\n<li>一致性验证</li>\n<li>数字签名</li>\n<li>安全访问认证</li>\n</ul>\n<p><strong>java加密</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String string)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (TextUtils.isEmpty(string)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       MessageDigest md5 = <span class=\"keyword\">null</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           md5 = MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);</div><div class=\"line\">           <span class=\"keyword\">byte</span>[] bytes = md5.digest(string.getBytes());</div><div class=\"line\">           String result = <span class=\"string\">\"\"</span>;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : bytes) &#123;</div><div class=\"line\">               String temp = Integer.toHexString(b &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (temp.length() == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                   temp = <span class=\"string\">\"0\"</span> + temp;</div><div class=\"line\">               &#125;</div><div class=\"line\">               result += temp;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> result;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class=\"line\">           e.printStackTrace();</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"http://blog.csdn.net/smartbetter/article/details/54017759\" target=\"_blank\" rel=\"external\">Java利用DES/3DES/AES 三种算法分别实现对称加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5470095.html\" target=\"_blank\" rel=\"external\">Android数据加密之Rsa加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5473030.html\" target=\"_blank\" rel=\"external\">Android数据加密之Aes加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5580950.html\" target=\"_blank\" rel=\"external\">Android数据加密之Des加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5885006.html\" target=\"_blank\" rel=\"external\">Android数据加密之MD5加密</a></p>\n<blockquote>\n<p>注意：不管是对称加密还是非对称加密，加密的填充方式也是十分重要的。</p>\n<p>android系统的RSA实现填充方式是”RSA/None/NoPadding”，而标准JDK实现是”RSA/None/PKCS1Padding”,当与服务器交互时，需要注意加密的填充方式。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法</th>\n<th style=\"text-align:center\">密钥长度</th>\n<th style=\"text-align:center\">默认密钥长度</th>\n<th style=\"text-align:center\">工作模式</th>\n<th style=\"text-align:center\">填充方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DES</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3DES</td>\n<td style=\"text-align:center\">112、168</td>\n<td style=\"text-align:center\">168</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AES</td>\n<td style=\"text-align:center\">128、192、256</td>\n<td style=\"text-align:center\">128</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<hr>\n<p>数据安全，不管是对于企业还是个人都是十分重要。而作为一个移动开发者，我们更需要去考虑数据传输的安全性，去保护企业及个人信息安全。在Java,Android语言中，有许多的常用加解密算法，例如：对称加密算法AES,DES,3DES，非对称加密算法RSA,经典哈希算法MD5,SHA.</p>\n<blockquote>\n<p>对称加密算法：加密秘钥和解密秘钥相同 例：AES,DES,3DES</p>\n<p>非对称加密算法：有公钥和秘钥，公钥加密私钥解密，私钥加密公钥解密。例：RSA</p>\n<p>哈希算法：加解密是不可逆的 例：MD5,SHA</p>\n</blockquote>\n<h1 id=\"常用加解密算法\"><a href=\"#常用加解密算法\" class=\"headerlink\" title=\"常用加解密算法\"></a>常用加解密算法</h1><hr>\n<h1 id=\"1-AES算法-Advanced-Encryption-Standard-高级数据加密标准\"><a href=\"#1-AES算法-Advanced-Encryption-Standard-高级数据加密标准\" class=\"headerlink\" title=\"1.AES算法(Advanced Encryption Standard 高级数据加密标准)\"></a>1.AES算法(Advanced Encryption Standard 高级数据加密标准)</h1><ul>\n<li><p>AES：高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击 </p>\n</li>\n<li><p>特点：密钥建立时间短、灵敏性好、内存需求低、安全性高 </p>\n</li>\n<li><p>Java实现</p>\n</li>\n</ul>\n<p>1).生成秘钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keygen.init(<span class=\"number\">128</span>);  <span class=\"comment\">//默认128，获得无政策权限后可为192或256</span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>","more":"<p>2).AES加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"AES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3).AES解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"AES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"AES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"2-DES算法-Data-Encryption-Standard-数据加密标准\"><a href=\"#2-DES算法-Data-Encryption-Standard-数据加密标准\" class=\"headerlink\" title=\"2.DES算法(Data Encryption Standard 数据加密标准)\"></a>2.DES算法(Data Encryption Standard 数据加密标准)</h1><ul>\n<li>DES：数据加密标准，是对称加密算法领域中的典型算法 </li>\n<li>特点：密钥偏短（56位）、生命周期短（避免被破解） </li>\n<li>Java实现</li>\n</ul>\n<p>1）生成密钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keyGen.init(<span class=\"number\">56</span>);<span class=\"comment\">//初始化密钥生成器</span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>\n<p>2）加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，加密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3）解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DES\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DES\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"3-3DES算法-Triple-DES、DESede，三重DES加密算法\"><a href=\"#3-3DES算法-Triple-DES、DESede，三重DES加密算法\" class=\"headerlink\" title=\"3.3DES算法(Triple DES、DESede，三重DES加密算法)\"></a>3.3DES算法(Triple DES、DESede，三重DES加密算法)</h1><ul>\n<li>3DES：将密钥长度增至112位或168位，通过增加迭代次数提高安全性 </li>\n<li>缺点：处理速度较慢、密钥计算时间较长、加密效率不高 </li>\n<li>Java实现</li>\n</ul>\n<p>1）生成密钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeyGenerator keyGen = KeyGenerator.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//密钥生成器</span></div><div class=\"line\">keyGen.init(<span class=\"number\">168</span>);  <span class=\"comment\">//可指定密钥长度为112或168，默认为168   </span></div><div class=\"line\">SecretKey secretKey = keyGen.generateKey();<span class=\"comment\">//生成密钥</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] key = secretKey.getEncoded();<span class=\"comment\">//密钥字节数组</span></div></pre></td></tr></table></figure></p>\n<p>2）3DES加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.ENCRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//加密data</span></div></pre></td></tr></table></figure></p>\n<p>3）3DES解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(key, <span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//恢复密钥</span></div><div class=\"line\">Cipher cipher = Cipher.getInstance(<span class=\"string\">\"DESede\"</span>);<span class=\"comment\">//Cipher完成加密或解密工作类</span></div><div class=\"line\">cipher.init(Cipher.DECRYPT_MODE, secretKey);<span class=\"comment\">//对Cipher初始化，解密模式</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] cipherByte = cipher.doFinal(data);<span class=\"comment\">//解密data</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"4-RSA算法\"><a href=\"#4-RSA算法\" class=\"headerlink\" title=\"4.RSA算法\"></a>4.RSA算法</h1><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</p>\n<blockquote>\n<p>RSA算法原理如下：<br>1.随机选择两个大质数p和q，p不等于q，计算N=pq；<br>2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。<br>3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。<br>4.销毁p和q。</p>\n</blockquote>\n<p>1)生成秘钥</p>\n<p>通过openssl工具生成RSA的公钥和私钥<br><a href=\"http://blog.csdn.net/tsuliuchao/article/details/8447690\">RSA密钥的生成与配置</a></p>\n<p>2)获取公钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> PublicKey <span class=\"title\">getPublicKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    PublicKey publicKey = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        InputStream in =  RSAApp.instance.getResources().getAssets().open(<span class=\"string\">\"rsa_public_key.pem\"</span>);</div><div class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(in));</div><div class=\"line\">        String readLine = <span class=\"keyword\">null</span>;</div><div class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">while</span> ((readLine = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (readLine.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'-'</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                sb.append(readLine);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        KeyFactory keyFactory = KeyFactory.getInstance(<span class=\"string\">\"RSA\"</span>);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] buffer=Base64.decode(sb.toString());</div><div class=\"line\">        EncodedKeySpec keySpec = <span class=\"keyword\">new</span> X509EncodedKeySpec(buffer);</div><div class=\"line\">        publicKey = keyFactory.generatePublic(keySpec);</div><div class=\"line\">        <span class=\"keyword\">return</span> publicKey;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> publicKey;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3)获取私钥<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> PrivateKey <span class=\"title\">getPrivateKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">       PrivateKey privateKey = <span class=\"keyword\">null</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           InputStream in = RSAApp.instance.getResources().getAssets().open(<span class=\"string\">\"pkcs8_rsa_private_key.pem\"</span>);</div><div class=\"line\">           BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(in));</div><div class=\"line\">           String readLine = <span class=\"keyword\">null</span>;</div><div class=\"line\">           StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">           <span class=\"keyword\">while</span> ((readLine = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (readLine.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'-'</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">continue</span>;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   sb.append(readLine);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           in.close();</div><div class=\"line\">           KeyFactory keyFactory = KeyFactory.getInstance(<span class=\"string\">\"RSA\"</span>);</div><div class=\"line\">           <span class=\"keyword\">byte</span>[] buffer= Base64.decode(sb.toString());</div><div class=\"line\">           EncodedKeySpec privateKeySpec = <span class=\"keyword\">new</span> PKCS8EncodedKeySpec(buffer);</div><div class=\"line\">           privateKey = keyFactory.generatePrivate(privateKeySpec);</div><div class=\"line\">           <span class=\"keyword\">return</span> privateKey;</div><div class=\"line\"></div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> privateKey;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>4)公钥加密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(str)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Cipher cipher = Cipher.getInstance(<span class=\"string\">\"RSA/ECB/PKCS1Padding\"</span>);</div><div class=\"line\">        cipher.init(Cipher.ENCRYPT_MODE, getPublicKey());</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] enBytes = cipher.doFinal(str.getBytes());</div><div class=\"line\">        <span class=\"keyword\">return</span> Base64.encode(enBytes);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>5)私钥解密<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">decode</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(str)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Cipher cipher = Cipher.getInstance(<span class=\"string\">\"RSA/ECB/PKCS1Padding\"</span>);</div><div class=\"line\">        cipher.init(Cipher.DECRYPT_MODE, getPrivateKey());</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] base64 = Base64.decode(str);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] deBytes = cipher.doFinal(base64);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(deBytes, <span class=\"string\">\"UTF-8\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"5-MD5算法\"><a href=\"#5-MD5算法\" class=\"headerlink\" title=\"5.MD5算法\"></a>5.MD5算法</h1><p><strong>MD5加密有哪些特点？</strong></p>\n<ul>\n<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>\n<li>容易计算：从原数据计算出MD5值很容易。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>\n<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>\n</ul>\n<p><strong>MD5应用场景：</strong></p>\n<ul>\n<li>一致性验证</li>\n<li>数字签名</li>\n<li>安全访问认证</li>\n</ul>\n<p><strong>java加密</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String string)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (TextUtils.isEmpty(string)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       MessageDigest md5 = <span class=\"keyword\">null</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           md5 = MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);</div><div class=\"line\">           <span class=\"keyword\">byte</span>[] bytes = md5.digest(string.getBytes());</div><div class=\"line\">           String result = <span class=\"string\">\"\"</span>;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : bytes) &#123;</div><div class=\"line\">               String temp = Integer.toHexString(b &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (temp.length() == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                   temp = <span class=\"string\">\"0\"</span> + temp;</div><div class=\"line\">               &#125;</div><div class=\"line\">               result += temp;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> result;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class=\"line\">           e.printStackTrace();</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"http://blog.csdn.net/smartbetter/article/details/54017759\">Java利用DES/3DES/AES 三种算法分别实现对称加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5470095.html\">Android数据加密之Rsa加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5473030.html\">Android数据加密之Aes加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5580950.html\">Android数据加密之Des加密</a><br><a href=\"http://www.cnblogs.com/whoislcj/p/5885006.html\">Android数据加密之MD5加密</a></p>\n<blockquote>\n<p>注意：不管是对称加密还是非对称加密，加密的填充方式也是十分重要的。</p>\n<p>android系统的RSA实现填充方式是”RSA/None/NoPadding”，而标准JDK实现是”RSA/None/PKCS1Padding”,当与服务器交互时，需要注意加密的填充方式。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法</th>\n<th style=\"text-align:center\">密钥长度</th>\n<th style=\"text-align:center\">默认密钥长度</th>\n<th style=\"text-align:center\">工作模式</th>\n<th style=\"text-align:center\">填充方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DES</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3DES</td>\n<td style=\"text-align:center\">112、168</td>\n<td style=\"text-align:center\">168</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AES</td>\n<td style=\"text-align:center\">128、192、256</td>\n<td style=\"text-align:center\">128</td>\n<td style=\"text-align:center\">ECB、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128、OFB、OFB8-OFB128</td>\n<td style=\"text-align:center\">NoPadding、PKCS5Padding、ISO10126Padding</td>\n</tr>\n</tbody>\n</table>"},{"layout":"post","title":"【Java基础】SimpleDateFormat与Calendar使用详解","date":"2017-05-17T10:20:05.000Z","comments":1,"_content":"---\n# 1.SimpleDateFormat类\n函数语法\n\n| 标识 | 标识表意 | \n| :-----: | :----: |\n|G|年代标志符|\n|y|年|\n|M|月|\n|d|日|\n|h|时 在上午或下午 (1~12)|\n|H|时 在一天中 (0~23)|\n|m|分|\n|s|秒|\n|S|毫秒|\n|E|星期|\n|D|一年中的第几天|\n|F|一月中第几个星期几|\n|w|一年中第几个星期|\n|W|一月中第几个星期|\n|a|上午 / 下午 标记符| \n|k|时 在一天中 (1~24)|\n|K|时 在上午或下午 (0~11)|\n|z|时区|","source":"_posts/tech_java_date_format.md","raw":"---\nlayout: post\ntitle: \"【Java基础】SimpleDateFormat与Calendar使用详解\"\ndate: 5/17/2017 6:20:05 PM \ncomments: true\ntags: \n\t- 技术 \n\t- Java\n\t- Java基础\n---\n---\n# 1.SimpleDateFormat类\n函数语法\n\n| 标识 | 标识表意 | \n| :-----: | :----: |\n|G|年代标志符|\n|y|年|\n|M|月|\n|d|日|\n|h|时 在上午或下午 (1~12)|\n|H|时 在一天中 (0~23)|\n|m|分|\n|s|秒|\n|S|毫秒|\n|E|星期|\n|D|一年中的第几天|\n|F|一月中第几个星期几|\n|w|一年中第几个星期|\n|W|一月中第几个星期|\n|a|上午 / 下午 标记符| \n|k|时 在一天中 (1~24)|\n|K|时 在上午或下午 (0~11)|\n|z|时区|","slug":"tech_java_date_format","published":1,"updated":"2017-05-17T10:40:05.048Z","_id":"cj2sutc4i0003v0lkdheyd5ox","photos":[],"link":"","content":"<hr>\n<h1 id=\"1-SimpleDateFormat类\"><a href=\"#1-SimpleDateFormat类\" class=\"headerlink\" title=\"1.SimpleDateFormat类\"></a>1.SimpleDateFormat类</h1><p>函数语法</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标识</th>\n<th style=\"text-align:center\">标识表意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">年代标志符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\">年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">月</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">日</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">h</td>\n<td style=\"text-align:center\">时 在上午或下午 (1~12)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">时 在一天中 (0~23)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">毫秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">一年中的第几天</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">一月中第几个星期几</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">一年中第几个星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">W</td>\n<td style=\"text-align:center\">一月中第几个星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">上午 / 下午 标记符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">k</td>\n<td style=\"text-align:center\">时 在一天中 (1~24)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">时 在上午或下午 (0~11)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">z</td>\n<td style=\"text-align:center\">时区</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<hr>\n<h1 id=\"1-SimpleDateFormat类\"><a href=\"#1-SimpleDateFormat类\" class=\"headerlink\" title=\"1.SimpleDateFormat类\"></a>1.SimpleDateFormat类</h1><p>函数语法</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标识</th>\n<th style=\"text-align:center\">标识表意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">年代标志符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\">年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">月</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">日</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">h</td>\n<td style=\"text-align:center\">时 在上午或下午 (1~12)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">时 在一天中 (0~23)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">毫秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">一年中的第几天</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">一月中第几个星期几</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">一年中第几个星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">W</td>\n<td style=\"text-align:center\">一月中第几个星期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">上午 / 下午 标记符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">k</td>\n<td style=\"text-align:center\">时 在一天中 (1~24)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">时 在上午或下午 (0~11)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">z</td>\n<td style=\"text-align:center\">时区</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"Android技术知识要点","date":"2017-04-11T07:38:32.000Z","comments":1,"_content":"---\n# 一、项目中使用库工程问题要点\n##### 1.库工程与主工程资源冲突问题\n\n  当运行有引用library工程的android工程时，android工具将会合并library工程与主工程的所有资源。如果一个资源ID将有可能在library工程之间或library工程、主工程之间都有定义，这时候优先级别高的资源ID将覆盖优先级别低的，使用资源时将使用有线级别最高的工程的资源。工程之间优先级别如何判定，请看下一条。\n\n##### 2.库工程之间以及主工程的资源使用上的优先级问题\n\n上图显示一个android工程引用了四个library工程，这四个library工程和主工程之间是有优先级之分的。android主工程的优先级别最高，四个library工程科举上图排序有上到下优先级别依次降低。library工程之间也可以手动排序，选择其中一个，点击up(提高优先级)或者down（降低优先级）。\n\n##### 3.库工程和主工程使用不同的android platform version问题\n\n主工程打包时，android sdk版本使用的是主工程。所以library工程使用的android sdk版本要不高于主工程的sdk版本。如果library工程sdk版本高于主工程，将不能通过编译。\n<!-- more -->\n# 二、自定义ViewGroup或Canvas获取绘制内容Bitmap\n* 可以通过setDrawingCacheEnabled，然后再getDrawingCache(),但这个你得保证onDraw被调用。\n* 从Canvas获取Bitmap(自定义View类似),例子：\n\n```java\npublic Bitmap getBitmap() {  \n        Bitmap whiteBgBitmap = Bitmap.createBitmap(mBackgroundBitmap.getWidth(), mBackgroundBitmap.getHeight(),  \n                Bitmap.Config.ARGB_8888);  \n        Canvas canvas = new Canvas(whiteBgBitmap);  \n        canvas.drawColor(Color.WHITE);  \n        canvas.drawBitmap(mBackgroundBitmap, 0, 0, null);\n        return whiteBgBitmap;  \n    }  \n``` \n\n# 三、Https证书ctr(或cer)格式转bks格式\n- 1.要生成bks证书，需要bcprov-ext-jdk15on-151.jar([下载地址](http://www.bouncycastle.org/latest_releases.html)）\n- 2.cmd中输入以下命令\n![](/assets/img/tech_android_basic_point_img01.png);\n\n输入例子\n\nkeytool -importcert -v -trustcacerts -alias xx -file E:\\bks\\xx.cer -keystore E:\\bks\\xx.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath E:\\bks\\bcprov-jdk15on-146.jar -storepass xxxxxx\n\n注意:\n\n1.注意命令中不能有换行 \n\n2.地址必须全地址 \n\n3.文件要符合Java命名规范\n\n- 把证书复制到Android项目的asset(或raw)目录中，加载证书即可https访问。（[Android加载证书https请求](http://www.jianshu.com/p/9a6c204616d2)）\n\n","source":"_posts/tech-android-basic-point.md","raw":"---\nlayout: post\ntitle: \"Android技术知识要点\"\ndate: 4/11/2017 3:38:32 PM  \ncomments: true\ntags: \n\t- 技术 \n\t- Android\n---\n---\n# 一、项目中使用库工程问题要点\n##### 1.库工程与主工程资源冲突问题\n\n  当运行有引用library工程的android工程时，android工具将会合并library工程与主工程的所有资源。如果一个资源ID将有可能在library工程之间或library工程、主工程之间都有定义，这时候优先级别高的资源ID将覆盖优先级别低的，使用资源时将使用有线级别最高的工程的资源。工程之间优先级别如何判定，请看下一条。\n\n##### 2.库工程之间以及主工程的资源使用上的优先级问题\n\n上图显示一个android工程引用了四个library工程，这四个library工程和主工程之间是有优先级之分的。android主工程的优先级别最高，四个library工程科举上图排序有上到下优先级别依次降低。library工程之间也可以手动排序，选择其中一个，点击up(提高优先级)或者down（降低优先级）。\n\n##### 3.库工程和主工程使用不同的android platform version问题\n\n主工程打包时，android sdk版本使用的是主工程。所以library工程使用的android sdk版本要不高于主工程的sdk版本。如果library工程sdk版本高于主工程，将不能通过编译。\n<!-- more -->\n# 二、自定义ViewGroup或Canvas获取绘制内容Bitmap\n* 可以通过setDrawingCacheEnabled，然后再getDrawingCache(),但这个你得保证onDraw被调用。\n* 从Canvas获取Bitmap(自定义View类似),例子：\n\n```java\npublic Bitmap getBitmap() {  \n        Bitmap whiteBgBitmap = Bitmap.createBitmap(mBackgroundBitmap.getWidth(), mBackgroundBitmap.getHeight(),  \n                Bitmap.Config.ARGB_8888);  \n        Canvas canvas = new Canvas(whiteBgBitmap);  \n        canvas.drawColor(Color.WHITE);  \n        canvas.drawBitmap(mBackgroundBitmap, 0, 0, null);\n        return whiteBgBitmap;  \n    }  \n``` \n\n# 三、Https证书ctr(或cer)格式转bks格式\n- 1.要生成bks证书，需要bcprov-ext-jdk15on-151.jar([下载地址](http://www.bouncycastle.org/latest_releases.html)）\n- 2.cmd中输入以下命令\n![](/assets/img/tech_android_basic_point_img01.png);\n\n输入例子\n\nkeytool -importcert -v -trustcacerts -alias xx -file E:\\bks\\xx.cer -keystore E:\\bks\\xx.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath E:\\bks\\bcprov-jdk15on-146.jar -storepass xxxxxx\n\n注意:\n\n1.注意命令中不能有换行 \n\n2.地址必须全地址 \n\n3.文件要符合Java命名规范\n\n- 把证书复制到Android项目的asset(或raw)目录中，加载证书即可https访问。（[Android加载证书https请求](http://www.jianshu.com/p/9a6c204616d2)）\n\n","slug":"tech-android-basic-point","published":1,"updated":"2017-04-11T08:09:07.437Z","photos":[],"link":"","_id":"cj2sutc4j0004v0lk2kwbrmfy","content":"<hr>\n<h1 id=\"一、项目中使用库工程问题要点\"><a href=\"#一、项目中使用库工程问题要点\" class=\"headerlink\" title=\"一、项目中使用库工程问题要点\"></a>一、项目中使用库工程问题要点</h1><h5 id=\"1-库工程与主工程资源冲突问题\"><a href=\"#1-库工程与主工程资源冲突问题\" class=\"headerlink\" title=\"1.库工程与主工程资源冲突问题\"></a>1.库工程与主工程资源冲突问题</h5><p>  当运行有引用library工程的android工程时，android工具将会合并library工程与主工程的所有资源。如果一个资源ID将有可能在library工程之间或library工程、主工程之间都有定义，这时候优先级别高的资源ID将覆盖优先级别低的，使用资源时将使用有线级别最高的工程的资源。工程之间优先级别如何判定，请看下一条。</p>\n<h5 id=\"2-库工程之间以及主工程的资源使用上的优先级问题\"><a href=\"#2-库工程之间以及主工程的资源使用上的优先级问题\" class=\"headerlink\" title=\"2.库工程之间以及主工程的资源使用上的优先级问题\"></a>2.库工程之间以及主工程的资源使用上的优先级问题</h5><p>上图显示一个android工程引用了四个library工程，这四个library工程和主工程之间是有优先级之分的。android主工程的优先级别最高，四个library工程科举上图排序有上到下优先级别依次降低。library工程之间也可以手动排序，选择其中一个，点击up(提高优先级)或者down（降低优先级）。</p>\n<h5 id=\"3-库工程和主工程使用不同的android-platform-version问题\"><a href=\"#3-库工程和主工程使用不同的android-platform-version问题\" class=\"headerlink\" title=\"3.库工程和主工程使用不同的android platform version问题\"></a>3.库工程和主工程使用不同的android platform version问题</h5><p>主工程打包时，android sdk版本使用的是主工程。所以library工程使用的android sdk版本要不高于主工程的sdk版本。如果library工程sdk版本高于主工程，将不能通过编译。<br><a id=\"more\"></a></p>\n<h1 id=\"二、自定义ViewGroup或Canvas获取绘制内容Bitmap\"><a href=\"#二、自定义ViewGroup或Canvas获取绘制内容Bitmap\" class=\"headerlink\" title=\"二、自定义ViewGroup或Canvas获取绘制内容Bitmap\"></a>二、自定义ViewGroup或Canvas获取绘制内容Bitmap</h1><ul>\n<li>可以通过setDrawingCacheEnabled，然后再getDrawingCache(),但这个你得保证onDraw被调用。</li>\n<li>从Canvas获取Bitmap(自定义View类似),例子：</li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmap</span><span class=\"params\">()</span> </span>{  \n        Bitmap whiteBgBitmap = Bitmap.createBitmap(mBackgroundBitmap.getWidth(), mBackgroundBitmap.getHeight(),  \n                Bitmap.Config.ARGB_8888);  \n        Canvas canvas = <span class=\"keyword\">new</span> Canvas(whiteBgBitmap);  \n        canvas.drawColor(Color.WHITE);  \n        canvas.drawBitmap(mBackgroundBitmap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">return</span> whiteBgBitmap;  \n    }\n</code></pre>\n<h1 id=\"三、Https证书ctr-或cer-格式转bks格式\"><a href=\"#三、Https证书ctr-或cer-格式转bks格式\" class=\"headerlink\" title=\"三、Https证书ctr(或cer)格式转bks格式\"></a>三、Https证书ctr(或cer)格式转bks格式</h1><ul>\n<li>1.要生成bks证书，需要bcprov-ext-jdk15on-151.jar(<a href=\"http://www.bouncycastle.org/latest_releases.html\" target=\"_blank\" rel=\"external\">下载地址</a>）</li>\n<li>2.cmd中输入以下命令<br><img src=\"/assets/img/tech_android_basic_point_img01.png\" alt=\"\">;</li>\n</ul>\n<p>输入例子</p>\n<p>keytool -importcert -v -trustcacerts -alias xx -file E:\\bks\\xx.cer -keystore E:\\bks\\xx.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath E:\\bks\\bcprov-jdk15on-146.jar -storepass xxxxxx</p>\n<p>注意:</p>\n<p>1.注意命令中不能有换行 </p>\n<p>2.地址必须全地址 </p>\n<p>3.文件要符合Java命名规范</p>\n<ul>\n<li>把证书复制到Android项目的asset(或raw)目录中，加载证书即可https访问。（<a href=\"http://www.jianshu.com/p/9a6c204616d2\" target=\"_blank\" rel=\"external\">Android加载证书https请求</a>）</li>\n</ul>\n","excerpt":"<hr>\n<h1 id=\"一、项目中使用库工程问题要点\"><a href=\"#一、项目中使用库工程问题要点\" class=\"headerlink\" title=\"一、项目中使用库工程问题要点\"></a>一、项目中使用库工程问题要点</h1><h5 id=\"1-库工程与主工程资源冲突问题\"><a href=\"#1-库工程与主工程资源冲突问题\" class=\"headerlink\" title=\"1.库工程与主工程资源冲突问题\"></a>1.库工程与主工程资源冲突问题</h5><p>  当运行有引用library工程的android工程时，android工具将会合并library工程与主工程的所有资源。如果一个资源ID将有可能在library工程之间或library工程、主工程之间都有定义，这时候优先级别高的资源ID将覆盖优先级别低的，使用资源时将使用有线级别最高的工程的资源。工程之间优先级别如何判定，请看下一条。</p>\n<h5 id=\"2-库工程之间以及主工程的资源使用上的优先级问题\"><a href=\"#2-库工程之间以及主工程的资源使用上的优先级问题\" class=\"headerlink\" title=\"2.库工程之间以及主工程的资源使用上的优先级问题\"></a>2.库工程之间以及主工程的资源使用上的优先级问题</h5><p>上图显示一个android工程引用了四个library工程，这四个library工程和主工程之间是有优先级之分的。android主工程的优先级别最高，四个library工程科举上图排序有上到下优先级别依次降低。library工程之间也可以手动排序，选择其中一个，点击up(提高优先级)或者down（降低优先级）。</p>\n<h5 id=\"3-库工程和主工程使用不同的android-platform-version问题\"><a href=\"#3-库工程和主工程使用不同的android-platform-version问题\" class=\"headerlink\" title=\"3.库工程和主工程使用不同的android platform version问题\"></a>3.库工程和主工程使用不同的android platform version问题</h5><p>主工程打包时，android sdk版本使用的是主工程。所以library工程使用的android sdk版本要不高于主工程的sdk版本。如果library工程sdk版本高于主工程，将不能通过编译。<br>","more":"</p>\n<h1 id=\"二、自定义ViewGroup或Canvas获取绘制内容Bitmap\"><a href=\"#二、自定义ViewGroup或Canvas获取绘制内容Bitmap\" class=\"headerlink\" title=\"二、自定义ViewGroup或Canvas获取绘制内容Bitmap\"></a>二、自定义ViewGroup或Canvas获取绘制内容Bitmap</h1><ul>\n<li>可以通过setDrawingCacheEnabled，然后再getDrawingCache(),但这个你得保证onDraw被调用。</li>\n<li>从Canvas获取Bitmap(自定义View类似),例子：</li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmap</span><span class=\"params\">()</span> </span>{  \n        Bitmap whiteBgBitmap = Bitmap.createBitmap(mBackgroundBitmap.getWidth(), mBackgroundBitmap.getHeight(),  \n                Bitmap.Config.ARGB_8888);  \n        Canvas canvas = <span class=\"keyword\">new</span> Canvas(whiteBgBitmap);  \n        canvas.drawColor(Color.WHITE);  \n        canvas.drawBitmap(mBackgroundBitmap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">return</span> whiteBgBitmap;  \n    }\n</code></pre>\n<h1 id=\"三、Https证书ctr-或cer-格式转bks格式\"><a href=\"#三、Https证书ctr-或cer-格式转bks格式\" class=\"headerlink\" title=\"三、Https证书ctr(或cer)格式转bks格式\"></a>三、Https证书ctr(或cer)格式转bks格式</h1><ul>\n<li>1.要生成bks证书，需要bcprov-ext-jdk15on-151.jar(<a href=\"http://www.bouncycastle.org/latest_releases.html\">下载地址</a>）</li>\n<li>2.cmd中输入以下命令<br><img src=\"/assets/img/tech_android_basic_point_img01.png\" alt=\"\">;</li>\n</ul>\n<p>输入例子</p>\n<p>keytool -importcert -v -trustcacerts -alias xx -file E:\\bks\\xx.cer -keystore E:\\bks\\xx.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath E:\\bks\\bcprov-jdk15on-146.jar -storepass xxxxxx</p>\n<p>注意:</p>\n<p>1.注意命令中不能有换行 </p>\n<p>2.地址必须全地址 </p>\n<p>3.文件要符合Java命名规范</p>\n<ul>\n<li>把证书复制到Android项目的asset(或raw)目录中，加载证书即可https访问。（<a href=\"http://www.jianshu.com/p/9a6c204616d2\">Android加载证书https请求</a>）</li>\n</ul>"},{"layout":"post","title":"【响应式编程】Rxjava学习总结","date":"2017-03-16T13:06:13.000Z","comments":1,"_content":"---\n# 1.[RxJava基础详解-扔物线](http://gank.io/post/560e15be2dca930e00da1083) #\n# 2.RxJava常用方法总结 #\nRxJava 的观察者模式\n\n![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg)\n\n\n![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg)\n\n\nObservable.just(T...)方法\n>![](http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg)\n>Observable.just()动画显示\n>![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif)\n\nObservable.from(T[])分发集合方法(图类似just())\n\n<!-- more -->\nObservable.map()直接变换\n>![](http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg)\n\nObservable.flatMap()平铺变换\n>![](http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg)\n\n# 3.RxJava线程调度 #\n1.RxJava线程控制\n>Observable.subscribeOn(Schedulers.io())指定被观察运行线程(订阅线程)\n>\nObservable.observeOn(AndroidSchedulers.mainThread)指定观察者运行线程\n>\nObservable.doOnSubscribe(Schedulers.io())被观察者开始执行前调用\n\n2.Schedulers介绍\n\n > Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程（这是默认的）。\n > \n > Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n > \n > Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n > \n >Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n >\n >AndroidSchedulers.mainThread()，是RxAndroid 中一个对 RxJava 的轻量级扩展为了Android 的主线程提供 Scheduler，它指定的操作将在 Android 主线程运行。   \n\n# 4.结尾 #\n以上图片资源皆来至于 [RxJava基础详解-扔物线](http://gank.io/post/560e15be2dca930e00da1083)\n\n\n","source":"_posts/tech_rxjava_basic.md","raw":"---\nlayout: post\ntitle: \"【响应式编程】Rxjava学习总结\"\ndate: 3/16/2017 9:06:13 PM \ncomments: true\ntags: \n\t- 技术 \n\t- Rxjava\n\t- Rxandroid\n\t- 响应式编程\n---\n---\n# 1.[RxJava基础详解-扔物线](http://gank.io/post/560e15be2dca930e00da1083) #\n# 2.RxJava常用方法总结 #\nRxJava 的观察者模式\n\n![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg)\n\n\n![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg)\n\n\nObservable.just(T...)方法\n>![](http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg)\n>Observable.just()动画显示\n>![](http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif)\n\nObservable.from(T[])分发集合方法(图类似just())\n\n<!-- more -->\nObservable.map()直接变换\n>![](http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg)\n\nObservable.flatMap()平铺变换\n>![](http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg)\n\n# 3.RxJava线程调度 #\n1.RxJava线程控制\n>Observable.subscribeOn(Schedulers.io())指定被观察运行线程(订阅线程)\n>\nObservable.observeOn(AndroidSchedulers.mainThread)指定观察者运行线程\n>\nObservable.doOnSubscribe(Schedulers.io())被观察者开始执行前调用\n\n2.Schedulers介绍\n\n > Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程（这是默认的）。\n > \n > Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n > \n > Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n > \n >Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n >\n >AndroidSchedulers.mainThread()，是RxAndroid 中一个对 RxJava 的轻量级扩展为了Android 的主线程提供 Scheduler，它指定的操作将在 Android 主线程运行。   \n\n# 4.结尾 #\n以上图片资源皆来至于 [RxJava基础详解-扔物线](http://gank.io/post/560e15be2dca930e00da1083)\n\n\n","slug":"tech_rxjava_basic","published":1,"updated":"2017-05-12T10:34:01.368Z","photos":[],"link":"","_id":"cj2sutc4o0005v0lkvzlbd5u0","content":"<hr>\n<h1 id=\"1-RxJava基础详解-扔物线\"><a href=\"#1-RxJava基础详解-扔物线\" class=\"headerlink\" title=\"1.RxJava基础详解-扔物线\"></a>1.<a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">RxJava基础详解-扔物线</a></h1><h1 id=\"2-RxJava常用方法总结\"><a href=\"#2-RxJava常用方法总结\" class=\"headerlink\" title=\"2.RxJava常用方法总结\"></a>2.RxJava常用方法总结</h1><p>RxJava 的观察者模式</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg\" alt=\"\"></p>\n<p>Observable.just(T…)方法</p>\n<blockquote>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg\" alt=\"\"><br>Observable.just()动画显示<br><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif\" alt=\"\"></p>\n</blockquote>\n<p>Observable.from(T[])分发集合方法(图类似just())</p>\n<a id=\"more\"></a>\n<p>Observable.map()直接变换</p>\n<blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg\" alt=\"\"></p>\n</blockquote>\n<p>Observable.flatMap()平铺变换</p>\n<blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg\" alt=\"\"></p>\n</blockquote>\n<h1 id=\"3-RxJava线程调度\"><a href=\"#3-RxJava线程调度\" class=\"headerlink\" title=\"3.RxJava线程调度\"></a>3.RxJava线程调度</h1><p>1.RxJava线程控制</p>\n<blockquote>\n<p>Observable.subscribeOn(Schedulers.io())指定被观察运行线程(订阅线程)</p>\n<p>Observable.observeOn(AndroidSchedulers.mainThread)指定观察者运行线程</p>\n<p>Observable.doOnSubscribe(Schedulers.io())被观察者开始执行前调用</p>\n</blockquote>\n<p>2.Schedulers介绍</p>\n<blockquote>\n<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程（这是默认的）。</p>\n<p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n<p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n<p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n<p>AndroidSchedulers.mainThread()，是RxAndroid 中一个对 RxJava 的轻量级扩展为了Android 的主线程提供 Scheduler，它指定的操作将在 Android 主线程运行。   </p>\n</blockquote>\n<h1 id=\"4-结尾\"><a href=\"#4-结尾\" class=\"headerlink\" title=\"4.结尾\"></a>4.结尾</h1><p>以上图片资源皆来至于 <a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">RxJava基础详解-扔物线</a></p>\n","excerpt":"<hr>\n<h1 id=\"1-RxJava基础详解-扔物线\"><a href=\"#1-RxJava基础详解-扔物线\" class=\"headerlink\" title=\"1.RxJava基础详解-扔物线\"></a>1.<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">RxJava基础详解-扔物线</a></h1><h1 id=\"2-RxJava常用方法总结\"><a href=\"#2-RxJava常用方法总结\" class=\"headerlink\" title=\"2.RxJava常用方法总结\"></a>2.RxJava常用方法总结</h1><p>RxJava 的观察者模式</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg\" alt=\"\"></p>\n<p>Observable.just(T…)方法</p>\n<blockquote>\n<p><img src=\"http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg\" alt=\"\"><br>Observable.just()动画显示<br><img src=\"http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif\" alt=\"\"></p>\n</blockquote>\n<p>Observable.from(T[])分发集合方法(图类似just())</p>","more":"<p>Observable.map()直接变换</p>\n<blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg\" alt=\"\"></p>\n</blockquote>\n<p>Observable.flatMap()平铺变换</p>\n<blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg\" alt=\"\"></p>\n</blockquote>\n<h1 id=\"3-RxJava线程调度\"><a href=\"#3-RxJava线程调度\" class=\"headerlink\" title=\"3.RxJava线程调度\"></a>3.RxJava线程调度</h1><p>1.RxJava线程控制</p>\n<blockquote>\n<p>Observable.subscribeOn(Schedulers.io())指定被观察运行线程(订阅线程)</p>\n<p>Observable.observeOn(AndroidSchedulers.mainThread)指定观察者运行线程</p>\n<p>Observable.doOnSubscribe(Schedulers.io())被观察者开始执行前调用</p>\n</blockquote>\n<p>2.Schedulers介绍</p>\n<blockquote>\n<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程（这是默认的）。</p>\n<p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n<p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n<p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n<p>AndroidSchedulers.mainThread()，是RxAndroid 中一个对 RxJava 的轻量级扩展为了Android 的主线程提供 Scheduler，它指定的操作将在 Android 主线程运行。   </p>\n</blockquote>\n<h1 id=\"4-结尾\"><a href=\"#4-结尾\" class=\"headerlink\" title=\"4.结尾\"></a>4.结尾</h1><p>以上图片资源皆来至于 <a href=\"http://gank.io/post/560e15be2dca930e00da1083\">RxJava基础详解-扔物线</a></p>"},{"layout":"post","title":"【Android基础】MVP模式学习及使用","date":"2017-04-11T10:41:32.000Z","comments":1,"_content":"---\nGoogle官方推出MVP模式有一段时间，MVP模式在android项目中使用也越来越广泛。作为一个Android开发人员，学会使用MVP模式，那也相当的重要。\n# 一、什么是MVP\nMVP从MVC架构模式演化而来， MVC分别代表模型、视图和控制器，在Android中，定义Class类作为模型，Layout XML表示视图，而Activity用作控制器，这样一来，在Activity中充斥了大量代码，无论是从扩展性和重用性都无法达到理想的效果。所以个人认为，MVC分层在Android App开发中没有解决问题。而MVP解决了这个问题。\n\n MVP即为Model、View和Presenter。Model表示模型，实现数据存储与业务逻辑；View表示视图，提供用户交互的接口；Presenter表示主导器，相当于MVC中的Controller但比Controller更灵活。MVP的关系如图所示。\n\n![](http://img.blog.csdn.net/20160605143622019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### **从上图可以看出：**\n\nA） View将功能委托给Presenter完成，Presenter调用Model完成业务功能与数据存储，并再次通过View更新UI；\n\nB） View和Model没有直接关联，无法相互调用；\n\nC） Presenter和View可以相互调用；\n\nD） Presenter调用Model完成业务功能。\n\n<!-- more -->\n### **MVP的优点：**\n\nA） 各个层次之间的职责更加单一清晰；\n\nB） 很大程度上降低了代码的耦合度；\n\nC） 复用性大大提高；\n\nD） 面向接口编程，定义与实现分离，方便测试与维护；\n\nE） 代码更简洁。\n \n \n\n### **MVP的缺点：**\n\nA） 类变得更多了；\n\nB） 组件与组件之间的关系很复杂。\n\n# 二、MVP的使用\nGoogle官方在推出MVP模式时，也给出了一个使用MVP模式的DEMO([TODO-MVP](https://github.com/googlesamples/android-architecture/tree/todo-mvp/)),通过此Demo，细细阅读，细细评味。相信，很快你就会掌握MVP模式的使用方法。\n\nDEMO项目截图:\n\n![](http://7xohx8.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-10%20%E4%B8%8B%E5%8D%883.53.20.png)\n\n使用注意：虽然MVP模式非常的给力，但我们也不能乱用。需要结合我们项目实际情况来使用，对于功能比较简单的界面，其实MVC模式相对来说还是比较适合，毕竟功能简单，代码量也不会很多。对于功能比较复杂的界面，建议使用MVP模式来优化流程。\n\n# 三、相关链接\n\n[Android Architecture Blueprints 学习之 TODO-MVP（一）](http://www.tuicool.com/articles/zqiiu2y);\n\n[Android Architecture Blueprints 学习之 TODO-MVP（二）](http://www.tuicool.com/articles/qyIVV3q);\n\n[Android Architecture Blueprints 学习之 TODO-MVP（三）](http://www.tuicool.com/articles/UrmMfyB);","source":"_posts/tech_android_mvp.md","raw":"---\nlayout: post\ntitle: \"【Android基础】MVP模式学习及使用\"\ndate: 4/11/2017 6:41:32 PM \ncomments: true\ntags: \n\t- 技术 \n\t- Android\n\t- Android基础\n\t- MVP\n---\n---\nGoogle官方推出MVP模式有一段时间，MVP模式在android项目中使用也越来越广泛。作为一个Android开发人员，学会使用MVP模式，那也相当的重要。\n# 一、什么是MVP\nMVP从MVC架构模式演化而来， MVC分别代表模型、视图和控制器，在Android中，定义Class类作为模型，Layout XML表示视图，而Activity用作控制器，这样一来，在Activity中充斥了大量代码，无论是从扩展性和重用性都无法达到理想的效果。所以个人认为，MVC分层在Android App开发中没有解决问题。而MVP解决了这个问题。\n\n MVP即为Model、View和Presenter。Model表示模型，实现数据存储与业务逻辑；View表示视图，提供用户交互的接口；Presenter表示主导器，相当于MVC中的Controller但比Controller更灵活。MVP的关系如图所示。\n\n![](http://img.blog.csdn.net/20160605143622019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### **从上图可以看出：**\n\nA） View将功能委托给Presenter完成，Presenter调用Model完成业务功能与数据存储，并再次通过View更新UI；\n\nB） View和Model没有直接关联，无法相互调用；\n\nC） Presenter和View可以相互调用；\n\nD） Presenter调用Model完成业务功能。\n\n<!-- more -->\n### **MVP的优点：**\n\nA） 各个层次之间的职责更加单一清晰；\n\nB） 很大程度上降低了代码的耦合度；\n\nC） 复用性大大提高；\n\nD） 面向接口编程，定义与实现分离，方便测试与维护；\n\nE） 代码更简洁。\n \n \n\n### **MVP的缺点：**\n\nA） 类变得更多了；\n\nB） 组件与组件之间的关系很复杂。\n\n# 二、MVP的使用\nGoogle官方在推出MVP模式时，也给出了一个使用MVP模式的DEMO([TODO-MVP](https://github.com/googlesamples/android-architecture/tree/todo-mvp/)),通过此Demo，细细阅读，细细评味。相信，很快你就会掌握MVP模式的使用方法。\n\nDEMO项目截图:\n\n![](http://7xohx8.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-10%20%E4%B8%8B%E5%8D%883.53.20.png)\n\n使用注意：虽然MVP模式非常的给力，但我们也不能乱用。需要结合我们项目实际情况来使用，对于功能比较简单的界面，其实MVC模式相对来说还是比较适合，毕竟功能简单，代码量也不会很多。对于功能比较复杂的界面，建议使用MVP模式来优化流程。\n\n# 三、相关链接\n\n[Android Architecture Blueprints 学习之 TODO-MVP（一）](http://www.tuicool.com/articles/zqiiu2y);\n\n[Android Architecture Blueprints 学习之 TODO-MVP（二）](http://www.tuicool.com/articles/qyIVV3q);\n\n[Android Architecture Blueprints 学习之 TODO-MVP（三）](http://www.tuicool.com/articles/UrmMfyB);","slug":"tech_android_mvp","published":1,"updated":"2017-04-13T11:09:31.939Z","photos":[],"link":"","_id":"cj2sutc4q0007v0lkftbzvoif","content":"<hr>\n<p>Google官方推出MVP模式有一段时间，MVP模式在android项目中使用也越来越广泛。作为一个Android开发人员，学会使用MVP模式，那也相当的重要。</p>\n<h1 id=\"一、什么是MVP\"><a href=\"#一、什么是MVP\" class=\"headerlink\" title=\"一、什么是MVP\"></a>一、什么是MVP</h1><p>MVP从MVC架构模式演化而来， MVC分别代表模型、视图和控制器，在Android中，定义Class类作为模型，Layout XML表示视图，而Activity用作控制器，这样一来，在Activity中充斥了大量代码，无论是从扩展性和重用性都无法达到理想的效果。所以个人认为，MVC分层在Android App开发中没有解决问题。而MVP解决了这个问题。</p>\n<p> MVP即为Model、View和Presenter。Model表示模型，实现数据存储与业务逻辑；View表示视图，提供用户交互的接口；Presenter表示主导器，相当于MVC中的Controller但比Controller更灵活。MVP的关系如图所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20160605143622019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"从上图可以看出：\"><a href=\"#从上图可以看出：\" class=\"headerlink\" title=\"从上图可以看出：\"></a><strong>从上图可以看出：</strong></h3><p>A） View将功能委托给Presenter完成，Presenter调用Model完成业务功能与数据存储，并再次通过View更新UI；</p>\n<p>B） View和Model没有直接关联，无法相互调用；</p>\n<p>C） Presenter和View可以相互调用；</p>\n<p>D） Presenter调用Model完成业务功能。</p>\n<a id=\"more\"></a>\n<h3 id=\"MVP的优点：\"><a href=\"#MVP的优点：\" class=\"headerlink\" title=\"MVP的优点：\"></a><strong>MVP的优点：</strong></h3><p>A） 各个层次之间的职责更加单一清晰；</p>\n<p>B） 很大程度上降低了代码的耦合度；</p>\n<p>C） 复用性大大提高；</p>\n<p>D） 面向接口编程，定义与实现分离，方便测试与维护；</p>\n<p>E） 代码更简洁。</p>\n<h3 id=\"MVP的缺点：\"><a href=\"#MVP的缺点：\" class=\"headerlink\" title=\"MVP的缺点：\"></a><strong>MVP的缺点：</strong></h3><p>A） 类变得更多了；</p>\n<p>B） 组件与组件之间的关系很复杂。</p>\n<h1 id=\"二、MVP的使用\"><a href=\"#二、MVP的使用\" class=\"headerlink\" title=\"二、MVP的使用\"></a>二、MVP的使用</h1><p>Google官方在推出MVP模式时，也给出了一个使用MVP模式的DEMO(<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp/\" target=\"_blank\" rel=\"external\">TODO-MVP</a>),通过此Demo，细细阅读，细细评味。相信，很快你就会掌握MVP模式的使用方法。</p>\n<p>DEMO项目截图:</p>\n<p><img src=\"http://7xohx8.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-10%20%E4%B8%8B%E5%8D%883.53.20.png\" alt=\"\"></p>\n<p>使用注意：虽然MVP模式非常的给力，但我们也不能乱用。需要结合我们项目实际情况来使用，对于功能比较简单的界面，其实MVC模式相对来说还是比较适合，毕竟功能简单，代码量也不会很多。对于功能比较复杂的界面，建议使用MVP模式来优化流程。</p>\n<h1 id=\"三、相关链接\"><a href=\"#三、相关链接\" class=\"headerlink\" title=\"三、相关链接\"></a>三、相关链接</h1><p><a href=\"http://www.tuicool.com/articles/zqiiu2y\" target=\"_blank\" rel=\"external\">Android Architecture Blueprints 学习之 TODO-MVP（一）</a>;</p>\n<p><a href=\"http://www.tuicool.com/articles/qyIVV3q\" target=\"_blank\" rel=\"external\">Android Architecture Blueprints 学习之 TODO-MVP（二）</a>;</p>\n<p><a href=\"http://www.tuicool.com/articles/UrmMfyB\" target=\"_blank\" rel=\"external\">Android Architecture Blueprints 学习之 TODO-MVP（三）</a>;</p>\n","excerpt":"<hr>\n<p>Google官方推出MVP模式有一段时间，MVP模式在android项目中使用也越来越广泛。作为一个Android开发人员，学会使用MVP模式，那也相当的重要。</p>\n<h1 id=\"一、什么是MVP\"><a href=\"#一、什么是MVP\" class=\"headerlink\" title=\"一、什么是MVP\"></a>一、什么是MVP</h1><p>MVP从MVC架构模式演化而来， MVC分别代表模型、视图和控制器，在Android中，定义Class类作为模型，Layout XML表示视图，而Activity用作控制器，这样一来，在Activity中充斥了大量代码，无论是从扩展性和重用性都无法达到理想的效果。所以个人认为，MVC分层在Android App开发中没有解决问题。而MVP解决了这个问题。</p>\n<p> MVP即为Model、View和Presenter。Model表示模型，实现数据存储与业务逻辑；View表示视图，提供用户交互的接口；Presenter表示主导器，相当于MVC中的Controller但比Controller更灵活。MVP的关系如图所示。</p>\n<p><img src=\"http://img.blog.csdn.net/20160605143622019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"从上图可以看出：\"><a href=\"#从上图可以看出：\" class=\"headerlink\" title=\"从上图可以看出：\"></a><strong>从上图可以看出：</strong></h3><p>A） View将功能委托给Presenter完成，Presenter调用Model完成业务功能与数据存储，并再次通过View更新UI；</p>\n<p>B） View和Model没有直接关联，无法相互调用；</p>\n<p>C） Presenter和View可以相互调用；</p>\n<p>D） Presenter调用Model完成业务功能。</p>","more":"<h3 id=\"MVP的优点：\"><a href=\"#MVP的优点：\" class=\"headerlink\" title=\"MVP的优点：\"></a><strong>MVP的优点：</strong></h3><p>A） 各个层次之间的职责更加单一清晰；</p>\n<p>B） 很大程度上降低了代码的耦合度；</p>\n<p>C） 复用性大大提高；</p>\n<p>D） 面向接口编程，定义与实现分离，方便测试与维护；</p>\n<p>E） 代码更简洁。</p>\n<h3 id=\"MVP的缺点：\"><a href=\"#MVP的缺点：\" class=\"headerlink\" title=\"MVP的缺点：\"></a><strong>MVP的缺点：</strong></h3><p>A） 类变得更多了；</p>\n<p>B） 组件与组件之间的关系很复杂。</p>\n<h1 id=\"二、MVP的使用\"><a href=\"#二、MVP的使用\" class=\"headerlink\" title=\"二、MVP的使用\"></a>二、MVP的使用</h1><p>Google官方在推出MVP模式时，也给出了一个使用MVP模式的DEMO(<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp/\">TODO-MVP</a>),通过此Demo，细细阅读，细细评味。相信，很快你就会掌握MVP模式的使用方法。</p>\n<p>DEMO项目截图:</p>\n<p><img src=\"http://7xohx8.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-10%20%E4%B8%8B%E5%8D%883.53.20.png\" alt=\"\"></p>\n<p>使用注意：虽然MVP模式非常的给力，但我们也不能乱用。需要结合我们项目实际情况来使用，对于功能比较简单的界面，其实MVC模式相对来说还是比较适合，毕竟功能简单，代码量也不会很多。对于功能比较复杂的界面，建议使用MVP模式来优化流程。</p>\n<h1 id=\"三、相关链接\"><a href=\"#三、相关链接\" class=\"headerlink\" title=\"三、相关链接\"></a>三、相关链接</h1><p><a href=\"http://www.tuicool.com/articles/zqiiu2y\">Android Architecture Blueprints 学习之 TODO-MVP（一）</a>;</p>\n<p><a href=\"http://www.tuicool.com/articles/qyIVV3q\">Android Architecture Blueprints 学习之 TODO-MVP（二）</a>;</p>\n<p><a href=\"http://www.tuicool.com/articles/UrmMfyB\">Android Architecture Blueprints 学习之 TODO-MVP（三）</a>;</p>"},{"layout":"post","title":"通过Hexo自建博客","date":"2017-03-12T10:41:32.000Z","comments":1,"_content":"---\n【作为一名技术开发人员，搭建一个属于自己的博客，记录自己，沉淀自己，还是很重要的。】\n\n年前给自己定一个目标：搭建博客，记录成长。之后，你懂的，就有下面的内容：\n\n# 一、Hexo介绍、安装及实操\n[Hexo平台搭建官网](https://hexo.io/zh-cn/docs/index.html)\n\n通过hexo官网步骤，可以很快的搭建hexo平台。通过命令hexo s,然后，在浏览器中输入http://localhost:4000/ 网站显示如下：\n![](/assets/img/tech_create_blog_record_img01.png)\n\n# 二、Hexo主题选择\n通过Hexo官网，搭建的博客使用的主题为hexo自带的主题landscape,效果如上图。如果你希望你的博客更炫，更酷，推荐使用第三方的Hexo主题。主题选择：\n<!-- more -->\n1.[Next主题](http://theme-next.iissnan.com/)\n\n2.[Hexo主题集合(github)](https://github.com/hexojs/hexo/wiki/Themes)\n\n3.[Hexo主题集合(知乎)](https://www.zhihu.com/question/24422335)\n\n**主题配置：**\n\n```\n在hexo配置文件_config.yml中修改 theme: 主题名字（如：theme: landscape)\n```\n\n**非Hexo主题(搭建网站可用)**\n\n[jekyll主题集合(官网)](http://jekyllthemes.org/)\n\n[jekyll主题集合(github)](https://github.com/jekyll/jekyll/wiki/Sites)\n\n[WordPress主题集合](https://wordpress.org/themes/)\n\n# 三、部署到Github上\n [Github官网](https://github.com/)\n\n1.注册Github账号\n\n2.创建Repository（格式为：github账号名.github.io）\n\n```\n注意Repository的名字必须和账号名相同。比如Github账号是angelen10，那么应该创建的Repository的名字是：angelen10.github.io。\n```\n\n3.在hexo配置文件_config.yml中配置git路径\n\n```\nxxxx为github账户名\ndeploy: \n  type: git \n  repository: git@github.com:xxxxx/xxxx.github.io.git\n  branch: master\n```\n\n4.设置SSH keys绑定到你建的repository\n\n[设置SSH key官方教程](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n5.Hexo基本操作命令\n\n```\n\nhexo g == hexo generate\n\nhexo d == hexo deploy\n\nhexo s == hexo server\n\nhexo n == hexo new\n\n```\n\n# 四、相关链接\n\n[搭建Hexo博客并部署到Github详细教程](http://blog.sina.com.cn/s/blog_4c44643f0102vuju.html)\n\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n\n[利用Github Page 搭建个人博客网站](http://blog.csdn.net/tzs_1041218129/article/details/53214497)\n\n\n\n\n\n\n\n\n\n","source":"_posts/tech_create_blog_record.md","raw":"---\nlayout: post\ntitle: \"通过Hexo自建博客\"\ndate: 3/12/2017 6:41:32 PM \ncomments: true\ntags: \n\t- 技术 \n\t- 博客搭建\n---\n---\n【作为一名技术开发人员，搭建一个属于自己的博客，记录自己，沉淀自己，还是很重要的。】\n\n年前给自己定一个目标：搭建博客，记录成长。之后，你懂的，就有下面的内容：\n\n# 一、Hexo介绍、安装及实操\n[Hexo平台搭建官网](https://hexo.io/zh-cn/docs/index.html)\n\n通过hexo官网步骤，可以很快的搭建hexo平台。通过命令hexo s,然后，在浏览器中输入http://localhost:4000/ 网站显示如下：\n![](/assets/img/tech_create_blog_record_img01.png)\n\n# 二、Hexo主题选择\n通过Hexo官网，搭建的博客使用的主题为hexo自带的主题landscape,效果如上图。如果你希望你的博客更炫，更酷，推荐使用第三方的Hexo主题。主题选择：\n<!-- more -->\n1.[Next主题](http://theme-next.iissnan.com/)\n\n2.[Hexo主题集合(github)](https://github.com/hexojs/hexo/wiki/Themes)\n\n3.[Hexo主题集合(知乎)](https://www.zhihu.com/question/24422335)\n\n**主题配置：**\n\n```\n在hexo配置文件_config.yml中修改 theme: 主题名字（如：theme: landscape)\n```\n\n**非Hexo主题(搭建网站可用)**\n\n[jekyll主题集合(官网)](http://jekyllthemes.org/)\n\n[jekyll主题集合(github)](https://github.com/jekyll/jekyll/wiki/Sites)\n\n[WordPress主题集合](https://wordpress.org/themes/)\n\n# 三、部署到Github上\n [Github官网](https://github.com/)\n\n1.注册Github账号\n\n2.创建Repository（格式为：github账号名.github.io）\n\n```\n注意Repository的名字必须和账号名相同。比如Github账号是angelen10，那么应该创建的Repository的名字是：angelen10.github.io。\n```\n\n3.在hexo配置文件_config.yml中配置git路径\n\n```\nxxxx为github账户名\ndeploy: \n  type: git \n  repository: git@github.com:xxxxx/xxxx.github.io.git\n  branch: master\n```\n\n4.设置SSH keys绑定到你建的repository\n\n[设置SSH key官方教程](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n5.Hexo基本操作命令\n\n```\n\nhexo g == hexo generate\n\nhexo d == hexo deploy\n\nhexo s == hexo server\n\nhexo n == hexo new\n\n```\n\n# 四、相关链接\n\n[搭建Hexo博客并部署到Github详细教程](http://blog.sina.com.cn/s/blog_4c44643f0102vuju.html)\n\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n\n[利用Github Page 搭建个人博客网站](http://blog.csdn.net/tzs_1041218129/article/details/53214497)\n\n\n\n\n\n\n\n\n\n","slug":"tech_create_blog_record","published":1,"updated":"2017-04-21T03:05:48.577Z","photos":[],"link":"","_id":"cj2sutc4r0008v0lkg8vbmdfy","content":"<hr>\n<p>【作为一名技术开发人员，搭建一个属于自己的博客，记录自己，沉淀自己，还是很重要的。】</p>\n<p>年前给自己定一个目标：搭建博客，记录成长。之后，你懂的，就有下面的内容：</p>\n<h1 id=\"一、Hexo介绍、安装及实操\"><a href=\"#一、Hexo介绍、安装及实操\" class=\"headerlink\" title=\"一、Hexo介绍、安装及实操\"></a>一、Hexo介绍、安装及实操</h1><p><a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">Hexo平台搭建官网</a></p>\n<p>通过hexo官网步骤，可以很快的搭建hexo平台。通过命令hexo s,然后，在浏览器中输入<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a> 网站显示如下：<br><img src=\"/assets/img/tech_create_blog_record_img01.png\" alt=\"\"></p>\n<h1 id=\"二、Hexo主题选择\"><a href=\"#二、Hexo主题选择\" class=\"headerlink\" title=\"二、Hexo主题选择\"></a>二、Hexo主题选择</h1><p>通过Hexo官网，搭建的博客使用的主题为hexo自带的主题landscape,效果如上图。如果你希望你的博客更炫，更酷，推荐使用第三方的Hexo主题。主题选择：<br><a id=\"more\"></a><br>1.<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">Next主题</a></p>\n<p>2.<a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">Hexo主题集合(github)</a></p>\n<p>3.<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"external\">Hexo主题集合(知乎)</a></p>\n<p><strong>主题配置：</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在hexo配置文件_config.yml中修改 <span class=\"string\">theme:</span> 主题名字（如：<span class=\"string\">theme:</span> landscape)</div></pre></td></tr></table></figure>\n<p><strong>非Hexo主题(搭建网站可用)</strong></p>\n<p><a href=\"http://jekyllthemes.org/\" target=\"_blank\" rel=\"external\">jekyll主题集合(官网)</a></p>\n<p><a href=\"https://github.com/jekyll/jekyll/wiki/Sites\" target=\"_blank\" rel=\"external\">jekyll主题集合(github)</a></p>\n<p><a href=\"https://wordpress.org/themes/\" target=\"_blank\" rel=\"external\">WordPress主题集合</a></p>\n<h1 id=\"三、部署到Github上\"><a href=\"#三、部署到Github上\" class=\"headerlink\" title=\"三、部署到Github上\"></a>三、部署到Github上</h1><p> <a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github官网</a></p>\n<p>1.注册Github账号</p>\n<p>2.创建Repository（格式为：github账号名.github.io）</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">注意Repository的名字必须和账号名相同。比如Github账号是angelen10，那么应该创建的Repository的名字是：angelen10<span class=\"selector-class\">.github</span><span class=\"selector-class\">.io</span>。</div></pre></td></tr></table></figure>\n<p>3.在hexo配置文件_config.yml中配置git路径</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxx为github账户名</div><div class=\"line\">deploy: </div><div class=\"line\">  type: git </div><div class=\"line\">  repository: git@github<span class=\"selector-class\">.com</span>:xxxxx/xxxx<span class=\"selector-class\">.github</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.git</span></div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>4.设置SSH keys绑定到你建的repository</p>\n<p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\" target=\"_blank\" rel=\"external\">设置SSH key官方教程</a></p>\n<p>5.Hexo基本操作命令</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">hexo g == hexo <span class=\"keyword\">generate</span></div><div class=\"line\"></div><div class=\"line\">hexo d == hexo deploy</div><div class=\"line\"></div><div class=\"line\">hexo s == hexo server</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo <span class=\"keyword\">new</span></div></pre></td></tr></table></figure>\n<h1 id=\"四、相关链接\"><a href=\"#四、相关链接\" class=\"headerlink\" title=\"四、相关链接\"></a>四、相关链接</h1><p><a href=\"http://blog.sina.com.cn/s/blog_4c44643f0102vuju.html\" target=\"_blank\" rel=\"external\">搭建Hexo博客并部署到Github详细教程</a></p>\n<p><a href=\"http://www.jianshu.com/p/05289a4bc8b2\" target=\"_blank\" rel=\"external\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></p>\n<p><a href=\"http://blog.csdn.net/tzs_1041218129/article/details/53214497\" target=\"_blank\" rel=\"external\">利用Github Page 搭建个人博客网站</a></p>\n","excerpt":"<hr>\n<p>【作为一名技术开发人员，搭建一个属于自己的博客，记录自己，沉淀自己，还是很重要的。】</p>\n<p>年前给自己定一个目标：搭建博客，记录成长。之后，你懂的，就有下面的内容：</p>\n<h1 id=\"一、Hexo介绍、安装及实操\"><a href=\"#一、Hexo介绍、安装及实操\" class=\"headerlink\" title=\"一、Hexo介绍、安装及实操\"></a>一、Hexo介绍、安装及实操</h1><p><a href=\"https://hexo.io/zh-cn/docs/index.html\">Hexo平台搭建官网</a></p>\n<p>通过hexo官网步骤，可以很快的搭建hexo平台。通过命令hexo s,然后，在浏览器中输入<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 网站显示如下：<br><img src=\"/assets/img/tech_create_blog_record_img01.png\" alt=\"\"></p>\n<h1 id=\"二、Hexo主题选择\"><a href=\"#二、Hexo主题选择\" class=\"headerlink\" title=\"二、Hexo主题选择\"></a>二、Hexo主题选择</h1><p>通过Hexo官网，搭建的博客使用的主题为hexo自带的主题landscape,效果如上图。如果你希望你的博客更炫，更酷，推荐使用第三方的Hexo主题。主题选择：<br>","more":"<br>1.<a href=\"http://theme-next.iissnan.com/\">Next主题</a></p>\n<p>2.<a href=\"https://github.com/hexojs/hexo/wiki/Themes\">Hexo主题集合(github)</a></p>\n<p>3.<a href=\"https://www.zhihu.com/question/24422335\">Hexo主题集合(知乎)</a></p>\n<p><strong>主题配置：</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在hexo配置文件_config.yml中修改 <span class=\"string\">theme:</span> 主题名字（如：<span class=\"string\">theme:</span> landscape)</div></pre></td></tr></table></figure>\n<p><strong>非Hexo主题(搭建网站可用)</strong></p>\n<p><a href=\"http://jekyllthemes.org/\">jekyll主题集合(官网)</a></p>\n<p><a href=\"https://github.com/jekyll/jekyll/wiki/Sites\">jekyll主题集合(github)</a></p>\n<p><a href=\"https://wordpress.org/themes/\">WordPress主题集合</a></p>\n<h1 id=\"三、部署到Github上\"><a href=\"#三、部署到Github上\" class=\"headerlink\" title=\"三、部署到Github上\"></a>三、部署到Github上</h1><p> <a href=\"https://github.com/\">Github官网</a></p>\n<p>1.注册Github账号</p>\n<p>2.创建Repository（格式为：github账号名.github.io）</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">注意Repository的名字必须和账号名相同。比如Github账号是angelen10，那么应该创建的Repository的名字是：angelen10<span class=\"selector-class\">.github</span><span class=\"selector-class\">.io</span>。</div></pre></td></tr></table></figure>\n<p>3.在hexo配置文件_config.yml中配置git路径</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxx为github账户名</div><div class=\"line\">deploy: </div><div class=\"line\">  type: git </div><div class=\"line\">  repository: git@github<span class=\"selector-class\">.com</span>:xxxxx/xxxx<span class=\"selector-class\">.github</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.git</span></div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>4.设置SSH keys绑定到你建的repository</p>\n<p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\">设置SSH key官方教程</a></p>\n<p>5.Hexo基本操作命令</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">hexo g == hexo <span class=\"keyword\">generate</span></div><div class=\"line\"></div><div class=\"line\">hexo d == hexo deploy</div><div class=\"line\"></div><div class=\"line\">hexo s == hexo server</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo <span class=\"keyword\">new</span></div></pre></td></tr></table></figure>\n<h1 id=\"四、相关链接\"><a href=\"#四、相关链接\" class=\"headerlink\" title=\"四、相关链接\"></a>四、相关链接</h1><p><a href=\"http://blog.sina.com.cn/s/blog_4c44643f0102vuju.html\">搭建Hexo博客并部署到Github详细教程</a></p>\n<p><a href=\"http://www.jianshu.com/p/05289a4bc8b2\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></p>\n<p><a href=\"http://blog.csdn.net/tzs_1041218129/article/details/53214497\">利用Github Page 搭建个人博客网站</a></p>"},{"layout":"post","title":"中国历史","date":"2017-05-10T06:21:44.000Z","comments":1,"_content":"---\n\n三皇五帝始，尧舜禹相传。夏商与西周，东周分两段。春秋和战国，一统秦两汉。\n三分魏蜀吴，二晋前后延。南北朝并立，隋唐五代传。宋元明清后，皇朝自此完。\n\n-----\n![](/assets/img/think_history_01.png)\n![](/assets/img/think_history_02.png)\n![](/assets/img/think_history_03.png)\n![](/assets/img/think_history_04.png)\n<!-- more -->\n-----\n**1．夏（约前2070-1600年）**\n210万，包括长江以北的湖北，河南，安徽，山东，河北，山西，京津和江苏，陕西的一部分\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051149384529020.jpg)\n\n** 2．商（约前1600-1046年）**\n320万，除上述土地外，还包括陕西江苏的剩余土地，辽宁，甘肃，湖南，浙江，重庆和四川的一部分\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051150139423592.jpg)\n\n**3．周（约前1046-221年）**\n340万，基本与商差不多，在辽宁和重庆四川的范围更大\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051151160306678.jpg)\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152037973888.jpg)\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152261219492.jpg)\n\n**4．秦（前221-207年）**\n360万，还包括整个宁夏并包括重庆全部和更大的几乎整个四川的土地，东晋各诸侯国的国土总合与西周基本相同\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152595834055.jpg)\n\n**5．汉（前206-公元220年）**\n在两汉最顶盛的时代，由西汉武帝和后人西汉宣帝、东汉光武帝、东汉明帝打下了惊人的国土。现在朝鲜的几乎全部，越南的北方。大半的新疆，包括中亚相当大的土地都在汉的西域都护府范围中，还有全部的四川和云贵的大片土地，辽宁的全部土地也在汉治下，和吉林的一片土地，内蒙也有相当大的土地在汉的治内，估约国土为1040万平方公里。东汉后期出现严重缩水，失去了云贵和内蒙的土地，新疆北部的土地也丧失殆尽，国土应为890万平方公里。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051321524057953.jpg)\n\n**6．三国（220-280年）**\n魏：530万平方公里，所有的长江以北的汉人地区和在新疆甚至中亚的土地，也包括朝鲜的少量土地和内蒙的土地；\n吴：240万平方公里，浙江，江西，福建，广东，海南，广西和越南北方。\n蜀：170万平方公里，湖南，四川，重庆，贵州，云南，和青海的一小部分，缅甸的极北方。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051322266165185.jpg)\n\n**7．晋（265-420年）**\n西晋的国土大小为920万平方公里。在云贵两地上略少于蜀的控制，在越南和朝鲜的土地缩小了。但略增加了内蒙的土地。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323111394665.jpg)\n\n\n**8．五胡十六国（304-439年）**\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323282052059.jpg)\n\n**9．南北朝（420-581年）**\n国土总合约为935万平方公里，增加了几乎所有剩余的内蒙和部分外蒙的土地\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051324030096475.jpg)\n\n**10．隋（581-618年）**\n国土为840万平方公里，突厥占领了甘肃和宁夏相当大的土地，云南和贵州也正走向独立，丧失了所有在越南和朝鲜的国土\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325135214460.jpg)\n\n**11．唐（618-907年）**\n强盛时的唐国土大的非常惊人，比现在中国少黑龙江和西藏与云南，多了中亚的大片土地，大半个蒙古国和俄贝加尔湖，共1240万平方公里，在数十年后竟缩为1030万平方公里，安史之乱后更是缩为800万平方公里，可谓史上巨大的缩水。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325444403275.jpg)\n\n**12．五代十国（907-979）**\n国家太多，地图略\n\n**13．宋（960-1179年）**\n国土为460万平方公里，与现在中国比没有新疆，甘肃，宁夏，内蒙，整个东北三省，青海和西藏，云贵和台湾。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326097595854.jpg)\n\n**12．元（1206-1368年）**\n1680万平方公里，马克思列宁毛泽东都视其是中国的朝代，忽必烈也自称是中国之主。国土包括整个中国和蒙古，和俄罗斯西伯利亚的大片土地，当是中国古代史上的第一\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326277464631.jpg)\n\n**13．明（1368-1644年）**\n国土最大时，比现在少一小半西藏和大半新疆，内蒙古全部和东三省小半土地，俄罗斯极少土地。共710万平方公里。后来大为缩水，丧失西藏新疆和东北台湾，到灭亡时只剩下350万平方公里。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326510684659.jpg)\n\n**14．清（1616-1911年）**\n国土1310万平方公里，整个中国和外蒙和俄罗斯及中亚的一些土地，论大小算是中国各朝代第二。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051327201782867.jpg)\n\n\n\n# 参考文献\n[中国历史朝代顺序表](http://www.diyifanwen.com/tool/lishichaodai/126100035061238.html)\n[中国各朝代历史地图](http://lishi.100xuexi.com/view/trend/20151205/288371.html)\n[世界历史发展视频](http://img1.cache.netease.com/flvplayer081128/~false~0085_V6T2A4508~vimg2.ws.126.net/image/snapshot/2011/2/0/9/V6T2A4509~.swf)\n\n\n\n","source":"_posts/think_china_history_map.md","raw":"---\nlayout: post\ntitle: \"中国历史\"\ndate: 5/10/2017 2:21:44 PM  \ncomments: true\ntags: \n\t- 随想 \n\t- 中国历史\n---\n---\n\n三皇五帝始，尧舜禹相传。夏商与西周，东周分两段。春秋和战国，一统秦两汉。\n三分魏蜀吴，二晋前后延。南北朝并立，隋唐五代传。宋元明清后，皇朝自此完。\n\n-----\n![](/assets/img/think_history_01.png)\n![](/assets/img/think_history_02.png)\n![](/assets/img/think_history_03.png)\n![](/assets/img/think_history_04.png)\n<!-- more -->\n-----\n**1．夏（约前2070-1600年）**\n210万，包括长江以北的湖北，河南，安徽，山东，河北，山西，京津和江苏，陕西的一部分\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051149384529020.jpg)\n\n** 2．商（约前1600-1046年）**\n320万，除上述土地外，还包括陕西江苏的剩余土地，辽宁，甘肃，湖南，浙江，重庆和四川的一部分\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051150139423592.jpg)\n\n**3．周（约前1046-221年）**\n340万，基本与商差不多，在辽宁和重庆四川的范围更大\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051151160306678.jpg)\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152037973888.jpg)\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152261219492.jpg)\n\n**4．秦（前221-207年）**\n360万，还包括整个宁夏并包括重庆全部和更大的几乎整个四川的土地，东晋各诸侯国的国土总合与西周基本相同\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152595834055.jpg)\n\n**5．汉（前206-公元220年）**\n在两汉最顶盛的时代，由西汉武帝和后人西汉宣帝、东汉光武帝、东汉明帝打下了惊人的国土。现在朝鲜的几乎全部，越南的北方。大半的新疆，包括中亚相当大的土地都在汉的西域都护府范围中，还有全部的四川和云贵的大片土地，辽宁的全部土地也在汉治下，和吉林的一片土地，内蒙也有相当大的土地在汉的治内，估约国土为1040万平方公里。东汉后期出现严重缩水，失去了云贵和内蒙的土地，新疆北部的土地也丧失殆尽，国土应为890万平方公里。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051321524057953.jpg)\n\n**6．三国（220-280年）**\n魏：530万平方公里，所有的长江以北的汉人地区和在新疆甚至中亚的土地，也包括朝鲜的少量土地和内蒙的土地；\n吴：240万平方公里，浙江，江西，福建，广东，海南，广西和越南北方。\n蜀：170万平方公里，湖南，四川，重庆，贵州，云南，和青海的一小部分，缅甸的极北方。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051322266165185.jpg)\n\n**7．晋（265-420年）**\n西晋的国土大小为920万平方公里。在云贵两地上略少于蜀的控制，在越南和朝鲜的土地缩小了。但略增加了内蒙的土地。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323111394665.jpg)\n\n\n**8．五胡十六国（304-439年）**\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323282052059.jpg)\n\n**9．南北朝（420-581年）**\n国土总合约为935万平方公里，增加了几乎所有剩余的内蒙和部分外蒙的土地\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051324030096475.jpg)\n\n**10．隋（581-618年）**\n国土为840万平方公里，突厥占领了甘肃和宁夏相当大的土地，云南和贵州也正走向独立，丧失了所有在越南和朝鲜的国土\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325135214460.jpg)\n\n**11．唐（618-907年）**\n强盛时的唐国土大的非常惊人，比现在中国少黑龙江和西藏与云南，多了中亚的大片土地，大半个蒙古国和俄贝加尔湖，共1240万平方公里，在数十年后竟缩为1030万平方公里，安史之乱后更是缩为800万平方公里，可谓史上巨大的缩水。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325444403275.jpg)\n\n**12．五代十国（907-979）**\n国家太多，地图略\n\n**13．宋（960-1179年）**\n国土为460万平方公里，与现在中国比没有新疆，甘肃，宁夏，内蒙，整个东北三省，青海和西藏，云贵和台湾。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326097595854.jpg)\n\n**12．元（1206-1368年）**\n1680万平方公里，马克思列宁毛泽东都视其是中国的朝代，忽必烈也自称是中国之主。国土包括整个中国和蒙古，和俄罗斯西伯利亚的大片土地，当是中国古代史上的第一\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326277464631.jpg)\n\n**13．明（1368-1644年）**\n国土最大时，比现在少一小半西藏和大半新疆，内蒙古全部和东三省小半土地，俄罗斯极少土地。共710万平方公里。后来大为缩水，丧失西藏新疆和东北台湾，到灭亡时只剩下350万平方公里。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326510684659.jpg)\n\n**14．清（1616-1911年）**\n国土1310万平方公里，整个中国和外蒙和俄罗斯及中亚的一些土地，论大小算是中国各朝代第二。\n\n![](http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051327201782867.jpg)\n\n\n\n# 参考文献\n[中国历史朝代顺序表](http://www.diyifanwen.com/tool/lishichaodai/126100035061238.html)\n[中国各朝代历史地图](http://lishi.100xuexi.com/view/trend/20151205/288371.html)\n[世界历史发展视频](http://img1.cache.netease.com/flvplayer081128/~false~0085_V6T2A4508~vimg2.ws.126.net/image/snapshot/2011/2/0/9/V6T2A4509~.swf)\n\n\n\n","slug":"think_china_history_map","published":1,"updated":"2017-05-10T09:08:52.970Z","photos":[],"link":"","_id":"cj2sutc4x000av0lk6fxgwzdi","content":"<hr>\n<p>三皇五帝始，尧舜禹相传。夏商与西周，东周分两段。春秋和战国，一统秦两汉。<br>三分魏蜀吴，二晋前后延。南北朝并立，隋唐五代传。宋元明清后，皇朝自此完。</p>\n<hr>\n<p><img src=\"/assets/img/think_history_01.png\" alt=\"\"><br><img src=\"/assets/img/think_history_02.png\" alt=\"\"><br><img src=\"/assets/img/think_history_03.png\" alt=\"\"><br><img src=\"/assets/img/think_history_04.png\" alt=\"\"></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p><strong>1．夏（约前2070-1600年）</strong><br>210万，包括长江以北的湖北，河南，安徽，山东，河北，山西，京津和江苏，陕西的一部分</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051149384529020.jpg\" alt=\"\"></p>\n<p><strong> 2．商（约前1600-1046年）</strong><br>320万，除上述土地外，还包括陕西江苏的剩余土地，辽宁，甘肃，湖南，浙江，重庆和四川的一部分</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051150139423592.jpg\" alt=\"\"></p>\n<p><strong>3．周（约前1046-221年）</strong><br>340万，基本与商差不多，在辽宁和重庆四川的范围更大</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051151160306678.jpg\" alt=\"\"><br><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152037973888.jpg\" alt=\"\"><br><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152261219492.jpg\" alt=\"\"></p>\n<p><strong>4．秦（前221-207年）</strong><br>360万，还包括整个宁夏并包括重庆全部和更大的几乎整个四川的土地，东晋各诸侯国的国土总合与西周基本相同</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152595834055.jpg\" alt=\"\"></p>\n<p><strong>5．汉（前206-公元220年）</strong><br>在两汉最顶盛的时代，由西汉武帝和后人西汉宣帝、东汉光武帝、东汉明帝打下了惊人的国土。现在朝鲜的几乎全部，越南的北方。大半的新疆，包括中亚相当大的土地都在汉的西域都护府范围中，还有全部的四川和云贵的大片土地，辽宁的全部土地也在汉治下，和吉林的一片土地，内蒙也有相当大的土地在汉的治内，估约国土为1040万平方公里。东汉后期出现严重缩水，失去了云贵和内蒙的土地，新疆北部的土地也丧失殆尽，国土应为890万平方公里。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051321524057953.jpg\" alt=\"\"></p>\n<p><strong>6．三国（220-280年）</strong><br>魏：530万平方公里，所有的长江以北的汉人地区和在新疆甚至中亚的土地，也包括朝鲜的少量土地和内蒙的土地；<br>吴：240万平方公里，浙江，江西，福建，广东，海南，广西和越南北方。<br>蜀：170万平方公里，湖南，四川，重庆，贵州，云南，和青海的一小部分，缅甸的极北方。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051322266165185.jpg\" alt=\"\"></p>\n<p><strong>7．晋（265-420年）</strong><br>西晋的国土大小为920万平方公里。在云贵两地上略少于蜀的控制，在越南和朝鲜的土地缩小了。但略增加了内蒙的土地。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323111394665.jpg\" alt=\"\"></p>\n<p><strong>8．五胡十六国（304-439年）</strong></p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323282052059.jpg\" alt=\"\"></p>\n<p><strong>9．南北朝（420-581年）</strong><br>国土总合约为935万平方公里，增加了几乎所有剩余的内蒙和部分外蒙的土地</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051324030096475.jpg\" alt=\"\"></p>\n<p><strong>10．隋（581-618年）</strong><br>国土为840万平方公里，突厥占领了甘肃和宁夏相当大的土地，云南和贵州也正走向独立，丧失了所有在越南和朝鲜的国土</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325135214460.jpg\" alt=\"\"></p>\n<p><strong>11．唐（618-907年）</strong><br>强盛时的唐国土大的非常惊人，比现在中国少黑龙江和西藏与云南，多了中亚的大片土地，大半个蒙古国和俄贝加尔湖，共1240万平方公里，在数十年后竟缩为1030万平方公里，安史之乱后更是缩为800万平方公里，可谓史上巨大的缩水。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325444403275.jpg\" alt=\"\"></p>\n<p><strong>12．五代十国（907-979）</strong><br>国家太多，地图略</p>\n<p><strong>13．宋（960-1179年）</strong><br>国土为460万平方公里，与现在中国比没有新疆，甘肃，宁夏，内蒙，整个东北三省，青海和西藏，云贵和台湾。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326097595854.jpg\" alt=\"\"></p>\n<p><strong>12．元（1206-1368年）</strong><br>1680万平方公里，马克思列宁毛泽东都视其是中国的朝代，忽必烈也自称是中国之主。国土包括整个中国和蒙古，和俄罗斯西伯利亚的大片土地，当是中国古代史上的第一</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326277464631.jpg\" alt=\"\"></p>\n<p><strong>13．明（1368-1644年）</strong><br>国土最大时，比现在少一小半西藏和大半新疆，内蒙古全部和东三省小半土地，俄罗斯极少土地。共710万平方公里。后来大为缩水，丧失西藏新疆和东北台湾，到灭亡时只剩下350万平方公里。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326510684659.jpg\" alt=\"\"></p>\n<p><strong>14．清（1616-1911年）</strong><br>国土1310万平方公里，整个中国和外蒙和俄罗斯及中亚的一些土地，论大小算是中国各朝代第二。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051327201782867.jpg\" alt=\"\"></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"http://www.diyifanwen.com/tool/lishichaodai/126100035061238.html\" target=\"_blank\" rel=\"external\">中国历史朝代顺序表</a><br><a href=\"http://lishi.100xuexi.com/view/trend/20151205/288371.html\" target=\"_blank\" rel=\"external\">中国各朝代历史地图</a><br><a href=\"http://img1.cache.netease.com/flvplayer081128/~false~0085_V6T2A4508~vimg2.ws.126.net/image/snapshot/2011/2/0/9/V6T2A4509~.swf\" target=\"_blank\" rel=\"external\">世界历史发展视频</a></p>\n","excerpt":"<hr>\n<p>三皇五帝始，尧舜禹相传。夏商与西周，东周分两段。春秋和战国，一统秦两汉。<br>三分魏蜀吴，二晋前后延。南北朝并立，隋唐五代传。宋元明清后，皇朝自此完。</p>\n<hr>\n<p><img src=\"/assets/img/think_history_01.png\" alt=\"\"><br><img src=\"/assets/img/think_history_02.png\" alt=\"\"><br><img src=\"/assets/img/think_history_03.png\" alt=\"\"><br><img src=\"/assets/img/think_history_04.png\" alt=\"\"></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p><strong>1．夏（约前2070-1600年）</strong><br>210万，包括长江以北的湖北，河南，安徽，山东，河北，山西，京津和江苏，陕西的一部分</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051149384529020.jpg\" alt=\"\"></p>\n<p><strong> 2．商（约前1600-1046年）</strong><br>320万，除上述土地外，还包括陕西江苏的剩余土地，辽宁，甘肃，湖南，浙江，重庆和四川的一部分</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051150139423592.jpg\" alt=\"\"></p>\n<p><strong>3．周（约前1046-221年）</strong><br>340万，基本与商差不多，在辽宁和重庆四川的范围更大</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051151160306678.jpg\" alt=\"\"><br><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152037973888.jpg\" alt=\"\"><br><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152261219492.jpg\" alt=\"\"></p>\n<p><strong>4．秦（前221-207年）</strong><br>360万，还包括整个宁夏并包括重庆全部和更大的几乎整个四川的土地，东晋各诸侯国的国土总合与西周基本相同</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051152595834055.jpg\" alt=\"\"></p>\n<p><strong>5．汉（前206-公元220年）</strong><br>在两汉最顶盛的时代，由西汉武帝和后人西汉宣帝、东汉光武帝、东汉明帝打下了惊人的国土。现在朝鲜的几乎全部，越南的北方。大半的新疆，包括中亚相当大的土地都在汉的西域都护府范围中，还有全部的四川和云贵的大片土地，辽宁的全部土地也在汉治下，和吉林的一片土地，内蒙也有相当大的土地在汉的治内，估约国土为1040万平方公里。东汉后期出现严重缩水，失去了云贵和内蒙的土地，新疆北部的土地也丧失殆尽，国土应为890万平方公里。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051321524057953.jpg\" alt=\"\"></p>\n<p><strong>6．三国（220-280年）</strong><br>魏：530万平方公里，所有的长江以北的汉人地区和在新疆甚至中亚的土地，也包括朝鲜的少量土地和内蒙的土地；<br>吴：240万平方公里，浙江，江西，福建，广东，海南，广西和越南北方。<br>蜀：170万平方公里，湖南，四川，重庆，贵州，云南，和青海的一小部分，缅甸的极北方。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051322266165185.jpg\" alt=\"\"></p>\n<p><strong>7．晋（265-420年）</strong><br>西晋的国土大小为920万平方公里。在云贵两地上略少于蜀的控制，在越南和朝鲜的土地缩小了。但略增加了内蒙的土地。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323111394665.jpg\" alt=\"\"></p>\n<p><strong>8．五胡十六国（304-439年）</strong></p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051323282052059.jpg\" alt=\"\"></p>\n<p><strong>9．南北朝（420-581年）</strong><br>国土总合约为935万平方公里，增加了几乎所有剩余的内蒙和部分外蒙的土地</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051324030096475.jpg\" alt=\"\"></p>\n<p><strong>10．隋（581-618年）</strong><br>国土为840万平方公里，突厥占领了甘肃和宁夏相当大的土地，云南和贵州也正走向独立，丧失了所有在越南和朝鲜的国土</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325135214460.jpg\" alt=\"\"></p>\n<p><strong>11．唐（618-907年）</strong><br>强盛时的唐国土大的非常惊人，比现在中国少黑龙江和西藏与云南，多了中亚的大片土地，大半个蒙古国和俄贝加尔湖，共1240万平方公里，在数十年后竟缩为1030万平方公里，安史之乱后更是缩为800万平方公里，可谓史上巨大的缩水。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051325444403275.jpg\" alt=\"\"></p>\n<p><strong>12．五代十国（907-979）</strong><br>国家太多，地图略</p>\n<p><strong>13．宋（960-1179年）</strong><br>国土为460万平方公里，与现在中国比没有新疆，甘肃，宁夏，内蒙，整个东北三省，青海和西藏，云贵和台湾。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326097595854.jpg\" alt=\"\"></p>\n<p><strong>12．元（1206-1368年）</strong><br>1680万平方公里，马克思列宁毛泽东都视其是中国的朝代，忽必烈也自称是中国之主。国土包括整个中国和蒙古，和俄罗斯西伯利亚的大片土地，当是中国古代史上的第一</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326277464631.jpg\" alt=\"\"></p>\n<p><strong>13．明（1368-1644年）</strong><br>国土最大时，比现在少一小半西藏和大半新疆，内蒙古全部和东三省小半土地，俄罗斯极少土地。共710万平方公里。后来大为缩水，丧失西藏新疆和东北台湾，到灭亡时只剩下350万平方公里。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051326510684659.jpg\" alt=\"\"></p>\n<p><strong>14．清（1616-1911年）</strong><br>国土1310万平方公里，整个中国和外蒙和俄罗斯及中亚的一些土地，论大小算是中国各朝代第二。</p>\n<p><img src=\"http://file.100xuexi.com/XXSub/MatUpPT/Image/201512051327201782867.jpg\" alt=\"\"></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"http://www.diyifanwen.com/tool/lishichaodai/126100035061238.html\">中国历史朝代顺序表</a><br><a href=\"http://lishi.100xuexi.com/view/trend/20151205/288371.html\">中国各朝代历史地图</a><br><a href=\"http://img1.cache.netease.com/flvplayer081128/~false~0085_V6T2A4508~vimg2.ws.126.net/image/snapshot/2011/2/0/9/V6T2A4509~.swf\">世界历史发展视频</a></p>"},{"layout":"post","title":"【诗】陋室铭","date":"2017-05-03T03:07:51.000Z","comments":1,"_content":"---\n作者：刘禹锡(唐)\n\n\n\n山不在高， 有仙则名。 \n\n水不在深， 有龙则灵。 \n\n斯是陋室， 惟吾德馨。 \n\n苔痕上阶绿， 草色入帘青。 \n\n谈笑有鸿儒， 往来无白丁。 \n\n可以调素琴， 阅金经。 \n\n无丝竹之乱耳， 无案牍之劳形。 \n\n南阳诸葛庐， 西蜀子云亭。\n\n孔子云： 何陋之有？\n<!-- more -->\n\n![](/assets/img/think_poem_loushiming.jpg)\n\n---\n\n> 译：\n> \n> 山不在于高，有了神仙就出名。水不在于深，有了龙就显得有了灵气。这是简陋的房子，只是我（住屋的人）品德好（就感觉不到简陋了）。长到台阶上的苔痕颜色碧绿；草色青葱，映入帘中。到这里谈笑的都是知识渊博的大学者，交往的没有知识浅薄的人，可以弹奏不加装饰的古琴，阅读佛经。没有奏乐的声音扰乱双耳，没有官府的公文使身体劳累。南阳有诸葛亮的草庐，西蜀有扬子云的亭子。孔子说：“有什么简陋的呢?”\n\n","source":"_posts/think_loushimin_poem.md","raw":"---\nlayout: post\ntitle: \"【诗】陋室铭\"\ndate: 5/3/2017 11:07:51 AM \ncomments: true\ntags: \n\t- 随想 \n\t- 诗\n\t- 陋室铭\n---\n---\n作者：刘禹锡(唐)\n\n\n\n山不在高， 有仙则名。 \n\n水不在深， 有龙则灵。 \n\n斯是陋室， 惟吾德馨。 \n\n苔痕上阶绿， 草色入帘青。 \n\n谈笑有鸿儒， 往来无白丁。 \n\n可以调素琴， 阅金经。 \n\n无丝竹之乱耳， 无案牍之劳形。 \n\n南阳诸葛庐， 西蜀子云亭。\n\n孔子云： 何陋之有？\n<!-- more -->\n\n![](/assets/img/think_poem_loushiming.jpg)\n\n---\n\n> 译：\n> \n> 山不在于高，有了神仙就出名。水不在于深，有了龙就显得有了灵气。这是简陋的房子，只是我（住屋的人）品德好（就感觉不到简陋了）。长到台阶上的苔痕颜色碧绿；草色青葱，映入帘中。到这里谈笑的都是知识渊博的大学者，交往的没有知识浅薄的人，可以弹奏不加装饰的古琴，阅读佛经。没有奏乐的声音扰乱双耳，没有官府的公文使身体劳累。南阳有诸葛亮的草庐，西蜀有扬子云的亭子。孔子说：“有什么简陋的呢?”\n\n","slug":"think_loushimin_poem","published":1,"updated":"2017-05-03T12:26:01.969Z","photos":[],"link":"","_id":"cj2sutc4x000bv0lk33p2m51n","content":"<hr>\n<p>作者：刘禹锡(唐)</p>\n<p>山不在高， 有仙则名。 </p>\n<p>水不在深， 有龙则灵。 </p>\n<p>斯是陋室， 惟吾德馨。 </p>\n<p>苔痕上阶绿， 草色入帘青。 </p>\n<p>谈笑有鸿儒， 往来无白丁。 </p>\n<p>可以调素琴， 阅金经。 </p>\n<p>无丝竹之乱耳， 无案牍之劳形。 </p>\n<p>南阳诸葛庐， 西蜀子云亭。</p>\n<p>孔子云： 何陋之有？<br><a id=\"more\"></a></p>\n<p><img src=\"/assets/img/think_poem_loushiming.jpg\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>译：</p>\n<p>山不在于高，有了神仙就出名。水不在于深，有了龙就显得有了灵气。这是简陋的房子，只是我（住屋的人）品德好（就感觉不到简陋了）。长到台阶上的苔痕颜色碧绿；草色青葱，映入帘中。到这里谈笑的都是知识渊博的大学者，交往的没有知识浅薄的人，可以弹奏不加装饰的古琴，阅读佛经。没有奏乐的声音扰乱双耳，没有官府的公文使身体劳累。南阳有诸葛亮的草庐，西蜀有扬子云的亭子。孔子说：“有什么简陋的呢?”</p>\n</blockquote>\n","excerpt":"<hr>\n<p>作者：刘禹锡(唐)</p>\n<p>山不在高， 有仙则名。 </p>\n<p>水不在深， 有龙则灵。 </p>\n<p>斯是陋室， 惟吾德馨。 </p>\n<p>苔痕上阶绿， 草色入帘青。 </p>\n<p>谈笑有鸿儒， 往来无白丁。 </p>\n<p>可以调素琴， 阅金经。 </p>\n<p>无丝竹之乱耳， 无案牍之劳形。 </p>\n<p>南阳诸葛庐， 西蜀子云亭。</p>\n<p>孔子云： 何陋之有？<br>","more":"</p>\n<p><img src=\"/assets/img/think_poem_loushiming.jpg\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>译：</p>\n<p>山不在于高，有了神仙就出名。水不在于深，有了龙就显得有了灵气。这是简陋的房子，只是我（住屋的人）品德好（就感觉不到简陋了）。长到台阶上的苔痕颜色碧绿；草色青葱，映入帘中。到这里谈笑的都是知识渊博的大学者，交往的没有知识浅薄的人，可以弹奏不加装饰的古琴，阅读佛经。没有奏乐的声音扰乱双耳，没有官府的公文使身体劳累。南阳有诸葛亮的草庐，西蜀有扬子云的亭子。孔子说：“有什么简陋的呢?”</p>\n</blockquote>"},{"layout":"post","title":"学习网址","date":"2017-03-17T13:59:30.000Z","comments":1,"_content":"---\n\n\n# 技术学习网址\n|   网址1   | 网址2  |  网址3    |  网址4     |\n| :---: | :---: | :---: | :---: | \n| [Markdown学习](https://wizardforcel.gitbooks.io/markdown-simple-world/content/2.html)  | [Markdown语法学习](http://www.jianshu.com/p/0b257de21eb5)  |[RxJava学习](http://gank.io/post/560e15be2dca930e00da1083)|[Android组件化](http://www.jianshu.com/p/2af3795957a8)|\n| [Airbnb的Lottie动画开源框架](http://www.jianshu.com/p/9a2136ecbc7b)   | [Lottie官网](http://www.lottiefiles.com/?page=2)  |[MaterialDesign安卓开源库](https://github.com/lightSky/Awesome-MaterialDesign) | [常用框架源码解析](http://a.codekk.com/)   |\n\n# Github牛人\n|  昵称   | 博客  | Github地址   |\n| :---: | :---: | :---: |\n|GcsSloop|[GcsSloop的博客](http://www.gcssloop.com/)|[GcsSloop的Github](https://github.com/GcsSloop)|","source":"_posts/tech_study_website.md","raw":"---\nlayout: post\ntitle: \"学习网址\"\ndate: 3/17/2017 9:59:30 PM \ncomments: true\ntags: \n\t- 技术 \n---\n---\n\n\n# 技术学习网址\n|   网址1   | 网址2  |  网址3    |  网址4     |\n| :---: | :---: | :---: | :---: | \n| [Markdown学习](https://wizardforcel.gitbooks.io/markdown-simple-world/content/2.html)  | [Markdown语法学习](http://www.jianshu.com/p/0b257de21eb5)  |[RxJava学习](http://gank.io/post/560e15be2dca930e00da1083)|[Android组件化](http://www.jianshu.com/p/2af3795957a8)|\n| [Airbnb的Lottie动画开源框架](http://www.jianshu.com/p/9a2136ecbc7b)   | [Lottie官网](http://www.lottiefiles.com/?page=2)  |[MaterialDesign安卓开源库](https://github.com/lightSky/Awesome-MaterialDesign) | [常用框架源码解析](http://a.codekk.com/)   |\n\n# Github牛人\n|  昵称   | 博客  | Github地址   |\n| :---: | :---: | :---: |\n|GcsSloop|[GcsSloop的博客](http://www.gcssloop.com/)|[GcsSloop的Github](https://github.com/GcsSloop)|","slug":"tech_study_website","published":1,"updated":"2017-05-12T10:37:52.882Z","photos":[],"link":"","_id":"cj2sutc50000dv0lkvw9v1kb2","content":"<hr>\n<h1 id=\"技术学习网址\"><a href=\"#技术学习网址\" class=\"headerlink\" title=\"技术学习网址\"></a>技术学习网址</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">网址1</th>\n<th style=\"text-align:center\">网址2</th>\n<th style=\"text-align:center\">网址3</th>\n<th style=\"text-align:center\">网址4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://wizardforcel.gitbooks.io/markdown-simple-world/content/2.html\" target=\"_blank\" rel=\"external\">Markdown学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/0b257de21eb5\" target=\"_blank\" rel=\"external\">Markdown语法学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">RxJava学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/2af3795957a8\" target=\"_blank\" rel=\"external\">Android组件化</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/9a2136ecbc7b\" target=\"_blank\" rel=\"external\">Airbnb的Lottie动画开源框架</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.lottiefiles.com/?page=2\" target=\"_blank\" rel=\"external\">Lottie官网</a></td>\n<td style=\"text-align:center\"><a href=\"https://github.com/lightSky/Awesome-MaterialDesign\" target=\"_blank\" rel=\"external\">MaterialDesign安卓开源库</a></td>\n<td style=\"text-align:center\"><a href=\"http://a.codekk.com/\" target=\"_blank\" rel=\"external\">常用框架源码解析</a></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Github牛人\"><a href=\"#Github牛人\" class=\"headerlink\" title=\"Github牛人\"></a>Github牛人</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">昵称</th>\n<th style=\"text-align:center\">博客</th>\n<th style=\"text-align:center\">Github地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">GcsSloop</td>\n<td style=\"text-align:center\"><a href=\"http://www.gcssloop.com/\" target=\"_blank\" rel=\"external\">GcsSloop的博客</a></td>\n<td style=\"text-align:center\"><a href=\"https://github.com/GcsSloop\" target=\"_blank\" rel=\"external\">GcsSloop的Github</a></td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<hr>\n<h1 id=\"技术学习网址\"><a href=\"#技术学习网址\" class=\"headerlink\" title=\"技术学习网址\"></a>技术学习网址</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">网址1</th>\n<th style=\"text-align:center\">网址2</th>\n<th style=\"text-align:center\">网址3</th>\n<th style=\"text-align:center\">网址4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://wizardforcel.gitbooks.io/markdown-simple-world/content/2.html\">Markdown学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/0b257de21eb5\">Markdown语法学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://gank.io/post/560e15be2dca930e00da1083\">RxJava学习</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/2af3795957a8\">Android组件化</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.jianshu.com/p/9a2136ecbc7b\">Airbnb的Lottie动画开源框架</a></td>\n<td style=\"text-align:center\"><a href=\"http://www.lottiefiles.com/?page=2\">Lottie官网</a></td>\n<td style=\"text-align:center\"><a href=\"https://github.com/lightSky/Awesome-MaterialDesign\">MaterialDesign安卓开源库</a></td>\n<td style=\"text-align:center\"><a href=\"http://a.codekk.com/\">常用框架源码解析</a></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Github牛人\"><a href=\"#Github牛人\" class=\"headerlink\" title=\"Github牛人\"></a>Github牛人</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">昵称</th>\n<th style=\"text-align:center\">博客</th>\n<th style=\"text-align:center\">Github地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">GcsSloop</td>\n<td style=\"text-align:center\"><a href=\"http://www.gcssloop.com/\">GcsSloop的博客</a></td>\n<td style=\"text-align:center\"><a href=\"https://github.com/GcsSloop\">GcsSloop的Github</a></td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"人生的意义","date":"2017-05-10T03:09:26.000Z","comments":1,"_content":"---\n![](/assets/img/think_life_meaningful.jpg)\n\n如果你问我,人生有啥意义？\n我会说：人生毫无意义，所谓的人生意义需要自己去下定义，自己去寻找属于自己的人生意义。\n\n人一生很短暂，平均也就八十多个春夏秋冬，也就三万多个小时；\n这一生，你想要怎样过活，必须由你自己来决定。\n\n父母，亲人，他们也都不是你自己；\n他们的话，始终也只是建议，重点在于你。\n\n你可以采纳吸收，也可以弃之不用。\n\n我们每一个人，都是独一无二的，也都可以独立活出自己想要的生活。\n不需要过多的焦虑，跟随自己的内心，你的内心会告诉你答案。\n\n\n\n","source":"_posts/think_life_meaningful.md","raw":"---\nlayout: post\ntitle: \"人生的意义\"\ndate: 5/10/2017 11:09:26 AM  \ncomments: true\ntags: \n\t- 随想 \n\t- 人生的意义\n---\n---\n![](/assets/img/think_life_meaningful.jpg)\n\n如果你问我,人生有啥意义？\n我会说：人生毫无意义，所谓的人生意义需要自己去下定义，自己去寻找属于自己的人生意义。\n\n人一生很短暂，平均也就八十多个春夏秋冬，也就三万多个小时；\n这一生，你想要怎样过活，必须由你自己来决定。\n\n父母，亲人，他们也都不是你自己；\n他们的话，始终也只是建议，重点在于你。\n\n你可以采纳吸收，也可以弃之不用。\n\n我们每一个人，都是独一无二的，也都可以独立活出自己想要的生活。\n不需要过多的焦虑，跟随自己的内心，你的内心会告诉你答案。\n\n\n\n","slug":"think_life_meaningful","published":1,"updated":"2017-05-10T03:34:28.417Z","photos":[],"link":"","_id":"cj2sutc51000fv0lknm8n1qka","content":"<hr>\n<p><img src=\"/assets/img/think_life_meaningful.jpg\" alt=\"\"></p>\n<p>如果你问我,人生有啥意义？<br>我会说：人生毫无意义，所谓的人生意义需要自己去下定义，自己去寻找属于自己的人生意义。</p>\n<p>人一生很短暂，平均也就八十多个春夏秋冬，也就三万多个小时；<br>这一生，你想要怎样过活，必须由你自己来决定。</p>\n<p>父母，亲人，他们也都不是你自己；<br>他们的话，始终也只是建议，重点在于你。</p>\n<p>你可以采纳吸收，也可以弃之不用。</p>\n<p>我们每一个人，都是独一无二的，也都可以独立活出自己想要的生活。<br>不需要过多的焦虑，跟随自己的内心，你的内心会告诉你答案。</p>\n","excerpt":"","more":"<hr>\n<p><img src=\"/assets/img/think_life_meaningful.jpg\" alt=\"\"></p>\n<p>如果你问我,人生有啥意义？<br>我会说：人生毫无意义，所谓的人生意义需要自己去下定义，自己去寻找属于自己的人生意义。</p>\n<p>人一生很短暂，平均也就八十多个春夏秋冬，也就三万多个小时；<br>这一生，你想要怎样过活，必须由你自己来决定。</p>\n<p>父母，亲人，他们也都不是你自己；<br>他们的话，始终也只是建议，重点在于你。</p>\n<p>你可以采纳吸收，也可以弃之不用。</p>\n<p>我们每一个人，都是独一无二的，也都可以独立活出自己想要的生活。<br>不需要过多的焦虑，跟随自己的内心，你的内心会告诉你答案。</p>\n"},{"layout":"post","title":"【诗】船 白桦","date":"2017-03-16T13:50:37.000Z","comments":1,"_content":"---\n我有过多次这样的奇遇\n从天堂到地狱只在瞬息之间\n每一朵可爱、温柔的浪花\n都成了突然崛起、随即倾倒的高山\n \n每一滴海水都变脸变色\n刚刚还是那样美丽、蔚蓝\n旋涡纠缠着旋涡\n我被抛向高空又投进深渊……\n\n当时我甚至想到过轻生\n眼前一片苦海无边；\n放弃了希望就象放弃了舵柄，\n在暴力之下只能沉默和哀叹。\n<!-- more -->\n\n今天我才有资格嘲笑昨天的自己，\n为昨天落叶似的惶恐感到羞惭；\n虚度了多少年华，\n船身多次被礁石撞穿……\n \n千万次在大洋里撒网，\n才捕获到一点点生活的经验，\n才恍然大悟，\n啊！道理原是如此浅显：\n\n你要航行吗？\n必然会有千妖百怪出来阻拦；\n暴虐的欺凌是它们的游戏，\n制造灭亡是它们唯一的才干。\n \n命中注定我要常常和它们相逢，\n因为我的名字叫做船；\n面对强大于自身千万倍的对手，\n能援救自己的只有清醒和勇敢。\n \n恐惧只能使自己盲目，\n盲目只能夸大魔鬼的狰狞嘴脸；\n也许我的样子比它们更可怕，\n当我以生命相拼，一往无前！\n\n只要我还有一根完整的龙骨，\n绝不驶进避风的港湾；\n把生命放在征途上，\n让勇敢来决定道路的宽窄、长短。\n \n我完完全全的自由了，\n船头成为埋葬它们的铁铲；\n我在波浪中有节奏地跳跃，\n就象荡着一个巨大的秋千。\n\n即使它们终于把我撕碎，\n变成一些残破的木片；\n我不会沉沦，决不！\n我还会在浪尖上飞旋。\n \n后来者还会在残片上认出我，\n未来的诗人会喟然长叹：\n“这里有一个幸福的灵魂，\n它曾经是一艘前进着的航船……”\n\n","source":"_posts/think_ship_poem.md","raw":"---\nlayout: post\ntitle: \"【诗】船 白桦\"\ndate: 3/16/2017 9:50:37 PM \ncomments: true\ntags: \n\t- 随想 \n---\n---\n我有过多次这样的奇遇\n从天堂到地狱只在瞬息之间\n每一朵可爱、温柔的浪花\n都成了突然崛起、随即倾倒的高山\n \n每一滴海水都变脸变色\n刚刚还是那样美丽、蔚蓝\n旋涡纠缠着旋涡\n我被抛向高空又投进深渊……\n\n当时我甚至想到过轻生\n眼前一片苦海无边；\n放弃了希望就象放弃了舵柄，\n在暴力之下只能沉默和哀叹。\n<!-- more -->\n\n今天我才有资格嘲笑昨天的自己，\n为昨天落叶似的惶恐感到羞惭；\n虚度了多少年华，\n船身多次被礁石撞穿……\n \n千万次在大洋里撒网，\n才捕获到一点点生活的经验，\n才恍然大悟，\n啊！道理原是如此浅显：\n\n你要航行吗？\n必然会有千妖百怪出来阻拦；\n暴虐的欺凌是它们的游戏，\n制造灭亡是它们唯一的才干。\n \n命中注定我要常常和它们相逢，\n因为我的名字叫做船；\n面对强大于自身千万倍的对手，\n能援救自己的只有清醒和勇敢。\n \n恐惧只能使自己盲目，\n盲目只能夸大魔鬼的狰狞嘴脸；\n也许我的样子比它们更可怕，\n当我以生命相拼，一往无前！\n\n只要我还有一根完整的龙骨，\n绝不驶进避风的港湾；\n把生命放在征途上，\n让勇敢来决定道路的宽窄、长短。\n \n我完完全全的自由了，\n船头成为埋葬它们的铁铲；\n我在波浪中有节奏地跳跃，\n就象荡着一个巨大的秋千。\n\n即使它们终于把我撕碎，\n变成一些残破的木片；\n我不会沉沦，决不！\n我还会在浪尖上飞旋。\n \n后来者还会在残片上认出我，\n未来的诗人会喟然长叹：\n“这里有一个幸福的灵魂，\n它曾经是一艘前进着的航船……”\n\n","slug":"think_ship_poem","published":1,"updated":"2017-05-03T06:41:59.376Z","photos":[],"link":"","_id":"cj2sutc65001rv0lk2jzzoiqq","content":"<hr>\n<p>我有过多次这样的奇遇<br>从天堂到地狱只在瞬息之间<br>每一朵可爱、温柔的浪花<br>都成了突然崛起、随即倾倒的高山</p>\n<p>每一滴海水都变脸变色<br>刚刚还是那样美丽、蔚蓝<br>旋涡纠缠着旋涡<br>我被抛向高空又投进深渊……</p>\n<p>当时我甚至想到过轻生<br>眼前一片苦海无边；<br>放弃了希望就象放弃了舵柄，<br>在暴力之下只能沉默和哀叹。<br><a id=\"more\"></a></p>\n<p>今天我才有资格嘲笑昨天的自己，<br>为昨天落叶似的惶恐感到羞惭；<br>虚度了多少年华，<br>船身多次被礁石撞穿……</p>\n<p>千万次在大洋里撒网，<br>才捕获到一点点生活的经验，<br>才恍然大悟，<br>啊！道理原是如此浅显：</p>\n<p>你要航行吗？<br>必然会有千妖百怪出来阻拦；<br>暴虐的欺凌是它们的游戏，<br>制造灭亡是它们唯一的才干。</p>\n<p>命中注定我要常常和它们相逢，<br>因为我的名字叫做船；<br>面对强大于自身千万倍的对手，<br>能援救自己的只有清醒和勇敢。</p>\n<p>恐惧只能使自己盲目，<br>盲目只能夸大魔鬼的狰狞嘴脸；<br>也许我的样子比它们更可怕，<br>当我以生命相拼，一往无前！</p>\n<p>只要我还有一根完整的龙骨，<br>绝不驶进避风的港湾；<br>把生命放在征途上，<br>让勇敢来决定道路的宽窄、长短。</p>\n<p>我完完全全的自由了，<br>船头成为埋葬它们的铁铲；<br>我在波浪中有节奏地跳跃，<br>就象荡着一个巨大的秋千。</p>\n<p>即使它们终于把我撕碎，<br>变成一些残破的木片；<br>我不会沉沦，决不！<br>我还会在浪尖上飞旋。</p>\n<p>后来者还会在残片上认出我，<br>未来的诗人会喟然长叹：<br>“这里有一个幸福的灵魂，<br>它曾经是一艘前进着的航船……”</p>\n","excerpt":"<hr>\n<p>我有过多次这样的奇遇<br>从天堂到地狱只在瞬息之间<br>每一朵可爱、温柔的浪花<br>都成了突然崛起、随即倾倒的高山</p>\n<p>每一滴海水都变脸变色<br>刚刚还是那样美丽、蔚蓝<br>旋涡纠缠着旋涡<br>我被抛向高空又投进深渊……</p>\n<p>当时我甚至想到过轻生<br>眼前一片苦海无边；<br>放弃了希望就象放弃了舵柄，<br>在暴力之下只能沉默和哀叹。<br>","more":"</p>\n<p>今天我才有资格嘲笑昨天的自己，<br>为昨天落叶似的惶恐感到羞惭；<br>虚度了多少年华，<br>船身多次被礁石撞穿……</p>\n<p>千万次在大洋里撒网，<br>才捕获到一点点生活的经验，<br>才恍然大悟，<br>啊！道理原是如此浅显：</p>\n<p>你要航行吗？<br>必然会有千妖百怪出来阻拦；<br>暴虐的欺凌是它们的游戏，<br>制造灭亡是它们唯一的才干。</p>\n<p>命中注定我要常常和它们相逢，<br>因为我的名字叫做船；<br>面对强大于自身千万倍的对手，<br>能援救自己的只有清醒和勇敢。</p>\n<p>恐惧只能使自己盲目，<br>盲目只能夸大魔鬼的狰狞嘴脸；<br>也许我的样子比它们更可怕，<br>当我以生命相拼，一往无前！</p>\n<p>只要我还有一根完整的龙骨，<br>绝不驶进避风的港湾；<br>把生命放在征途上，<br>让勇敢来决定道路的宽窄、长短。</p>\n<p>我完完全全的自由了，<br>船头成为埋葬它们的铁铲；<br>我在波浪中有节奏地跳跃，<br>就象荡着一个巨大的秋千。</p>\n<p>即使它们终于把我撕碎，<br>变成一些残破的木片；<br>我不会沉沦，决不！<br>我还会在浪尖上飞旋。</p>\n<p>后来者还会在残片上认出我，<br>未来的诗人会喟然长叹：<br>“这里有一个幸福的灵魂，<br>它曾经是一艘前进着的航船……”</p>"},{"layout":"post","title":"[韩国*济州岛]旅行摄影","date":"2017-03-16T13:45:45.000Z","comments":1,"_content":"---\n# 海中的孤岛 #\n![](http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBN3dmYUVXT2NyNXdpV2NleHhQeFNkWkwyTE4xVlF1MHB3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n在我们心中，都有属于我们自己的一座孤岛。\n<!-- more -->\n\n# 城山日出峰 #\n![](http://imglf.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBOVdCY09zSXNiTmVPTlRub05sUHNnZU5qQXZ0c2s5cy9BPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n\n# 城山日出峰 #\n![](http://imglf0.nosdn.127.net/img/MUgydEdvOEdHeHVvelcvQVV0d09xcHpaZmczQ1hNQ0dNbkIvTmpsK3F1RDdzTzJYZmRVdk9RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n\n# 济州美景 #\n![](http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHVhVk1sZEllRGhUdTZwSTlsSWlMa0lFYjVvSWQ3aTlGVXZOb1c4ZjZQeHJnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)","source":"_posts/travel_korea_jeju.md","raw":"---\nlayout: post\ntitle: \"[韩国*济州岛]旅行摄影\"\ndate: 3/16/2017 9:45:45 PM \ncomments: true\ntags: \n\t- 摄影 \n\t- 旅行\n---\n---\n# 海中的孤岛 #\n![](http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBN3dmYUVXT2NyNXdpV2NleHhQeFNkWkwyTE4xVlF1MHB3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n在我们心中，都有属于我们自己的一座孤岛。\n<!-- more -->\n\n# 城山日出峰 #\n![](http://imglf.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBOVdCY09zSXNiTmVPTlRub05sUHNnZU5qQXZ0c2s5cy9BPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n\n# 城山日出峰 #\n![](http://imglf0.nosdn.127.net/img/MUgydEdvOEdHeHVvelcvQVV0d09xcHpaZmczQ1hNQ0dNbkIvTmpsK3F1RDdzTzJYZmRVdk9RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\n\n# 济州美景 #\n![](http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHVhVk1sZEllRGhUdTZwSTlsSWlMa0lFYjVvSWQ3aTlGVXZOb1c4ZjZQeHJnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)","slug":"travel_korea_jeju","published":1,"updated":"2017-03-17T13:55:21.435Z","photos":[],"link":"","_id":"cj2sutc6g001tv0lkhacbdzcd","content":"<hr>\n<h1 id=\"海中的孤岛\"><a href=\"#海中的孤岛\" class=\"headerlink\" title=\"海中的孤岛\"></a>海中的孤岛</h1><p><img src=\"http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBN3dmYUVXT2NyNXdpV2NleHhQeFNkWkwyTE4xVlF1MHB3PT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"><br>在我们心中，都有属于我们自己的一座孤岛。<br><a id=\"more\"></a></p>\n<h1 id=\"城山日出峰\"><a href=\"#城山日出峰\" class=\"headerlink\" title=\"城山日出峰\"></a>城山日出峰</h1><p><img src=\"http://imglf.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBOVdCY09zSXNiTmVPTlRub05sUHNnZU5qQXZ0c2s5cy9BPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>\n<h1 id=\"城山日出峰-1\"><a href=\"#城山日出峰-1\" class=\"headerlink\" title=\"城山日出峰\"></a>城山日出峰</h1><p><img src=\"http://imglf0.nosdn.127.net/img/MUgydEdvOEdHeHVvelcvQVV0d09xcHpaZmczQ1hNQ0dNbkIvTmpsK3F1RDdzTzJYZmRVdk9RPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>\n<h1 id=\"济州美景\"><a href=\"#济州美景\" class=\"headerlink\" title=\"济州美景\"></a>济州美景</h1><p><img src=\"http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHVhVk1sZEllRGhUdTZwSTlsSWlMa0lFYjVvSWQ3aTlGVXZOb1c4ZjZQeHJnPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>\n","excerpt":"<hr>\n<h1 id=\"海中的孤岛\"><a href=\"#海中的孤岛\" class=\"headerlink\" title=\"海中的孤岛\"></a>海中的孤岛</h1><p><img src=\"http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBN3dmYUVXT2NyNXdpV2NleHhQeFNkWkwyTE4xVlF1MHB3PT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"><br>在我们心中，都有属于我们自己的一座孤岛。<br>","more":"</p>\n<h1 id=\"城山日出峰\"><a href=\"#城山日出峰\" class=\"headerlink\" title=\"城山日出峰\"></a>城山日出峰</h1><p><img src=\"http://imglf.nosdn.127.net/img/MUgydEdvOEdHeHZ4NjYwRjB5NDZBOVdCY09zSXNiTmVPTlRub05sUHNnZU5qQXZ0c2s5cy9BPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>\n<h1 id=\"城山日出峰-1\"><a href=\"#城山日出峰-1\" class=\"headerlink\" title=\"城山日出峰\"></a>城山日出峰</h1><p><img src=\"http://imglf0.nosdn.127.net/img/MUgydEdvOEdHeHVvelcvQVV0d09xcHpaZmczQ1hNQ0dNbkIvTmpsK3F1RDdzTzJYZmRVdk9RPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>\n<h1 id=\"济州美景\"><a href=\"#济州美景\" class=\"headerlink\" title=\"济州美景\"></a>济州美景</h1><p><img src=\"http://imglf2.nosdn.127.net/img/MUgydEdvOEdHeHVhVk1sZEllRGhUdTZwSTlsSWlMa0lFYjVvSWQ3aTlGVXZOb1c4ZjZQeHJnPT0.jpg?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg\" alt=\"\"></p>"},{"layout":"post","title":"【Android基础】Activity的启动模式","date":"2017-03-25T04:02:11.000Z","comments":1,"_content":"---\n 在Android中，当我们多次启动同一个Activity时，系统会创建多个实例，并把它们按照先进后出的原则一一放入任务栈中，当我们按back键时，就会有一个activity从任务栈顶移除，重复下去，直到任务栈为空，系统就会回收这个任务栈。但是这样以来，系统多次启动同一个Activity时就会重复创建多个实例，这种做法显然不合理，为了能够优化这个问题，Android提供四种启动模式来修改系统这一默认行为。\n> 四种启动模式分别为：\n> \n- standard\n- singleTop\n- singleTask\n- singleInstance\n \n   \n>启动模式配置\n```xml\n<activity android:name=\".Activity\" android:launchMode=\"启动模式\">\n```\n\n# Activity的四种启动模式\n\n----------\n\n**1.Standard-默认模式**\n\n默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。\n<!-- more -->\n**2.SingleTop-栈顶复用模式** \n\n可以有多个实例，但是不允许多个相同Activity叠加。三种情况：\n> 1.如果当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法\n> \n> 2.当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例\n> \n> 3.当前栈中不存在该Activity的实例时，其行为同standard启动模式\n\n\n>应用场景:\n>适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。\n\n\n**3.SingleTask-栈内复用模式**\n\n只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。\n\n如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。\n\n>应用场景:\n>适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。\n\n**4.SingleInstance-全局唯一模式**\n\n只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。\n\n>应用场景:\n>\n>适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。\n\n\n### Note：Activity的标签属性（taskAffinity)\ntaskAffinity属性\n>   每个Activity都有taskAffinity属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而任务栈也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。taskAffinity代码配置：\n```xml\nactivity android:name=\".Activity\" android:launchMode=\"启动模式\" android:taskAffinity=\"任务栈名（如：包名）\"/>\n```","source":"_posts/tech-android-act-start-mode.md","raw":"---\nlayout: post\ntitle: \"【Android基础】Activity的启动模式\"\ndate: 3/25/2017 12:02:11 PM \ncomments: true\ntags: \n\t- 技术\n\t- Android \n\t- Android基础\n---\n---\n 在Android中，当我们多次启动同一个Activity时，系统会创建多个实例，并把它们按照先进后出的原则一一放入任务栈中，当我们按back键时，就会有一个activity从任务栈顶移除，重复下去，直到任务栈为空，系统就会回收这个任务栈。但是这样以来，系统多次启动同一个Activity时就会重复创建多个实例，这种做法显然不合理，为了能够优化这个问题，Android提供四种启动模式来修改系统这一默认行为。\n> 四种启动模式分别为：\n> \n- standard\n- singleTop\n- singleTask\n- singleInstance\n \n   \n>启动模式配置\n```xml\n<activity android:name=\".Activity\" android:launchMode=\"启动模式\">\n```\n\n# Activity的四种启动模式\n\n----------\n\n**1.Standard-默认模式**\n\n默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。\n<!-- more -->\n**2.SingleTop-栈顶复用模式** \n\n可以有多个实例，但是不允许多个相同Activity叠加。三种情况：\n> 1.如果当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法\n> \n> 2.当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例\n> \n> 3.当前栈中不存在该Activity的实例时，其行为同standard启动模式\n\n\n>应用场景:\n>适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。\n\n\n**3.SingleTask-栈内复用模式**\n\n只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。\n\n如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。\n\n>应用场景:\n>适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。\n\n**4.SingleInstance-全局唯一模式**\n\n只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。\n\n>应用场景:\n>\n>适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。\n\n\n### Note：Activity的标签属性（taskAffinity)\ntaskAffinity属性\n>   每个Activity都有taskAffinity属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而任务栈也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。taskAffinity代码配置：\n```xml\nactivity android:name=\".Activity\" android:launchMode=\"启动模式\" android:taskAffinity=\"任务栈名（如：包名）\"/>\n```","slug":"tech-android-act-start-mode","published":1,"updated":"2017-05-12T10:35:00.448Z","photos":[],"link":"","_id":"cj2sutc6i001uv0lkzx5lzaz8","content":"<hr>\n<p> 在Android中，当我们多次启动同一个Activity时，系统会创建多个实例，并把它们按照先进后出的原则一一放入任务栈中，当我们按back键时，就会有一个activity从任务栈顶移除，重复下去，直到任务栈为空，系统就会回收这个任务栈。但是这样以来，系统多次启动同一个Activity时就会重复创建多个实例，这种做法显然不合理，为了能够优化这个问题，Android提供四种启动模式来修改系统这一默认行为。</p>\n<blockquote>\n<p>四种启动模式分别为：</p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance</li>\n</ul>\n<p>启动模式配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".Activity\"</span> <span class=\"attr\">android:launchMode</span>=<span class=\"string\">\"启动模式\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"Activity的四种启动模式\"><a href=\"#Activity的四种启动模式\" class=\"headerlink\" title=\"Activity的四种启动模式\"></a>Activity的四种启动模式</h1><hr>\n<p><strong>1.Standard-默认模式</strong></p>\n<p>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。<br><a id=\"more\"></a><br><strong>2.SingleTop-栈顶复用模式</strong> </p>\n<p>可以有多个实例，但是不允许多个相同Activity叠加。三种情况：</p>\n<blockquote>\n<p>1.如果当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法</p>\n<p>2.当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例</p>\n<p>3.当前栈中不存在该Activity的实例时，其行为同standard启动模式</p>\n<p>应用场景:<br>适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>\n</blockquote>\n<p><strong>3.SingleTask-栈内复用模式</strong></p>\n<p>只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。</p>\n<p>如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</p>\n<blockquote>\n<p>应用场景:<br>适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>\n</blockquote>\n<p><strong>4.SingleInstance-全局唯一模式</strong></p>\n<p>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</p>\n<blockquote>\n<p>应用场景:</p>\n<p>适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。</p>\n</blockquote>\n<h3 id=\"Note：Activity的标签属性（taskAffinity\"><a href=\"#Note：Activity的标签属性（taskAffinity\" class=\"headerlink\" title=\"Note：Activity的标签属性（taskAffinity)\"></a>Note：Activity的标签属性（taskAffinity)</h3><p>taskAffinity属性</p>\n<blockquote>\n<p>  每个Activity都有taskAffinity属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而任务栈也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。taskAffinity代码配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity android:name=\".Activity\" android:launchMode=\"启动模式\" android:taskAffinity=\"任务栈名（如：包名）\"/&gt;</div></pre></td></tr></table></figure></p>\n</blockquote>\n","excerpt":"<hr>\n<p> 在Android中，当我们多次启动同一个Activity时，系统会创建多个实例，并把它们按照先进后出的原则一一放入任务栈中，当我们按back键时，就会有一个activity从任务栈顶移除，重复下去，直到任务栈为空，系统就会回收这个任务栈。但是这样以来，系统多次启动同一个Activity时就会重复创建多个实例，这种做法显然不合理，为了能够优化这个问题，Android提供四种启动模式来修改系统这一默认行为。</p>\n<blockquote>\n<p>四种启动模式分别为：</p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance</li>\n</ul>\n<p>启动模式配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".Activity\"</span> <span class=\"attr\">android:launchMode</span>=<span class=\"string\">\"启动模式\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"Activity的四种启动模式\"><a href=\"#Activity的四种启动模式\" class=\"headerlink\" title=\"Activity的四种启动模式\"></a>Activity的四种启动模式</h1><hr>\n<p><strong>1.Standard-默认模式</strong></p>\n<p>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。<br>","more":"<br><strong>2.SingleTop-栈顶复用模式</strong> </p>\n<p>可以有多个实例，但是不允许多个相同Activity叠加。三种情况：</p>\n<blockquote>\n<p>1.如果当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法</p>\n<p>2.当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例</p>\n<p>3.当前栈中不存在该Activity的实例时，其行为同standard启动模式</p>\n<p>应用场景:<br>适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>\n</blockquote>\n<p><strong>3.SingleTask-栈内复用模式</strong></p>\n<p>只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。</p>\n<p>如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</p>\n<blockquote>\n<p>应用场景:<br>适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>\n</blockquote>\n<p><strong>4.SingleInstance-全局唯一模式</strong></p>\n<p>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</p>\n<blockquote>\n<p>应用场景:</p>\n<p>适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。</p>\n</blockquote>\n<h3 id=\"Note：Activity的标签属性（taskAffinity\"><a href=\"#Note：Activity的标签属性（taskAffinity\" class=\"headerlink\" title=\"Note：Activity的标签属性（taskAffinity)\"></a>Note：Activity的标签属性（taskAffinity)</h3><p>taskAffinity属性</p>\n<blockquote>\n<p>  每个Activity都有taskAffinity属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而任务栈也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。taskAffinity代码配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity android:name=\".Activity\" android:launchMode=\"启动模式\" android:taskAffinity=\"任务栈名（如：包名）\"/&gt;</div></pre></td></tr></table></figure></p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj2sutc4a0000v0lkxazdsm56","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc51000ev0lk4h1vjdct"},{"post_id":"cj2sutc4a0000v0lkxazdsm56","tag_id":"cj2sutc4p0006v0lk2j4mbspc","_id":"cj2sutc53000gv0lk28of2k3n"},{"post_id":"cj2sutc4a0000v0lkxazdsm56","tag_id":"cj2sutc4v0009v0lklm86zovr","_id":"cj2sutc55000iv0lk2ne9ye78"},{"post_id":"cj2sutc50000dv0lkvw9v1kb2","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc55000jv0lkhhlhuzuh"},{"post_id":"cj2sutc4e0001v0lktuazmc91","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc57000mv0lkglx6foqh"},{"post_id":"cj2sutc4e0001v0lktuazmc91","tag_id":"cj2sutc4p0006v0lk2j4mbspc","_id":"cj2sutc57000nv0lk7b6e0lc0"},{"post_id":"cj2sutc4e0001v0lktuazmc91","tag_id":"cj2sutc55000kv0lk33f4mh2d","_id":"cj2sutc58000pv0lkw4ezp3uj"},{"post_id":"cj2sutc4i0003v0lkdheyd5ox","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc5a000sv0lktwm8s0yf"},{"post_id":"cj2sutc4i0003v0lkdheyd5ox","tag_id":"cj2sutc57000ov0lkkvptzqly","_id":"cj2sutc5a000tv0lkrbf2xo25"},{"post_id":"cj2sutc4i0003v0lkdheyd5ox","tag_id":"cj2sutc58000qv0lkz6zy1c4k","_id":"cj2sutc5a000vv0lk3gh5taw8"},{"post_id":"cj2sutc4j0004v0lk2kwbrmfy","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc5a000wv0lk07azrpro"},{"post_id":"cj2sutc4j0004v0lk2kwbrmfy","tag_id":"cj2sutc4p0006v0lk2j4mbspc","_id":"cj2sutc5c000yv0lkqwep9ngf"},{"post_id":"cj2sutc4o0005v0lkvzlbd5u0","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc5c0011v0lklgtiiu18"},{"post_id":"cj2sutc4o0005v0lkvzlbd5u0","tag_id":"cj2sutc5a000uv0lkr9hz7j3g","_id":"cj2sutc5d0012v0lk772ufsrv"},{"post_id":"cj2sutc4o0005v0lkvzlbd5u0","tag_id":"cj2sutc5b000xv0lkvj4pi3tt","_id":"cj2sutc5e0014v0lkhpspukos"},{"post_id":"cj2sutc4o0005v0lkvzlbd5u0","tag_id":"cj2sutc5c000zv0lkvospngqw","_id":"cj2sutc5e0015v0lkkaf9cjop"},{"post_id":"cj2sutc4q0007v0lkftbzvoif","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc5f0017v0lk13dbfgh1"},{"post_id":"cj2sutc4q0007v0lkftbzvoif","tag_id":"cj2sutc4p0006v0lk2j4mbspc","_id":"cj2sutc5f0018v0lkfhqu5qw6"},{"post_id":"cj2sutc4q0007v0lkftbzvoif","tag_id":"cj2sutc5c0010v0lkndft6i6d","_id":"cj2sutc5g001av0lkx8axst8h"},{"post_id":"cj2sutc4q0007v0lkftbzvoif","tag_id":"cj2sutc5d0013v0lke4txh7j4","_id":"cj2sutc5g001bv0lk8ngozire"},{"post_id":"cj2sutc4r0008v0lkg8vbmdfy","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc5h001dv0lkcscsqegm"},{"post_id":"cj2sutc4r0008v0lkg8vbmdfy","tag_id":"cj2sutc5e0016v0lk4jqy777u","_id":"cj2sutc5i001ev0lkcw4odo8y"},{"post_id":"cj2sutc4x000av0lk6fxgwzdi","tag_id":"cj2sutc5f0019v0lktfbqr0tj","_id":"cj2sutc5j001gv0lk82eqz61z"},{"post_id":"cj2sutc4x000av0lk6fxgwzdi","tag_id":"cj2sutc5g001cv0lkbxrzoez4","_id":"cj2sutc5j001hv0lkwx1j8dvw"},{"post_id":"cj2sutc4x000bv0lk33p2m51n","tag_id":"cj2sutc5f0019v0lktfbqr0tj","_id":"cj2sutc5m001lv0lkm8a81wae"},{"post_id":"cj2sutc4x000bv0lk33p2m51n","tag_id":"cj2sutc5j001iv0lkoon49qb8","_id":"cj2sutc5m001mv0lk2ptk37c7"},{"post_id":"cj2sutc4x000bv0lk33p2m51n","tag_id":"cj2sutc5j001jv0lkgydszxhl","_id":"cj2sutc5n001ov0lkh29bladb"},{"post_id":"cj2sutc51000fv0lknm8n1qka","tag_id":"cj2sutc5f0019v0lktfbqr0tj","_id":"cj2sutc5n001pv0lkuspej03r"},{"post_id":"cj2sutc51000fv0lknm8n1qka","tag_id":"cj2sutc5m001nv0lk4wgpkil8","_id":"cj2sutc5o001qv0lknylf8fwg"},{"post_id":"cj2sutc65001rv0lk2jzzoiqq","tag_id":"cj2sutc5f0019v0lktfbqr0tj","_id":"cj2sutc67001sv0lkln260rx6"},{"post_id":"cj2sutc6i001uv0lkzx5lzaz8","tag_id":"cj2sutc4g0002v0lk84igewjj","_id":"cj2sutc6k001wv0lk7fzzxicq"},{"post_id":"cj2sutc6i001uv0lkzx5lzaz8","tag_id":"cj2sutc4p0006v0lk2j4mbspc","_id":"cj2sutc6k001xv0lkqtwbmwvh"},{"post_id":"cj2sutc6i001uv0lkzx5lzaz8","tag_id":"cj2sutc5c0010v0lkndft6i6d","_id":"cj2sutc6l001zv0lkvr79xbkr"},{"post_id":"cj2sutc6g001tv0lkhacbdzcd","tag_id":"cj2sutc6j001vv0lkoqvoola5","_id":"cj2sutc6m0020v0lk4x7wzhbh"},{"post_id":"cj2sutc6g001tv0lkhacbdzcd","tag_id":"cj2sutc6k001yv0lkr4gbad0i","_id":"cj2sutc6m0021v0lktjpjji29"}],"Tag":[{"name":"技术","_id":"cj2sutc4g0002v0lk84igewjj"},{"name":"Android","_id":"cj2sutc4p0006v0lk2j4mbspc"},{"name":"开源框架","_id":"cj2sutc4v0009v0lklm86zovr"},{"name":"加解密算法","_id":"cj2sutc55000kv0lk33f4mh2d"},{"name":"Java","_id":"cj2sutc57000ov0lkkvptzqly"},{"name":"Java基础","_id":"cj2sutc58000qv0lkz6zy1c4k"},{"name":"Rxjava","_id":"cj2sutc5a000uv0lkr9hz7j3g"},{"name":"Rxandroid","_id":"cj2sutc5b000xv0lkvj4pi3tt"},{"name":"响应式编程","_id":"cj2sutc5c000zv0lkvospngqw"},{"name":"Android基础","_id":"cj2sutc5c0010v0lkndft6i6d"},{"name":"MVP","_id":"cj2sutc5d0013v0lke4txh7j4"},{"name":"博客搭建","_id":"cj2sutc5e0016v0lk4jqy777u"},{"name":"随想","_id":"cj2sutc5f0019v0lktfbqr0tj"},{"name":"中国历史","_id":"cj2sutc5g001cv0lkbxrzoez4"},{"name":"诗","_id":"cj2sutc5j001iv0lkoon49qb8"},{"name":"陋室铭","_id":"cj2sutc5j001jv0lkgydszxhl"},{"name":"人生的意义","_id":"cj2sutc5m001nv0lk4wgpkil8"},{"name":"摄影","_id":"cj2sutc6j001vv0lkoqvoola5"},{"name":"旅行","_id":"cj2sutc6k001yv0lkr4gbad0i"}]}}